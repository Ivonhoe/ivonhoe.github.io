
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android动画总结 | 别辜负自己</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="说在开始这篇文档记录了一下自己在实际工作中实现的一些Android动画效果时的开发思路，总结了我自己如何看待Android动画问题，希望能给大家的动画开发提供一些思路和帮助。
一、Android动画基础1.1 动画类型
Frame Animation：帧动画，顺序播放事先做好的图像，是一种画面转换动画
Tween Animation:补间动画（或者叫渐变动画），通过对场景里的对象不断做图像变换(平">
<meta property="og:type" content="article">
<meta property="og:title" content="Android动画总结">
<meta property="og:url" content="https://ivonhoe.github.io/2015/02/09/Android动画总结/index.html">
<meta property="og:site_name" content="别辜负自己">
<meta property="og:description" content="说在开始这篇文档记录了一下自己在实际工作中实现的一些Android动画效果时的开发思路，总结了我自己如何看待Android动画问题，希望能给大家的动画开发提供一些思路和帮助。
一、Android动画基础1.1 动画类型
Frame Animation：帧动画，顺序播放事先做好的图像，是一种画面转换动画
Tween Animation:补间动画（或者叫渐变动画），通过对场景里的对象不断做图像变换(平">
<meta property="og:image" content="https://ivonhoe.github.io/res/android_animation/android_animation_animation_class.png">
<meta property="og:image" content="https://ivonhoe.github.io/res/android_animation/jiasu_jiansu.png">
<meta property="og:image" content="https://ivonhoe.github.io/res/android_animation/android_animation_interpolator_class.png">
<meta property="og:image" content="https://ivonhoe.github.io/res/android_animation/xiangsi.jpg">
<meta property="og:image" content="https://ivonhoe.github.io/android_animation/tubiaodonghua.jpg">
<meta property="og:image" content="https://ivonhoe.github.io/android_animation/guangbixiaoguo.jpg">
<meta property="og:image" content="https://ivonhoe.github.io/res/android_animation/choreographer_seq_diag.png">
<meta property="og:updated_time" content="2016-03-06T13:36:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android动画总结">
<meta name="twitter:description" content="说在开始这篇文档记录了一下自己在实际工作中实现的一些Android动画效果时的开发思路，总结了我自己如何看待Android动画问题，希望能给大家的动画开发提供一些思路和帮助。
一、Android动画基础1.1 动画类型
Frame Animation：帧动画，顺序播放事先做好的图像，是一种画面转换动画
Tween Animation:补间动画（或者叫渐变动画），通过对场景里的对象不断做图像变换(平">
  
    <link rel="alternative" href="/atom.xml" title="别辜负自己" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">别辜负自己</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Read The Fucking Source Code</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="ivonhoe.github.io">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-Android动画总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/09/Android动画总结/" class="article-date">
  <time datetime="2015-02-09T11:40:53.000Z" itemprop="datePublished">2月 9 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android动画总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="说在开始">说在开始</h3><p>这篇文档记录了一下自己在实际工作中实现的一些Android动画效果时的开发思路，总结了我自己如何看待Android动画问题，希望能给大家的动画开发提供一些思路和帮助。</p>
<h3 id="一、Android动画基础">一、Android动画基础</h3><h4 id="1-1_动画类型">1.1 动画类型</h4><ul>
<li><strong>Frame Animation：</strong><br>帧动画，顺序播放事先做好的图像，是一种画面转换动画</li>
<li><strong>Tween Animation:</strong><br>补间动画（或者叫渐变动画），通过对场景里的对象不断做图像变换(平移、缩放、旋转)产生动画效果<a id="more"></a></li>
<li><strong>Property Animation:</strong><br>属性动画，通过动态地改变对象的属性从而达到动画效果，属性动画为API 11新特性</li>
</ul>
<h4 id="1-2_帧动画：">1.2 帧动画：</h4><p>是指顺序执行预先设置好的一组图片，类似电影胶片的形式，设置每一帧drawable，在java代码中加载资源生成一个AnimationDrawable对象。例如：在xml中配置spin_animation.xml在文件夹res/drawable/中：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> 
<span class="tag">&lt;<span class="title">animation-list</span>  
  <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>  
  <span class="attribute">android:oneshot</span>=<span class="value">"false"</span>  &gt;</span>  
       <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/p1"</span> <span class="attribute">android:duration</span>=<span class="value">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span>  
       <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/p2"</span> <span class="attribute">android:duration</span>=<span class="value">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span>  
       <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/p3"</span> <span class="attribute">android:duration</span>=<span class="value">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span>  
       <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/p4"</span> <span class="attribute">android:duration</span>=<span class="value">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span>  
<span class="tag">&lt;/<span class="title">animation-list</span>&gt;</span>
</code></pre><p>加载资源并应用：</p>
<pre><code>// <span class="operator"><span class="keyword">Load</span> the ImageView that will host the animation <span class="keyword">and</span>
// <span class="keyword">set</span> its background <span class="keyword">to</span> our AnimationDrawable <span class="keyword">XML</span> <span class="keyword">resource</span>.
ImageView img = (ImageView)findViewById(R.<span class="keyword">id</span>.spinning_wheel_image);</span>
img.setBackgroundResource(R.drawable.spin_animation);

// Get the background, which has been compiled to an AnimationDrawable object.
AnimationDrawable frameAnimation = (AnimationDrawable) img.getBackground();

// <span class="operator"><span class="keyword">Start</span> the animation (looped playback <span class="keyword">by</span> <span class="keyword">default</span>).
frameAnimation.<span class="keyword">start</span>();</span>
</code></pre><h4 id="1-3_补间动画：">1.3 补间动画：</h4><p>补间动画有四种动画形式，分别是:</p>
<ul>
<li>alpha 渐变透明度动画效果</li>
<li>scale 渐变尺寸伸缩动画效果</li>
<li>translate 画面位置移动动画效果</li>
<li>rotate 画面旋转动画效果</li>
</ul>
<p>可以和帧动画一样在xml中配置动画，例如旋转动画rotate.xml，设置起始和终止的角度，动画中心的相对位置，动画时长等。</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> 
<span class="tag">&lt;<span class="title">set</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>  
    <span class="attribute">android:fillAfter</span> = "<span class="attribute">false</span>"  
    <span class="attribute">android:zAdjustment</span>=<span class="value">"bottom"</span> &gt;</span>  
    <span class="tag">&lt;<span class="title">rotate</span>  
        <span class="attribute">android:fromDegrees</span>=<span class="value">"0"</span>  
        <span class="attribute">android:toDegrees</span>=<span class="value">"360"</span>  
        <span class="attribute">android:pivotX</span>=<span class="value">"50%"</span>  
        <span class="attribute">android:pivotY</span>=<span class="value">"50%"</span>  
        <span class="attribute">android:duration</span>=<span class="value">"4000"</span> /&gt;</span>  
<span class="tag">&lt;/<span class="title">set</span>&gt;</span>
</code></pre><p>使用AnimationUtils加载动画的xml文件生成Animation的实例，也可以在JAVA代码中构造补间动画</p>
<pre><code><span class="comment">// 加载xml构造Animation</span>
Animation anim = AnimationUtils.loadAnimation(mContext, R.anim.rotate);
<span class="comment">// 不通过xml构造</span>
Animation rotate = <span class="keyword">new</span> RotateAnimation(<span class="number">0.0f</span>, +<span class="number">360</span>,  Animation.RELATIVE_TO_SELF, <span class="number">0.5f</span>, 
                   Animation.RELATIVE_TO_SELF, <span class="number">0.5f</span>);
</code></pre><p><img src="/res/android_animation/android_animation_animation_class.png" alt="Animation类图"></p>
<h4 id="1-4_属性动画：">1.4 属性动画：</h4><p>补间动画只能应用于视图(View)对象，动画的方式也仅限于上面所说的四种方式，而属性动画可以应用于所有的Object对象，它通过改变对象的属性值完成动画效果，当然前提是需要有该属性的get和set方法，通过在动画的过程中调用get和set方法改变对象的属性值来完成动画效果。例如通过ObjectAnimator指定要改变的对象和属性名称：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofInt(testObject, <span class="string">"data"</span>, <span class="number">0</span>, <span class="number">10</span>);
animator.start();

<span class="keyword">private</span> <span class="keyword">class</span> TestObject {
    <span class="keyword">private</span> <span class="keyword">int</span> data;
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> data;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>{
        <span class="keyword">this</span>.data = data;
    }
}
</code></pre><p>当然也通过ValueAnimator，不需要指定属性名更灵活，设置AnimatorUpdateListener，在动画更新的回调中完成想要的动作，例如，在从0到10的变化过程中，去更新视图的位置？或者其他想要的任何可能操作。</p>
<pre><code>ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">10</span>);
animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() {
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>{
    <span class="keyword">int</span> factor = (Integer) animation.getAnimatedValue();
    }
});
</code></pre><h4 id="1-5_动画插值：">1.5 动画插值：</h4><p>插值器的作用是根据时间运行的百分比来计算出当前属性改变的百分比，反映的是时间和动画进度（或属性变化）的关系，通过动画当前运行的时间，计算出当前动画的变化量。例如系统预制的线性插值器（LinearInterpolator），时间和动画进度的函数关系是y = x的直线方程，就表示当前动画是均速变化的。而当时间和动画进度的函数关系式表达为y=x^2的时候，那表示动画的变化率随着时间的增加而增加的，在视觉上就表现为加速动画。在理论上就可以通过动画插值器实现不同快慢效果的动画。</p>
<p><img src="/res/android_animation/jiasu_jiansu.png" alt="加速减速插值器，曲线的斜率是先变大后变小，说明速度是先加速后减速的"></p>
<p>在系统预制的插值器有：AccelerateInterpolator（加速插值器），AccelerateDecelerateInterpolator（加速减速插值器）， LinearInterpolator（线性插值器），BounceInterpolator（弹跳插值器），AnticipateInterpolator（回荡秋千插值器），AnticipateOvershootInterpolator， CycleInterpolator（正弦周期变化插值器），OvershootInterpolator ，我们也可以通过实现TimeTimeInterpolator或者Interpolatorr接口实现自定义的插值器。</p>
<p><img src="/res/android_animation/android_animation_interpolator_class.png" alt="Interpolator类图"></p>
<h4 id="1-6_动画估值器">1.6 动画估值器</h4><p>估值器的作用是，根据插值器结果（当前属性变化的百分比）计算出当前属性的值，系统预置的有IntEvaluator（针对整型属性）、FloatEvaluator（针对浮点型属性）和ArgbEvaluator（针对Color属性）。满足的关系是：</p>
<h3 id="二、桌面文件夹伸缩动画">二、桌面文件夹伸缩动画</h3><h4 id="2-1_IOS文件夹动画原理">2.1 IOS文件夹动画原理</h4><p>类似IOS的文件夹视图展开动画，简单说就是针对文件夹视图的一个伸缩动画，而视觉效果上的动画目标就是如何让文件夹的桌面图标和文件夹打开后的视图看起来是一个进行放大缩小的整体，处理伸缩动画的关键：<br>1.伸缩的前后比例（多少）<br>2.伸缩视图的中心坐标（相对于哪一点做伸缩）<br>针对伸缩的比例，应该是文件夹展开前后文件夹内应用图标大小确定的。针对如何确定伸缩视图的中心坐标，就需要首先确定坐标系，就是中心点是相对哪个坐标系确定的！伸缩动画坐标系的的原点在哪里？</p>
<ul>
<li>伸缩动画的坐标系是由当前缩放视图确定的，当前视图的左上角为坐标系的原点，即（0，0）点。</li>
<li>原点的水平向右方向为横坐标的正方向，平行手机屏幕垂直向下方向未纵坐标的正方向。</li>
</ul>
<p>确定了伸缩的坐标系，现在的问题就是如何确定伸缩中心点的坐标，在我们学习数学的过程中，老师教我们如何把实际问题抽象成数学问题，就像小学时经典的船在顺流和逆流中航形的问题一样。面对视图的缩放，我们能够想到的应该就是多边形的相似问题，看待现在的文件夹视图，可以抽象成一个矩形，在以矩形的左上角确定的坐标系里，从一个Size放大（或缩小）到另一个Size，在矩形长和宽变化比例相同的情况下，变化前后的矩形就是两个相似矩形，这样就可以很容易的画出下图.</p>
<p><img src="/res/android_animation/xiangsi.jpg" alt="相似矩形"></p>
<p>针对相似多边形对应点连线或者反向延长线相交于一点的原理，我们很容易得出下面的关系，即伸缩前后大小、伸缩比例和伸缩点坐标的关系式：</p>
<pre><code>h2 = <span class="built_in">offset</span> / (<span class="number">1</span>-<span class="built_in">scale</span>)
</code></pre><p>通过上面的公式，就很容易计算出文件夹视图伸缩动画的pivotX和pivotY的值计算代码：</p>
<pre><code><span class="comment">// set scale pivotX and pivotY</span>
<span class="built_in">int</span> leftOffset = folderIconRect.left - folderViewLeft;
<span class="built_in">int</span> topOffset = folderIconRect.top - folderViewTop;
<span class="built_in">float</span> <span class="variable">height</span> = folderHeight * mFolderScale;
<span class="built_in">float</span> delta = ((<span class="built_in">float</span>) folderHeight) / (folderHeight - <span class="variable">height</span>);
<span class="built_in">float</span> folderPivotX = leftOffset * delta;
<span class="built_in">float</span> folderPivotY = topOffset * delta;
</code></pre><p>但是这对展开动画仅仅解决缩放动画的问题还原因不够，因为缩放动画只是针对文件夹的视图，而针对文件夹内每个应用图标视图也应该有相应的动画，为什么？因为按照文件夹的位置进行的缩放动画，无法保证文件夹内的应用图标和文件夹图标上应用的缩略图完全重合。联想到学习过的中学物理知识，这个场景就好像你一定能够想到了分运动和合运动，火车在轨道上行驶，人在火车内行走，问人相对与地面的运动是什么样子的？整体文件夹的视图相对于它的伸缩中心点进行伸缩，文件夹视图内的应用图标相对于文件夹视图进行位移，效果又会是什么样子的？想明白这个，相信你一定能感受到选择一个正确的坐标系是多么重要。</p>
<p><img src="/android_animation/tubiaodonghua.jpg" alt="文件夹内图标动画效果"></p>
<p>抽象出了运动的理论，那计算的思路就是计算出每个应用缩略图标相对于文件夹图标的位置，计算出文件夹展开后每个应用图标相对于文件夹视图的相对位置，接合每个应用图标的伸缩比例，就能得到每个应用图标在文件夹视图的缩放过程中需要完成的位移，简单来说就是Folder的视图在缩放，Folder里的App图标在Folder视图上做相应的位移，结果你会发现是这样：</p>
<p><img src="/android_animation/guangbixiaoguo.jpg" alt="关闭效果"></p>
<p>处理完文件夹视图的问题，相信这个问题已经解决大半了，剩下的就是桌面上其他图标的移动，简单来说还是缩放动画，只需要让每个图标的缩放点和Folder视图的缩放点相对于屏幕坐标系重合就可以了。</p>
<h4 id="2-2_总结">2.2 总结</h4><p>1.处理动画问题首先确定动画起始和终止的状态，根据状态确定动画类型。<br>2.确定动画坐标系。动画坐标系如何确定取决与动画改变的属性，对于缩放动画，缩放改变是视图本身，那缩放动画的坐标系一定是相对于视图自己建立的，左上角是原点。而对于位移动画，改变translationX和X的值都能实现位置上的改变，但是他们表示的含义不一样，translationX是相对于视图本身而言的，X是相对于父布局而言的，那他们建立的坐标系肯定也不一样。<br>3.根据建立坐标系完成动画，把复杂的合运动分解成在不同坐标系上的分运动简单求解。</p>
<h3 id="三、动画源码分析（基于Android_5-0）">三、动画源码分析（基于Android 5.0）</h3><h4 id="3-1_动画插值源码">3.1 动画插值源码</h4><p>想要实现动画无非想做一件事情，就是把动画的对象在合适的时间画出合适的状态，如何控制时间？就是通过补间动画或者属性动画设置动画的时长、起始时间、起始延迟这些属性来控制动画的时间。如何控制动画状态？就可以通过动画插值，插值方法getInterpolation(input),input就是当前动画运行时间的百分比，而函数返回值就是当前动画的进度百分比，通过动画进度和动画的起始状态和结束状态来控制动画对象的当前状态。无论是补间动画或者属性动画都是定义动画状态的起始状态、终止状态、动画多久、如何动画。</p>
<h4 id="3-2_补间动画源码">3.2 补间动画源码</h4><p>先找到动画执行的入口View.startAnimation(animation)，startAnimation执行了invalidate，触发了重绘刷新视图界面。</p>
<pre><code>public void <span class="function">startAnimation</span>(<span class="attribute">Animation</span> <span class="attribute">animation</span>) {
    <span class="attribute">animation</span><span class="class">.setStartTime</span>(<span class="attribute">Animation</span><span class="class">.START_ON_FIRST_FRAME</span>);
    <span class="function">setAnimation</span>(<span class="attribute">animation</span>);
    <span class="function">invalidateParentCaches</span>();
    <span class="function">invalidate</span>(true);
}
</code></pre><p>invalidate()触发执行View.draw(Canvas canvas, ViewGroup parent, long drawingTime)函数</p>
<ul>
<li>调用动画的 getTransformation 方法，得到当前时间点的矩阵</li>
<li>将该矩阵设置成 Canvas 的当前矩阵</li>
<li>调用 canvas 的 drawBitmap 方法，绘制屏幕</li>
<li>判断 getTransformation 的返回值，若为真，调用 invalidate 方法，刷新屏幕进入下一桢；若为假，说明动画完成。</li>
</ul>
<pre><code><span class="built_in">boolean</span> draw(Canvas canvas, ViewGroup <span class="keyword">parent</span>, long drawingTime) {
    <span class="attribute">...</span><span class="attribute">...</span>
    <span class="comment">// 如果有需要执行的动画</span>
    final Animation a = getAnimation();
    <span class="keyword">if</span> (a != <span class="built_in">null</span>) {
        <span class="comment">// 根据动画和当前时间计算Transformation，并返回是否需要再继续做动画</span>
        more = drawAnimation(<span class="keyword">parent</span>, drawingTime, a, scalingRequired);
        concatMatrix = a<span class="built_in">.</span>willChangeTransformationMatrix();
        <span class="keyword">if</span> (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        <span class="comment">// 得到动画的变换结果</span>
        transformToApply = <span class="keyword">parent</span><span class="built_in">.</span>mChildTransformation;
    } <span class="keyword">else</span> {
        <span class="attribute">...</span><span class="attribute">...</span>
    }

    <span class="attribute">...</span><span class="attribute">...</span>

    float alpha = useDisplayListProperties ? <span class="number">1</span> : getAlpha();
    <span class="keyword">if</span> (transformToApply != <span class="built_in">null</span> <span class="subst">||</span> alpha &lt; <span class="number">1</span> <span class="subst">||</span> <span class="subst">!</span>hasIdentityMatrix() <span class="subst">||</span>
            (mPrivateFlags3 <span class="subst">&amp;</span> PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
        <span class="attribute">...</span><span class="attribute">...</span>
            <span class="comment">// 根据Transformation值变换canvs</span>
            <span class="keyword">if</span> (transformToApply != <span class="built_in">null</span>) {
                <span class="keyword">if</span> (concatMatrix) {
                    <span class="keyword">if</span> (useDisplayListProperties) {
                        displayList<span class="built_in">.</span>setAnimationMatrix(transformToApply<span class="built_in">.</span>getMatrix());
                    } <span class="keyword">else</span> {
                        <span class="comment">// Undo the scroll translation, apply the transformation matrix,</span>
                        <span class="comment">// then redo the scroll translate to get the correct result.</span>
                        canvas<span class="built_in">.</span>translate(<span class="attribute">-transX</span>, <span class="attribute">-transY</span>);
                        canvas<span class="built_in">.</span>concat(transformToApply<span class="built_in">.</span>getMatrix());
                        canvas<span class="built_in">.</span>translate(transX, transY);
                    }
                    <span class="keyword">parent</span><span class="built_in">.</span>mGroupFlags |= ViewGroup<span class="built_in">.</span>FLAG_CLEAR_TRANSFORMATION;
                }

                float transformAlpha = transformToApply<span class="built_in">.</span>getAlpha();
                <span class="keyword">if</span> (transformAlpha &lt; <span class="number">1</span>) {
                    alpha *= transformAlpha;
                    <span class="keyword">parent</span><span class="built_in">.</span>mGroupFlags |= ViewGroup<span class="built_in">.</span>FLAG_CLEAR_TRANSFORMATION;
                }

            <span class="keyword">if</span> (<span class="subst">!</span>childHasIdentityMatrix <span class="subst">&amp;&amp;</span> <span class="subst">!</span>useDisplayListProperties) {
                canvas<span class="built_in">.</span>translate(<span class="attribute">-transX</span>, <span class="attribute">-transY</span>);
                canvas<span class="built_in">.</span>concat(getMatrix());
                canvas<span class="built_in">.</span>translate(transX, transY);
            }
        }
        <span class="attribute">...</span><span class="attribute">...</span>
    }

    <span class="keyword">if</span> (a != <span class="built_in">null</span> <span class="subst">&amp;&amp;</span> <span class="subst">!</span>more) {
        <span class="keyword">if</span> (<span class="subst">!</span>hardwareAccelerated <span class="subst">&amp;&amp;</span> <span class="subst">!</span>a<span class="built_in">.</span>getFillAfter()) {
            onSetAlpha(<span class="number">255</span>);
        }
        <span class="keyword">parent</span><span class="built_in">.</span>finishAnimatingView(this, a);
    }

    <span class="comment">// 根据动画进度判断是否需要继续重绘</span>
    <span class="keyword">if</span> (more <span class="subst">&amp;&amp;</span> hardwareAccelerated) {
        <span class="comment">// invalidation is the trigger to recreate display lists, so if we're using</span>
        <span class="comment">// display lists to render, force an invalidate to allow the animation to</span>
        <span class="comment">// continue drawing another frame</span>
        <span class="keyword">parent</span><span class="built_in">.</span>invalidate(<span class="literal">true</span>);
        <span class="keyword">if</span> (a<span class="built_in">.</span>hasAlpha() <span class="subst">&amp;&amp;</span> (mPrivateFlags <span class="subst">&amp;</span> PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            <span class="comment">// alpha animations should cause the child to recreate its display list</span>
            invalidate(<span class="literal">true</span>);
        }
    }

    mRecreateDisplayList = <span class="literal">false</span>;

    <span class="keyword">return</span> more;
}
</code></pre><p>时序图：</p>
<h4 id="3-2_属性动画源码">3.2 属性动画源码</h4><p>onsync时序图：<br><img src="/res/android_animation/choreographer_seq_diag.png" alt="choreographer onVsync时序图"></p>
<p>从ObjectAnimator的start()方法开始,跳转到父类ValueAnimator的start()方法，为了减少篇幅，这里的代码就不贴出来了，详细的代码可以查看从ObjectAnimator.java。</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{
    <span class="comment">// See if any of the current active/pending animators need to be canceled</span>
    <span class="comment">// 这里先判断当前的动画、等待的动画和延迟执行的动画和this去比较，如果动画的目标对象相同并且属性相同就取消相同的动画。</span>
    ......

    <span class="keyword">super</span>.start();
}
</code></pre><p>ValueAnimator的start(boolean)方法只是做了两件事：<br>1.把当前的animator加入等待队列中，<br>2.启动animationHandler。AnimationHandler并不是一个Handler，而是Runnable。</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> playBackwards)</span> </span>{
    <span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Animators may only be run on Looper threads"</span>);
    }

    ......

    AnimationHandler animationHandler = getOrCreateAnimationHandler();
    animationHandler.mPendingAnimations.add(<span class="keyword">this</span>);
    <span class="keyword">if</span> (mStartDelay == <span class="number">0</span>) {
        <span class="comment">// This sets the initial value of the animation, prior to actually starting it running</span>
        setCurrentPlayTime(<span class="number">0</span>);
        mPlayingState = STOPPED;
        mRunning = <span class="keyword">true</span>;
        notifyStartListeners();
    }
    animationHandler.start();
}
</code></pre><p>将AnimationHandler对象传递给Choreographer(编舞者)，Choreographer是和线程绑定的单例。告诉编舞者，我是一个CALLBACK_ANIMATION(动画类型)，你自己看着办吧。</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">scheduleAnimation</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (!mAnimationScheduled) {
        mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, <span class="keyword">this</span>, <span class="keyword">null</span>);
        mAnimationScheduled = <span class="keyword">true</span>;
    }
}
</code></pre><p>编舞者根据callbackType(就是上面的CALLBACK_ANIMATION类型)，把当前的action(就是animationHandler)加入相应类型的Callback队列等待被执行。并且安排下一帧的时间。</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> postCallbackDelayedInternal(<span class="built_in">int</span> callbackType,
        <span class="keyword">Object</span> action, <span class="keyword">Object</span> token, <span class="keyword">long</span> delayMillis) {

    <span class="keyword">synchronized</span> (mLock) {
        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();
        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;
        <span class="comment">// 加入相应类型的Callback队列等待被执行</span>
        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);

        <span class="keyword">if</span> (dueTime &lt;= now) {
            scheduleFrameLocked(now);
        } <span class="keyword">else</span> {
            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);
            msg.arg1 = callbackType;
            msg.setAsynchronous(<span class="keyword">true</span>);
            mHandler.sendMessageAtTime(msg, dueTime);
        }
    }
}
</code></pre><p>如果使用Vsync，通过FrameDisplayEventReceiver的scheduleVsync方法，申请一次VSYNC中断，这样就可以在中断处理的onVsync函数去进行绘制。如果不需要直接发送MSG_DO_FRAME消息。</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>{
    <span class="keyword">if</span> (!mFrameScheduled) {
        mFrameScheduled = <span class="keyword">true</span>;
        <span class="keyword">if</span> (USE_VSYNC) {
            <span class="comment">// If running on the Looper thread, then schedule the vsync immediately,</span>
            <span class="comment">// otherwise post a message to schedule the vsync from the UI thread</span>
            <span class="comment">// as soon as possible.</span>
            <span class="comment">// 如果使用VSYNC就申请一次中断请求</span>
            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) {
                scheduleVsyncLocked();
            } <span class="keyword">else</span> {
                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);
                msg.setAsynchronous(<span class="keyword">true</span>);
                mHandler.sendMessageAtFrontOfQueue(msg);
            }
        } <span class="keyword">else</span> {
            <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(
                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);
            <span class="comment">// 如果不是要VSYNC，就直接触发MSG_DO_FRAME</span>
            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
            msg.setAsynchronous(<span class="keyword">true</span>);
            mHandler.sendMessageAtTime(msg, nextFrameTime);
        }
    }
}
</code></pre><p>上面注册一个了reciver，在VSYNC发生的时候接受到消息，就会触发onVsync方法,执行当前的FrameDisplayEventReceiver Runnable。</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>{
    ......
    Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);
    msg.setAsynchronous(<span class="keyword">true</span>);
    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
    mHavePendingVsync = <span class="keyword">false</span>;
    doFrame(mTimestampNanos, mFrame);
}
</code></pre><p>我们看doFrame方法做了什么？调用doCallbacks方法，获取当前类型的等待序列中在当前时间的callback，得到action并执行run方法，在这里callback的action就是AnimationHandler。</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>{
    ......
    <span class="comment">// 优先级最高，和输入事件处理有关</span>
    doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);
    <span class="comment">// 优先级其次，和Animation的处理有关</span>
    doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
    <span class="comment">// 优先级最低，和UI等控件绘制有关</span>
    doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
}


<span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>{
    CallbackRecord callbacks;
    <span class="keyword">synchronized</span> (mLock) {
        <span class="comment">// We use "now" to determine when callbacks become due because it's possible</span>
        <span class="comment">// for earlier processing phases in a frame to post callbacks that should run</span>
        <span class="comment">// in a following phase, such as an input event that causes an animation to start.</span>
        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();
        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now);
        <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) {
            <span class="keyword">return</span>;
        }
        mCallbacksRunning = <span class="keyword">true</span>;
    }
    <span class="keyword">try</span> {
        <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) {
            <span class="comment">// 在这里回调callback的action</span>
            c.run(frameTimeNanos);
        }
    }
    ......
}
</code></pre><p>终于回调了AnimationHandler的run方法，代码很多，起始无非就是让应该启动的animation启动起来，该延迟的放在延迟队列，正在做动画的调用doAnimationFrame方法，动画播放结束的就结束动画。当然如果还需要继续动画那就继续调用scheduleAnimation方法，告诉编舞者，还有呢，继续在下个帧时间执行我。当然所有时间控制是根据VSYNC回调上来的时间和每个动画的时间信息共同控制的。</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>{
    ......
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) {
        ValueAnimator anim = mTmpAnimations.get(i);
        <span class="keyword">if</span> (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime)) {
            mEndingAnims.add(anim);
        }
    }
    ......
    <span class="comment">// If there are still active or delayed animations, schedule a future call to</span>
    <span class="comment">// onAnimate to process the next frame of the animations.</span>
    <span class="keyword">if</span> (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) {
        scheduleAnimation();
    }
}
</code></pre><h4 id="3-3_动画源码总结">3.3 动画源码总结</h4><p>1.针对视图来说，Animation和Scroller相似，都是如何控制视图的重绘，它们都指示定义了在某一个特定时刻我应该画成什么样子。<br>2.Choreographer实际上是视图所有重绘进度的实际控制者，因为它在控制着时间节奏，告诉应用们什么时间可以画，视图不需要自己控制刷新时间。<br>3.回头看Animation的源码分析，视图的重绘最终是触发ViewRootImpl的invalidate函数，该函数将最终调用ViewRootImpl的scheduleTraversals。同样是通过mChoreographer只是类型变成了CALLBACK_TRAVERSAL，代码如下所示：</p>
<pre><code>void scheduleTraversals<span class="literal">()</span> {
    <span class="keyword">if</span> (!mTraversalScheduled) {
        mTraversalScheduled = <span class="literal">true</span>;
        mTraversalBarrier = mHandler.getLooper<span class="literal">()</span>.postSyncBarrier<span class="literal">()</span>;
        mChoreographer.postCallback(
                <span class="type">Choreographer</span>.<span class="type">CALLBACK_TRAVERSAL</span>, mTraversalRunnable, null);
        <span class="keyword">if</span> (!mUnbufferedInputDispatch) {
            scheduleConsumeBatchedInput<span class="literal">()</span>;
        }
        notifyRendererOfFramePending<span class="literal">()</span>;
    }
}
</code></pre><p>4.Asynchronous Message和Synchronization Barrier我还没有理解，当你觉得自己明白了的时候，其实你还有很多不知道，当你觉得你不明白的时候，那是你真的不知道。不知道还是不知道！！</p>
<h3 id="四、参考文档">四、参考文档</h3><p><a href="http://blog.csdn.net/lmj623565791/article/details/38067475" target="_blank" rel="external">Android 属性动画（Property Animation） 完全解析 （上）</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/38092093" target="_blank" rel="external">Android 属性动画（Property Animation） 完全解析 （下）</a><br><a href="http://www.uml.org.cn/mobiledev/201301081.asp" target="_blank" rel="external">Android Project Butter分析</a><br><a href="http://developer.android.com/reference/android/view/Choreographer.html" target="_blank" rel="external">http://developer.android.com/reference/android/view/Choreographer.html</a><br><a href="http://developer.android.com/reference/android/view/Choreographer.FrameCallback.html" target="_blank" rel="external">http://developer.android.com/reference/android/view/Choreographer.FrameCallback.html</a><br><a href="https://github.com/samchen2009/android_uml" target="_blank" rel="external">https://github.com/samchen2009/android_uml</a></p>

      
    </div>

    
    <!-- /上述代码 -->
    
  <!-- css -->
  <style type="text/css">
      .center {
          text-align: center;
      }
      .hidden {
          display: none;
      }
    .donate_bar a.btn_donate{
      display: inline-block;
      width: 82px;
      height: 82px;
      background: url("http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif") no-repeat;
      _background: url("http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif") no-repeat;

      <!-- http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif
           因为本 hexo 生成的博客所用的 theme 的 a:hover 带动画效果，
         为了在让打赏按钮显示效果正常 而 添加了以下几行 css，
         嵌入其它博客时不一定要它们。 -->
      -webkit-transition: background 0s;
      -moz-transition: background 0s;
      -o-transition: background 0s;
      -ms-transition: background 0s;
      transition: background 0s;
      <!-- /让打赏按钮的效果显示正常 而 添加的几行 css 到此结束 -->
    }

    .donate_bar a.btn_donate:hover{ background-position: 0px -82px;}
    .donate_bar .donate_txt {
      display: block;
      color: #9d9d9d;
      font: 14px/2 "Microsoft Yahei";
    }
    .bold{ font-weight: bold; }
  </style>
  <!-- /css -->

    <!-- Donate Module -->
    <div id="donate_module">

  <!-- btn_donate & tips -->
  <div id="donate_board" class="donate_bar center">
      <br>
      ------------------------------------------------------------------------------------------------------------------------------
      <br>
    <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
    <span class="donate_txt">
      求鼓励，求支持！
    </span>
      
    
  </div>
  <!-- /btn_donate & tips -->

  <!-- donate guide -->
    
  <div id="donate_guide" class="donate_bar center hidden">
        <br>
      ------------------------------------------------------------------------------------------------------------------------------
      <br>

    <a href="https://ivonhoe.github.io/res/dex2jar_error/WechatIMG56.png" title="用微信扫一扫哦~" class="fancybox" rel="article0">
      <img src="https://ivonhoe.github.io/res/dex2jar_error/WechatIMG56.png" title="微信打赏 Colin" height="190px" width="auto"/>
    </a>
        
        &nbsp;&nbsp;

    <a href="https://ivonhoe.github.io/res/dex2jar_error/WechatIMG57.jpeg" title="用支付宝扫一扫即可~" class="fancybox" rel="article0">
      <img src="https://ivonhoe.github.io/res/dex2jar_error/WechatIMG57.jpeg" title="支付宝打赏 Colin" height="190px" width="auto"/>
    </a>

    <span class="donate_txt">
      求鼓励，求支持！
    </span>

  </div>
  <!-- /donate guide -->

  <!-- donate script -->
  <script type="text/javascript">
    document.getElementById('btn_donate').onclick = function() {
      $('#donate_board').addClass('hidden');
      $('#donate_guide').removeClass('hidden');
    }

    function donate_on_web(){
      $('#donate').submit();
        }

    var original_window_onload = window.onload;
        window.onload = function () {
            if (original_window_onload) {
                original_window_onload();
            }
            document.getElementById('donate_board_wdg').className = 'hidden';
    }
  </script>
  <!-- /donate script -->
</div>
<!-- /Donate Module -->
   
    

    <footer class="article-footer">
      
        <a data-url="https://ivonhoe.github.io/2015/02/09/Android动画总结/" data-id="cj0ryop0c001sp4mva8gixajw" class="article-share-link" data-share="baidu">分享到</a>
      

      
        <a href="https://ivonhoe.github.io/2015/02/09/Android动画总结/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动画/">动画</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/04/08/-翻译-Context-什么是Context？/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          [译]Context?什么是Context？
        
      </div>
    </a>
  
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="2015/02/09/Android动画总结/" data-title="Android动画总结" data-url="https://ivonhoe.github.io/2015/02/09/Android动画总结/"></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/Context/" style="font-size: 10px;">Context</a> <a href="/tags/Delvik/" style="font-size: 10px;">Delvik</a> <a href="/tags/Drawable/" style="font-size: 13.33px;">Drawable</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/dex2jar/" style="font-size: 10px;">dex2jar</a> <a href="/tags/产品分析/" style="font-size: 10px;">产品分析</a> <a href="/tags/内存/" style="font-size: 10px;">内存</a> <a href="/tags/动态链接库/" style="font-size: 10px;">动态链接库</a> <a href="/tags/动画/" style="font-size: 16.67px;">动画</a> <a href="/tags/去广告/" style="font-size: 10px;">去广告</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/数据解析/" style="font-size: 10px;">数据解析</a> <a href="/tags/源码编译/" style="font-size: 10px;">源码编译</a> <a href="/tags/生产者消费者模式/" style="font-size: 10px;">生产者消费者模式</a> <a href="/tags/移动安全/" style="font-size: 13.33px;">移动安全</a> <a href="/tags/翻译/" style="font-size: 10px;">翻译</a> <a href="/tags/贝塞尔曲线/" style="font-size: 10px;">贝塞尔曲线</a> <a href="/tags/转载/" style="font-size: 10px;">转载</a> <a href="/tags/进度条/" style="font-size: 10px;">进度条</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">二月 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/22/Bitmap&Memory/">Android Bitmap的内存大小是如何计算的？</a>
          </li>
        
          <li>
            <a href="/2017/02/09/美团如何防dex2jar/">Android安全之---应用防dex2jar原理及实现</a>
          </li>
        
          <li>
            <a href="/2017/02/04/Android安全之---APP去广告/">Android安全之---APP去广告</a>
          </li>
        
          <li>
            <a href="/2017/01/20/MacOS上编译Android源码/">Mac OS上编译Android源码</a>
          </li>
        
          <li>
            <a href="/2016/12/16/Mac-Linux下gcc编译动态链接库-so文件/">Mac/Linux下gcc编译动态链接库[.so文件]</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://xiguabaobao.com" target="_blank">主题作者</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Fan.Yang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>

      <span id="busuanzi_container_site_uv">
      本站访客数<span id="busuanzi_value_site_uv"></span>人次
      </span>
      <span id="busuanzi_container_site_pv">
      本站总访问量<span id="busuanzi_value_site_pv"></span>次
      </span>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"ivonhoe"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>window._bd_share_config={"common":{},"share":{"bdCustomStyle":"/css/bdshare.css"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js" type="text/javascript"></script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</div>
</body>
</html>
