<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>病已的博客</title>
  <subtitle>枕上，马上，厕上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ivonhoe.github.io/"/>
  <updated>2018-05-27T15:20:50.000Z</updated>
  <id>https://ivonhoe.github.io/</id>
  
  <author>
    <name>病已</name>
    <email>yangfan3687@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拒绝单例模式</title>
    <link href="https://ivonhoe.github.io/2018/05/27/singleton/"/>
    <id>https://ivonhoe.github.io/2018/05/27/singleton/</id>
    <published>2018-05-27T14:23:37.000Z</published>
    <updated>2018-05-27T15:20:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00前言">0x00前言</h3><p>相信很多同学在学习设计模式的过程中，最先了解的就是单例模式，至少我是这样。单例模式看似简单容易理解，实际上却有很多坑，正因为这样也成为了很多公司面试必考的面试题。实际使用单例模式时，难免会遇到滥用的情况，理解单例更要学会何时拒绝单例。</p>
<h3 id="0x01单例模式的基础知识">0x01单例模式的基础知识</h3><h4 id="1-_单例的几种写法?">1. 单例的几种写法?</h4><a id="more"></a>
<ul>
<li>懒汉式: 懒加载模式，需要的时候才创建实例。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。需要考虑线程安全问题。</li>
<li>饿汉式：单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</li>
<li>静态内部类：JVM本身机制保证了线程安全问题，由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</li>
</ul>
<h4 id="2-_为什么要双重检验锁?">2. 为什么要双重检验锁?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Singleton getSingleton() &#123;&#10;    if (instance == null) &#123;                         //Single Checked&#10;        synchronized (Singleton.class) &#123;&#10;            if (instance == null) &#123;                 //Double Checked&#10;                instance = new Singleton();&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;    return instance ;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。</li>
<li>不然，我们就开始同步线程。</li>
<li>第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。</li>
</ol>
<h4 id="3-_重排序问题">3. 重排序问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = new Singleton()</span><br></pre></td></tr></table></figure>
<p>这并不是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>
<ol>
<li>给 instance 分配内存</li>
<li>调用 Singleton 的构造函数来初始化成员变量</li>
<li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li>
</ol>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。<br>对此，我们只需要把singleton声明成 volatile 就可以了。</p>
<h3 id="0x02_滥用单例带来哪些问题？">0x02 滥用单例带来哪些问题？</h3><p>你的项目中可能会有一堆的Manager或者Controller，最简单获取方法是把他们设计成一个个单例，只需要通过一个getInstance的方法获取到他的唯一实例对象，在任何代码中的任何地方，甚至不需要上下文。是否思考过下面的这些问题？</p>
<blockquote>
<p>1.你的单例会有应用的生命周期吗？</p>
</blockquote>
<p>按照单例的定义，无法构建除该单例以外的实例，并且这个单例有一个静态引用，单例不会被虚拟机垃圾回收。单例对象一旦创建，对象的引用是保存在静态区，<strong>单例对象在堆上分配的内存空间只有在程序终止后才会释放</strong>，过多的单例必然增大内存的消耗，<strong>并且如果你的单例中的上下文引用了不当，可能会造成严重的内存泄露问题</strong>。单例的设计应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该用单例来管理。</p>
<blockquote>
<p>2.如何尽可能的减少依赖【耦合】？</p>
</blockquote>
<p>有依赖就有耦合，如果你的单例提供的是某一个特定功能的公共方法或状态。那调用方和被调用方就会因为单例的设计建立了强耦合关系。甚至更极端的情况中，包含了多个单例之间的相互依赖甚至循环依赖关系。那你永远不可能将各种角色模块化拆分出来。</p>
<blockquote>
<p>3.如果你想针对你的单例做扩展或升级怎么办?</p>
</blockquote>
<p>对单例的实现升级其实并不是单例模式要解决的问题，但是<strong>单例模式缺少抽象</strong>，在使用过程中必然会遇到这样的问题。在业务的发展过程中，一定会遇到需要对已有单例进行实现升级的情况，比如你需要对相同功能换一种方式实现？或者需要增加删除一个方法或接口？甚至可能变成一个完全不一样的功能。这时候的单例就会遇到一些问题，你不单单需要修改单例，你还需要修改依赖单例的上层业务代码。</p>
<h3 id="0x03如何尽可能少的使用单例模式？">0x03如何尽可能少的使用单例模式？</h3><p>单例的好处是简单易用，单例模式在系统设置了全局的访问点，优化和共享资源的访问。但是滥用单例也带来的上述的三个方面的危害，无法统一管理对象的生命周期、增加耦合、针对实现编程而不是针对接口编程。如何享受单例模式带来的好处并且解决她带来的危害在于，如何通过一种解耦的方式全局获取一个单例对象，并且这个单例对象的生命周期是可管理的，并且这个单例对象是针对接口的抽象实现。</p>
<ul>
<li>针对接口实现：单例不再提供getInstance方法，并且根据不同的抽象接口实现</li>
<li>提供全局的访问点: 调用方可以通过全局的SingleManager获取实现接口的具体实例</li>
<li>可管理的对象生命周期: 所有的单例的唯一对象都由SingleManager管理</li>
<li>低耦合的：为了避免循环引用问题，<strong>SingletonManager在运行时根据配置文件通过反射的方式实例化每个接口的具体实现类</strong>，调用方只依赖SingletonManager，并且通过SingletonManager获取接口的实现实例</li>
</ul>
<p><img src="/res/singleton/singleton.png" alt=""></p>
<h3 id="0x04_参考文档">0x04 参考文档</h3><p><a href="https://coolshell.cn/articles/265.html" target="_blank" rel="external">深入浅出单实例SINGLETON设计模式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00前言&quot;&gt;0x00前言&lt;/h3&gt;&lt;p&gt;相信很多同学在学习设计模式的过程中，最先了解的就是单例模式，至少我是这样。单例模式看似简单容易理解，实际上却有很多坑，正因为这样也成为了很多公司面试必考的面试题。实际使用单例模式时，难免会遇到滥用的情况，理解单例更要学会何时拒绝单例。&lt;/p&gt;
&lt;h3 id=&quot;0x01单例模式的基础知识&quot;&gt;0x01单例模式的基础知识&lt;/h3&gt;&lt;h4 id=&quot;1-_单例的几种写法?&quot;&gt;1. 单例的几种写法?&lt;/h4&gt;
    
    </summary>
    
      <category term="思考" scheme="https://ivonhoe.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="设计模式" scheme="https://ivonhoe.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS</title>
    <link href="https://ivonhoe.github.io/2018/05/21/https/"/>
    <id>https://ivonhoe.github.io/2018/05/21/https/</id>
    <published>2018-05-21T13:55:38.000Z</published>
    <updated>2018-05-27T08:42:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00_前言">0x00 前言</h3><p>https为什么安全？因为相对http的明文传输，https引入了数据加密和身份认证。服务器和客户端的消息只有服务器和客户端能够读懂，保证了数据的保密性。同时在交换数据之前，验证了对方的合法身份，保证了通信双方的安全。这篇总结主要记录了在理解https安全性的过程中遇到的问题。</p>
<h3 id="0x01_什么是对称加密和非对称加密">0x01 什么是对称加密和非对称加密</h3><p>在https的协议中如何实现数据加密和身份认证呢？简单来说是客户端先获取非对称加密的公钥，通过公钥和服务器协商生成对称加密的对称密钥，并使用对称密钥加密传输数据。</p>
<a id="more"></a>
<p><img src="/res/https/https-1.png" alt=""></p>
<h4 id="1-1_对称加密">1.1 对称加密</h4><p><strong>什么是对称加密：</strong>加密和解密使用相同密钥的算法。它要求发送方和接收方在安全通信之前，商定一个对称密钥。对称算法的安全性完全依赖于密钥，密钥泄漏就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。</p>
<p><strong>特点：</strong>计算量小、加密速度快、加密效率高。交易双方都使用同样密钥，安全性得不到保证。每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信息双方所拥有的钥匙数量呈几何级数增长，密钥管理成为负担。</p>
<p><strong>代表算法：</strong> DES、AES</p>
<h4 id="1-2_非对称加密">1.2 非对称加密</h4><p><strong>什么是非对称加密：</strong> 需要两个密钥来进行加密和解密。分别是公开密钥和私有密钥。如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 </p>
<p><strong>特点：</strong> CPU计算资源消耗非常大，效率较低。非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是2048位，意味着待加密内容不能超过256个字节。</p>
<p><strong>代表算法：</strong> RSA</p>
<h3 id="0x02_中间人劫持">0x02 中间人劫持</h3><p>如果在通信过程中，客户端的请求被中间人劫持，那么中间人可以就可伪装成“冒牌客户端”和服务器通信，同时伪装成“冒牌服务器”与客户端通信。从而达到获取客户端服务端通信内容的目的！主要过程如下：</p>
<ol>
<li>中间人在服务器发送公钥之前劫持客户端请求，伪造客户端向服务端发起SSL握手</li>
<li>中间人获取服务端加密公钥，伪造出一个自己的公钥发送给客户端</li>
<li>客户端接受到伪造的公钥，使用伪造的公钥发送对称密钥</li>
<li>中间人劫持到对称密钥，并利用自己的私钥解密出对称密钥</li>
<li>利用步骤2中的正确服务器加密公钥，加密客户端对称密钥发送给服务</li>
<li>客户端和服务器使用被中间人破解的对称密钥传输数据，中间人可以获取所有传输信息</li>
</ol>
<p><img src="/res/https/https-2.jpeg" alt=""></p>
<h4 id="2-1_数字签名">2.1 数字签名</h4><p>数字签名过程：</p>
<ol>
<li>服务端把一个报文经过HASH处理生成消息摘要信息Digest，使用私钥加密摘要信息生成签名信息。</li>
<li>将报文、签名发生给客户端</li>
<li>客户端使用相同的HASH算法对报文做相同的HASH处理，获取摘要Digest1</li>
<li>客户端使用公钥解密签名生成摘要Digest2，并且对比Digest1和Digest2是否一致</li>
<li>如果Digest1和Digest2一致说明报文没有被篡改过，这份报文和签名是对应的，具有不可抵赖性。</li>
</ol>
<h4 id="2-2_数字证书">2.2 数字证书</h4><p>解决中间人劫持问题的关键在于，客户端如何能够分辨出接收到的公钥确实是服务端的呢？这时候就需要数字证书了。</p>
<p>数字证书是公司向一个证书发布机构”SecureTrust CA”申请的。这个证书发布机构”SecureTrust CA”是一个大家公认并被一些权威机构接受的证书发布机构，<strong>并且我们的操作系统里面已经安装了”SecureTrust CA”的证书</strong>。”SecureTrust CA”在给我们发布证书时，把Issuer,Public key,Subject,Valid from,Valid to等信息以明文的形式写到证书里面，然后用一个摘要算法计算出这些数字证书内容的一个Digest，并使用CA自己的私钥对Digest进行加密，生成证书的数字签名。</p>
<p>验证公钥过程：</p>
<ol>
<li>服务端将证书发送给客户端，<strong>这里不是公钥</strong></li>
<li>客户端提取证书中的发布机构(Issuer)为”SecureTrust CA”，在操作系统中受信任的发布机构的证书中去找”SecureTrust CA”的证书，如果查不到说明证书有问题。</li>
<li>如果找到了”SecureTrust CA”的证书，客户端从系统的证书中提取”SecureTrust CA”的公钥，</li>
<li>使用CA公钥对步骤1中获取到证书中的签名信息的进行解密获取解密摘要，并使用摘要算法计算证书的摘要</li>
<li>对比解密摘要和计算出的摘要信息是否一致。如果一致说明认证成功，当前证书中包含的公钥信息是可以信认的。</li>
</ol>
<p><img src="/res/https/https-3.jpeg" alt=""></p>
<p>数字证书中包含公钥和证书所有者信息，并且保证数字证书里的公钥确实是这个证书的所有者的，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。</p>
<h3 id="0x03_总结">0x03 总结</h3><p><strong>数字签名：</strong>为了说明谁编写的报文，同时证明报文未被篡改过。</p>
<p><strong>数字证书：</strong>由权威的认证机构证明公钥的正确性。</p>
<h3 id="0x04_参考文档">0x04 参考文档</h3><p><a href="http://wetest.qq.com/lab/view/110.html" target="_blank" rel="external">HTTPS为什么安全 &amp;分析 HTTPS 连接建立全过程</a></p>
<p><a href="https://www.cnblogs.com/franson-2016/p/5530671.html" target="_blank" rel="external">一个故事教你看懂什么是数字证书，它的原理是什么?它的作用是什么？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00_前言&quot;&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;https为什么安全？因为相对http的明文传输，https引入了数据加密和身份认证。服务器和客户端的消息只有服务器和客户端能够读懂，保证了数据的保密性。同时在交换数据之前，验证了对方的合法身份，保证了通信双方的安全。这篇总结主要记录了在理解https安全性的过程中遇到的问题。&lt;/p&gt;
&lt;h3 id=&quot;0x01_什么是对称加密和非对称加密&quot;&gt;0x01 什么是对称加密和非对称加密&lt;/h3&gt;&lt;p&gt;在https的协议中如何实现数据加密和身份认证呢？简单来说是客户端先获取非对称加密的公钥，通过公钥和服务器协商生成对称加密的对称密钥，并使用对称密钥加密传输数据。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://ivonhoe.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="https" scheme="https://ivonhoe.github.io/tags/https/"/>
    
      <category term="对称加密" scheme="https://ivonhoe.github.io/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="数字签名，数字证书" scheme="https://ivonhoe.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%EF%BC%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    
      <category term="非对称加密" scheme="https://ivonhoe.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化之资源加载</title>
    <link href="https://ivonhoe.github.io/2018/03/14/small-bug-555-fix/"/>
    <id>https://ivonhoe.github.io/2018/03/14/small-bug-555-fix/</id>
    <published>2018-03-14T09:23:27.000Z</published>
    <updated>2018-05-27T08:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x00_前言">0x00 前言</h4><p>这篇文章主要记录了在使用Small插件化框架中遇到的资源加载问题及相应解决方案，并梳理出Android的资源加载流程和插件化框架的资源加载原理。在前两篇插件化技术介绍的基础上会关注更多技术细节，希望能有所收获！</p>
<h4 id="0x01_Small框架的资源加载异常">0x01 Small框架的资源加载异常</h4><p>最近收到一个客户反馈，在他们的中兴V0840手机上打开我们的app会持续崩溃。第一时间在百度移动质量平台上短时租用了该机型，抓取了log。发现是资源查找失败异常。并在Small github issues中搜索<code>android.content.res.Resources$NotFoundException</code> 可以发现很多类似的问题，详细日志可查看下图。</p>
<a id="more"></a>
<p>Github issus链接：<a href="https://github.com/wequick/Small/issues/555" target="_blank" rel="external">#555 Small Sample项目打包后在ZTE上闪退</a></p>
<p><strong>项目崩溃日志：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): FATAL EXCEPTION: main&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): Process: com.shandiangou.kaguanjia, PID: 8189&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.shandiangou.kaguanjia/com.shandiangou.kaguanjia.app.main.activity.GuideActivity&#125;: android.content.res.Resources$NotFoundException: Resource ID #0x2a030010&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2669)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2730)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.app.ActivityThread.-wrap12(ActivityThread.java)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1481)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.os.Handler.dispatchMessage(Handler.java:102)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.os.Looper.loop(Looper.java:154)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.app.ActivityThread.main(ActivityThread.java:6144)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at java.lang.reflect.Method.invoke(Native Method)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:886)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:776)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): Caused by: android.content.res.Resources$NotFoundException: Resource ID #0x2a030010&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.content.res.ResourcesImpl.getValue(ResourcesImpl.java:196)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.content.res.Resources.loadXmlResourceParser(Resources.java:2101)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.content.res.Resources.getLayout(Resources.java:1115)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.view.LayoutInflater.inflate(LayoutInflater.java:424)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.view.LayoutInflater.inflate(LayoutInflater.java:377)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at com.shandiangou.kaguanjia.common.base.CustomProgressDialog.init(CustomProgressDialog.java:38)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at com.shandiangou.kaguanjia.common.base.CustomProgressDialog.&#60;init&#62;(CustomProgressDialog.java:26)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at com.shandiangou.kaguanjia.common.base.BaseActivity.initProgressDialog(BaseActivity.java:27)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at com.shandiangou.kaguanjia.common.base.BaseActivity.onCreate(BaseActivity.java:22)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at com.shandiangou.kaguanjia.app.main.activity.GuideActivity.onCreate(GuideActivity.java:45)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.app.Activity.performCreate(Activity.java:6722)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1119)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at net.wequick.small.ApkBundleLauncher$InstrumentationWrapper.callActivityOnCreate(ApkBundleLauncher.java:334)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2622)&#10;03-06 17:48:31.685 E/AndroidRuntime( 8189): &#9;... 9 more&#10;03-06 17:48:31.688 W/ActivityManager( 1384):   Force finishing activity com.shandiangou.kaguanjia/net.wequick.small.A</span><br></pre></td></tr></table></figure>
<p><strong>Small框架官方Sample崩溃日志</strong></p>
<p><img src="/res/small/small-error.png" alt=""></p>
<h4 id="0x02_Android资源加载流程">0x02 Android资源加载流程</h4><p><strong>Android源码Resources创建流程图：</strong></p>
<p><img src="/res/small/android-resources1.png" alt=""></p>
<p>ActivityThread在接收到LAUNCH_ACTIVITY消息以后，在 <code>performLaunchActivity</code>方法中，使用Instrumentation通过反射的方式创建Activity实例，再创建Activity的Base Context, 并在创建Context过程中实例化AssetManger和Resources。<br>ActivityThread在LAUNCH_ACTIVITY消息中，完成了Activity生命周期中的三个回调，分别是<code>onCreate</code> <code>onStart</code> <code>onRestoreInstanceState</code>。</p>
<p>Android中资源管理类在不同sdk版本中的关系如下图所示。</p>
<p><img src="/res/small/android-resources2.png" alt="Android源码资源类图"></p>
<h4 id="0x03_Small框架插件资源加载方案">0x03 Small框架插件资源加载方案</h4><p>Small框架的资源加载流程在ApkBundleLauncher中完成，<code>setup</code>流程获取到所有插件so的信息，在<code>postSetUp</code>中获取所有插件包的资源路径，通过反射调用AssetManager的<code>addAssetPaths</code>方法，构造一个包含宿主包资源、系统资源和插件包资源的AssetManger。最后还是通过反射，使用包含所有资源的AssetManager替换掉ResourcesManager中Resources的AssetManger，最终达到加载插件中资源的目的。</p>
<p><strong>Small框架资源加载流程:</strong></p>
<p><img src="/res/small/android-resources4.png" alt="Android源码资源类图"></p>
<h4 id="0x04_bug修复方案">0x04 bug修复方案</h4><p>看完Small插件资源加载流程，你是否有疑问？Small只在框架加载时对ResourcesManager进行了hook，好像在创建新的Resources并没有进行hook操作？那么当系统新创建Resources实例时，新的Resources中包含的资源路径并没有插件资源，这好像说不通吧。其实关注Small的源码中<code>ReflectAccelerator.ensureCacheResources</code>，这个方法想要的达到的作用是当每次启动Activity时遍历系统缓存的ResourceImpl，将它的AssetManager替换成包含插件资源的AssetManager。当然这个机制只在SDK&gt;=24时生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void ensureCacheResources() &#123;&#10;    if (Build.VERSION.SDK_INT &#60; 24) return;&#10;    if (sResourceImpls == null || sMergedResourcesImpl == null) return;&#10;&#10;    Set&#60;?&#62; resourceKeys = sResourceImpls.keySet();&#10;    for (Object resourceKey : resourceKeys) &#123;&#10;        WeakReference resourceImpl = (WeakReference)sResourceImpls.get(resourceKey);&#10;        if (resourceImpl != null &#38;&#38; resourceImpl.get() != sMergedResourcesImpl) &#123;&#10;            // Sometimes? the weak reference for the key was released by what&#10;            // we can not find the cache resources we had merged before.&#10;            // And the system will recreate a new one which only build with host resources.&#10;            // So we needs to restore the cache. Fix #429.&#10;            // FIXME: we&#39;d better to find the way to KEEP the weak reference.&#10;            sResourceImpls.put(resourceKey, new WeakReference&#60;Object&#62;(sMergedResourcesImpl));&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里有两个问题:</strong></p>
<ol>
<li>SDK&lt;24时，在原生的Android系统中并不是每启动一个Activity都会创建一个新的Resources实例，ResourcesManager会使用缓存的Resources实例，所以只需要Hook一次资源加载。但是一旦创建多个Resources实例时，是不是意味着新创建的Resources并会包含插件的资源路径。个人理解是这样的。这应该也能解释为啥Small框架会在某些手机的<strong>分屏模式</strong>和某些<strong>横竖屏切换</strong>的时候会发生Crash，详情请查看<a href="https://github.com/wequick/Small/issues/356" target="_blank" rel="external">#356</a>和<a href="https://github.com/wequick/Small/issues/548" target="_blank" rel="external">#548</a></li>
<li>SDK&gt;24时，Small会执行<code>ensureCacheResources</code>希望将新创建的ResourcesImpl的AssetsManger替换掉。但是看到源码中的实现方式是，通过反射为ActivityThread的<code>mH</code>Handler注入一个<code>Handler.Callback</code>。当HandlerCallback handleMessage LAUNCH_ACTIVITY消息时，执行<code>ensureCacheResources</code>方法。查看Handler的<code>dispatchMessage</code>发现<code>mCallback.handleMessage</code>是先于<code>mHandler.handleMessage</code>的。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * Handle system messages here.&#10; */&#10;public void dispatchMessage(Message msg) &#123;&#10;    if (msg.callback != null) &#123;&#10;        handleCallback(msg);&#10;    &#125; else &#123;&#10;        if (mCallback != null) &#123;&#10;            if (mCallback.handleMessage(msg)) &#123;&#10;                return;&#10;            &#125;&#10;        &#125;&#10;        handleMessage(msg);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>查看 <strong>0x02 Android资源加载流程</strong> 的资源流程，你会发现Resources对象的实例化并将ResourcesImpl添加到ResourcesManger的缓存列表中是在<code>Handler.handleMessage</code>之后的。所以<code>ensureCacheResources</code>并不能保证启动Activity时<strong>新创建的</strong>ResourcesImpl实例能够被正常hook的！！</p>
<p>综上所述，这就是文章开头中兴手机Android7.1系统的手机上使用Small框架会发生Crash问题的原因，因为<strong>中兴系统每次打开新的Activity都会创建一个新的Resources和ResourcesImpl实例，而这些都是没有被hook的，不包含插件资源路径</strong>，自然就会发生资源查找失败的异常。解决方法也比较简单，因为是SDK&gt;24的机器，只需要在Small框架的<code>InstrumentationWrapper.callActivityOnCreate</code>方法中执行<code>ReflectAccelerator.ensureCacheResources()</code>就可以解决上面的问题了。</p>
<p>同时你需要注意另一个问题，查看ActivityThread的源码，在启动Activity流程的<code>performLaunchActivity</code>方法中，在<code>mInstrumentation.callActivityOnCreate</code>之前系统会为Activity设置主题。如果你选择在<code>mInstrumentation.callActivityOnCreate</code>中执行Resources的hook，并且此时需要的主题资源恰好在插件中，那依然会发生Crash。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;&#10;    ....&#10;    ....&#30465;&#30053;&#20854;&#20182;&#20195;&#30721;&#10;    int theme = r.activityInfo.getThemeResource();&#10;    if (theme != 0) &#123;&#10;        activity.setTheme(theme);&#10;    &#125;&#10;&#10;    activity.mCalled = false;&#10;    if (r.isPersistable()) &#123;&#10;        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);&#10;    &#125; else &#123;&#10;        mInstrumentation.callActivityOnCreate(activity, r.state);&#10;    &#125;&#10;    ....&#30465;&#30053;&#20854;&#20182;&#20195;&#30721;&#10;    ....&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里我的建议是把你项目中所有的主题定义都放在宿主中，并且修改Small的框架代码在<code>InstrumentationWrapper.callActivityOnCreate</code>方法中执行<code>ReflectAccelerator.ensureCacheResources</code>方法，这样就可以解决Small框架在某些场景下发生<code>Resources$NotFoundException</code>异常的问题。</p>
<h4 id="0x05_完">0x05 完</h4><p>Small插件化框架是我在项目中使用的框架，他的设计和实现思路上都非常优雅，是首选的轻量级插件化框架。以上分析只是对Android源码和Small框架的个人理解，如有理解有误的地方还望指出，个人微信号:tykYang，邮箱:yangfan3687@163.com。🙏🙏🙏</p>
<p><a href="https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/">Android插件化之Small框架实践总结</a></p>
<p><a href="https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/">Android插件化之Small框架原理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;0x00_前言&quot;&gt;0x00 前言&lt;/h4&gt;&lt;p&gt;这篇文章主要记录了在使用Small插件化框架中遇到的资源加载问题及相应解决方案，并梳理出Android的资源加载流程和插件化框架的资源加载原理。在前两篇插件化技术介绍的基础上会关注更多技术细节，希望能有所收获！&lt;/p&gt;
&lt;h4 id=&quot;0x01_Small框架的资源加载异常&quot;&gt;0x01 Small框架的资源加载异常&lt;/h4&gt;&lt;p&gt;最近收到一个客户反馈，在他们的中兴V0840手机上打开我们的app会持续崩溃。第一时间在百度移动质量平台上短时租用了该机型，抓取了log。发现是资源查找失败异常。并在Small github issues中搜索&lt;code&gt;android.content.res.Resources$NotFoundException&lt;/code&gt; 可以发现很多类似的问题，详细日志可查看下图。&lt;/p&gt;
    
    </summary>
    
      <category term="安卓插件化" scheme="https://ivonhoe.github.io/categories/%E5%AE%89%E5%8D%93%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="Android源码" scheme="https://ivonhoe.github.io/tags/Android%E6%BA%90%E7%A0%81/"/>
    
      <category term="插件化" scheme="https://ivonhoe.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化之Small框架原理</title>
    <link href="https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"/>
    <id>https://ivonhoe.github.io/2018/01/18/Small框架原理/</id>
    <published>2018-01-18T09:54:19.000Z</published>
    <updated>2018-05-27T08:45:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x00_前言">0x00 前言</h4><p>Small是一个轻量化的插件化框架，Small的使用介绍可以查看<a href="http://code.wequick.net/Small/cn/quickstart" target="_blank" rel="external">官网文档</a>了解，Small项目接入总结可以查看博客的另一篇<a href="https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/">《Small框架实践总结》</a>。这篇文章主要从以下几个角度来看Small框架的实现原理。</p>
<ol>
<li>Small如何实现插件代码打包和资源打包</li>
<li>Small加载插件代码和资源的原理</li>
<li>Small代理插件activity生命周期的原理</li>
</ol>
<h4 id="0x01_Small如何打包module代码?">0x01 Small如何打包module代码?</h4><a id="more"></a>
<p>small插件化中的三种组件角色，分别是<code>app.*</code>，<code>lib.*</code>，<code>宿主</code>。small在打包过程中会根据不同module的类型针对不同组件使用不同编译插件做处理，分别是:</p>
<ol>
<li><code>AppPlugin</code> –&gt; <code>app.*</code></li>
<li><code>LibraryPlugin</code> –&gt; <code>lib.*</code></li>
<li><code>HostPlugin</code> –&gt; <code>app</code></li>
<li><code>AssetPlugin</code> –&gt; <code>其他</code> </li>
</ol>
<p>在处理模块依赖上，首先区分gradle的两种依赖方式:</p>
<ol>
<li>Compile: compile是对所有的build type以及flavors都会参与编译并且打包到最终的apk文件中。</li>
<li>Provided: Provided是对所有的build type以及flavors只在编译时使用，只参与编译，不打包到最终apk。</li>
</ol>
<p>在打包<code>app.*</code>插件时，将<code>app.*</code>对其他module的依赖转换成<code>provided</code>依赖。当执行插件打包时可以看做是插件模块执行<code>assembleRelease</code>。</p>
<p>在打包<code>lib.*</code>插件时，<code>LibraryPlugin</code>会修改插件模块的<code>build.gradle</code>文件，<code>apply plugin:</code>从<code>&#39;com.android.library&#39;</code>修改成<code>&#39;com.android.application&#39;</code>，将对lib的方式转换成app的打包，再执行<code>assembleRelease</code>任务。</p>
<p>👍👍👍</p>
<h4 id="0x02_Small如何解决资源id冲突?">0x02 Small如何解决资源id冲突?</h4><p>Android App资源id的格式是0xPPTTNNNN，其中：</p>
<ul>
<li>PP 资源的package id</li>
<li>TT 资源类型的id，类型是attr、layout、string等等</li>
<li>NNNN 资源的entry id</li>
</ul>
<p>Android App资源的默认packageId是0x7f，当同时加载多个插件apk时。必然会有插件间资源id冲突的情况。业界解决资源id冲突主要通过package id的分段，实现方式一般有两种方式，第一种方式是修改aapt工具源码，让aapt针对插件打包时每个插件的packageId都不相同，重新编译出aapt，而达到解决资源id冲突的问题。small框架使用的是另外一种方式，那就是读取并重写resources.arsc文件。大致的处理流程如下（出自small原作者在github issues的回答）：</p>
<ol>
<li>编译完整的资源包，利用symbol/R.txt搜集完整包entries的资源信息</li>
<li>搜集当前插件包res目录的entry信息</li>
<li>根据(2)，通过重新排序分配各个entry的资源id，并结合(1),形成旧id到新id的映射</li>
<li>解析(1)生成的resources.arsc文件，利用(3)进行过滤输出</li>
</ol>
<h4 id="0x03_Small如何加载插件代码？">0x03 Small如何加载插件代码？</h4><p>Small的加载插件代码的方式基于android dex分包方案的，简单的说small通过将多个dex文件塞入到app的classloader中，达到加载插件代码的目的。Small并不会更换系统的classloader，所以这样在面对多种不同机型时可能就不会遇到的兼容性问题。</p>
<p>怎样把多个dex文件塞入系统classloader中，可以看下<a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=0" target="_blank" rel="external">QQ空间的热修复方案</a></p>
<h4 id="0x04_Small如何加载插件资源?">0x04 Small如何加载插件资源?</h4><p>Android资源是由 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/content/res/AssetManager.java" target="_blank" rel="external">AssetManager</a> 加载的。应用启动时系统创建一个AssetManager实例，并通过<code>addAssetPath</code>方法添加资源路径，默认添加:</p>
<ul>
<li>“/framework/base.apk” - Android base resources (base)</li>
<li>“/data/app/*.apk” - The launching apk resources (host)</li>
</ul>
<p>那么如何让插件的资源能够被系统加载？Small的方式是自己创建的AssetManager，调用AssetManger的<code>addAssetPath</code>方法添加插件资源路径，再将系统创建的AssetManager替换掉。</p>
<p>Hook AssetManager路径如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread&#10;|&#10;|---ResourcesManager mResourcesManager&#10;    |&#10;    |--- ArrayList&#60;WeakReference&#60;Resources&#62;&#62; mResourceReferences&#10;         |&#10;         |--- ResourcesImpl mResourcesImpl&#10;              |&#10;              |--- AssetManager mAssets&#10;         &#10;    |--- ArrayMap&#60;ResourcesKey, WeakReference&#60;ResourcesImpl&#62;&#62; mResourceImpls&#10;         |&#10;         |--- ResourcesImpl mResourcesImpl&#10;              |&#10;              |--- AssetManager mAssets</span><br></pre></td></tr></table></figure>
<h4 id="0x05_Small如何代理插件Activity的生命周期?">0x05 Small如何代理插件Activity的生命周期?</h4><p>先看Andriod中Activity是如何启动的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyActivity.startActivity()&#10;|&#10;|--&#62;Activity.startActivity() &#10;    |&#10;    |--&#62;Activity.startActivityForResult()&#10;        |&#10;        |--&#62;Instrumentation.execStartActivty()&#10;            |&#10;            |--&#62;ActivityManagerNative.getDefault().startActivityAsUser()</span><br></pre></td></tr></table></figure>
<p>通过 Activity 的启动流程可以发现，Activity是由 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/ActivityThread.java" target="_blank" rel="external">ActivityThread</a> 和 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/Instrumentation.java" target="_blank" rel="external">Instrumentation</a> 启动的，Instrumentation有关Activity启动相关的方法大概有：execStartActivity、newActivity等等。Small是这样操作的: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyActivity.startActivity()&#10;|&#10;|--&#62;Activity.startActivity() &#10;    |&#10;    |--&#62;Activity.startActivityForResult()&#10;        |&#10;        |--&#62;InstrumentationWrapper.execStartActivty()&#10;            |&#10;            |--&#62; InstrumentationWrapper.wrapIntent() &#23558; Intent &#123; cmp=net.wequick.example.small/.app.main.MainActivity &#125;&#10;            |--&#62; &#36716;&#25442;&#25104; Intent &#123; cat=[&#62;net.wequick.example.small.app.main.MainActivity] cmp=net.wequick.example.small/net.wequick.small.A &#125;&#10;                |&#10;                |--&#62;Instrumentation.execStartActivty()&#10;                    |&#10;                    |--&#62;ActivityManagerNative.getDefault().startActivityAsUser()</span><br></pre></td></tr></table></figure>
<p>Small首先在宿主manifest中注册一个命名特殊的占坑activity来欺骗系统获取生命周期，在封装一个Instrumentation替换掉宿主的，系统启动的是A这个activity，但classloader实际加载的代码却是 MainActivity.class 这个类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;!-- Stub Activities --&#62;&#10;&#60;activity android:name=&#34;.A&#34; android:launchMode=&#34;standard&#34;/&#62;</span><br></pre></td></tr></table></figure>
<p>伪代码如下: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread thread = currentActivityThread();&#10;Instrumentation base = thread.@mInstrumentation;&#10;Instrumentation wrapper = new InstrumentationWrapper(base);&#10;thread.@mInstrumentation = wrapper;&#10;&#10;class InstrumentationWrapper extends Instrumentation &#123;&#10;    public ActivityResult execStartActivity(..., Intent intent, ...) &#123;&#10;        fakeToStub(intent);&#10;        base.execStartActivity(args);&#10;    &#125;&#10;&#10;    @Override&#10;    public Activity newActivity(ClassLoader cl, String className, Intent intent) &#123;&#10;        className = restoreToReal(intent, className);&#10;        return base.newActivity(cl, className, intent);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0x06_Small如何动态更新插件模块?">0x06 Small如何动态更新插件模块?</h4><p><a href="https://github.com/wequick/Small/blob/master/Android/Sample/app.home/src/main/java/net/wequick/example/small/app/home/MainFragment.java" target="_blank" rel="external">查看github sample实现方式</a></p>
<h4 id="0x07_参考文档">0x07 参考文档</h4><p><a href="https://github.com/wequick/Small/wiki" target="_blank" rel="external">Small 官方 wiki</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=0" target="_blank" rel="external">QQ空间热补丁动态修复技术介绍</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;0x00_前言&quot;&gt;0x00 前言&lt;/h4&gt;&lt;p&gt;Small是一个轻量化的插件化框架，Small的使用介绍可以查看&lt;a href=&quot;http://code.wequick.net/Small/cn/quickstart&quot;&gt;官网文档&lt;/a&gt;了解，Small项目接入总结可以查看博客的另一篇&lt;a href=&quot;https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/&quot;&gt;《Small框架实践总结》&lt;/a&gt;。这篇文章主要从以下几个角度来看Small框架的实现原理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Small如何实现插件代码打包和资源打包&lt;/li&gt;
&lt;li&gt;Small加载插件代码和资源的原理&lt;/li&gt;
&lt;li&gt;Small代理插件activity生命周期的原理&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;0x01_Small如何打包module代码?&quot;&gt;0x01 Small如何打包module代码?&lt;/h4&gt;
    
    </summary>
    
      <category term="安卓插件化" scheme="https://ivonhoe.github.io/categories/%E5%AE%89%E5%8D%93%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="插件化" scheme="https://ivonhoe.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化之Small框架实践总结</title>
    <link href="https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://ivonhoe.github.io/2018/01/18/Small框架实践总结/</id>
    <published>2018-01-18T09:42:57.000Z</published>
    <updated>2018-05-27T08:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x00_前言">0x00 前言</h4><p>这篇文章主要总结了在使用Small框架改造老项目过程中遇到的问题和相应的解决方案，也总结了使用Small框架的基础知识点，并从一个使用者的角度来分析Small框架的优缺点。如果你的项目也面临业务模块耦合，边界不清晰，没有动态部署方案等等需要插件化方案来解决的问题，不妨先看下这篇文章再试一试Small框架，Small的功能未必全面但绝对聚焦了插件化框架需要解决的的核心问题。</p>
<p>什么是Small框架？ Small是一个轻量级的插件化框架，Small也是一个dex分包方案，Small也是一个业务模块解耦方案，同时Small也是一个动态化加载和更新方案。先去看官网文档了解Small的基础知识~~</p>
<p><a href="http://code.wequick.net/Small/cn/quickstart" target="_blank" rel="external">Small官网文档</a></p>
<a id="more"></a>
<h4 id="0x01_Small必知必会">0x01 Small必知必会</h4><p><img src="/res/small/small-1.png" alt="Small角色关系"></p>
<ol>
<li>Small框架将工程模块分为这几个角色，宿主，宿主分身，app插件，公共lib插件</li>
<li>宿主不依赖任何模块，宿主分身被所有app和lib依赖，但是宿主和宿主分身都被打包在主应用的主dex中，app插件和公共lib插件被单独打包在自己的插件so中</li>
<li>Small如何编译? <ul>
<li>./gradlew cleanLib </li>
<li><strong>编译公共库:</strong> ./gradlew buildLib </li>
<li>./gradlew cleanBundle</li>
<li><strong>编译app插件:</strong> ./gradle buildBundle </li>
<li><strong>编译宿主app:</strong> ./gradle :app:assembleDaily  <strong>注意：</strong>这里不是assembleDaily 而是:app:assembleDaily</li>
</ul>
</li>
<li>app插件的模块名称必须是app.<em> , 公共库lib插件的模块名称必须是lib.</em>。</li>
<li>在宿主app assets目录的bundle.json文件中声明每个插件的包名、类型和页面路由等信息。当app插件的包名为 <code>**.app.*</code> 或 <code>**.app*</code>时, small框架会默认该插件模块为app插件。</li>
<li>app插件和app插件之间无法相互依赖，app插件之间可以通过路由uri传参，或者LocalBroadcast、Eventbus等消息机制实现通信。</li>
<li><p>Small中插件的packageId是自动根据模块名称hash计算生成，有可能会遇到插件模块packageId冲突的情况，在这种情况下需要在发生冲突模块的build.gradle重新声明packageId, 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;&#10;  packageId = 0x33&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成插件到 x86 架构下./gradlew buildLib -q -Dbundle.arch=x86，<strong>需要注意</strong> 宿主的ndk abiFilters 要和<code>bundle.arch</code>一致哦。</p>
</li>
<li>如何启动其他插件模块的页面？通过<code>Small.openUri()</code>方法打开页面的路由地址。</li>
<li>动态更新插件时，需要升级插件的versionCode才会生效</li>
<li>非Activity组件需要声明在宿主或者宿主分身的manifest中</li>
</ol>
<h4 id="0x02_Small框架的优缺点">0x02 Small框架的优缺点</h4><p><strong>选择small框架的原因：</strong></p>
<ol>
<li>集成简单</li>
<li>开发方式非常接近Android app的原生开发方式</li>
<li>不需要更换编译工具，已有项目中针对业务需求开发的编译工具依然可以继续使用</li>
<li>优雅，特别是对资源id冲突的处理方式</li>
<li>轻量化，尽可能少的hook系统变量，兼容性问题较少</li>
</ol>
<p><strong>不选择small框架的原因：</strong></p>
<ol>
<li>插件的加载并不是按需加载</li>
<li>插件的更新实现较简单，且没有回滚方案</li>
<li>有些隐藏bug还未解决，但可以绕过</li>
<li>功能相对其他插件化框架(比如atlas)来说还不够完善，但足够解决项目插件化目标中遇到的80%问题</li>
</ol>
<h4 id="0x03_Small插件化实践踩过的那些坑">0x03 Small插件化实践踩过的那些坑</h4><p>遇到问题怎么办？到github issues里查询你遇到的问题，一般都可以找到答案。这里大致总结了我们团队在small框架使用过程中遇到的常见问题。</p>
<ol>
<li>lib插件中增加或减少资源时，需要删除模块目录下public.xml再重新编译。public.xml是为了锁定lib中资源id</li>
<li>增加或修改插件中ndk module覆盖安装不生效，需要将native module编译生成的so文件放在宿主中才能实现更新</li>
<li>遇到ClassNotFoundException异常或者无法启动某些activity companentInfo，排查问题的方法:<ul>
<li>查看Fatal Runtime Exception日志，查看日志中已经加载的so是否包含你的插件so</li>
<li>如果插件so被加载，再确定相应代码已经被编译进插件so中，查看方法很简单，将插件so重命名为apk直接在Android Studio中打开 </li>
<li>确认是否将插件so正确声明在bundle.json文件中</li>
<li>确认该异常类继承的父类或者接口满足上述几个条件</li>
</ul>
</li>
<li>Class ref in pre-verified class resolved to unexpected implementation ，使用gradle smallLint命令查看是否有class重复了 <a href="https://github.com/wequick/Small/issues/423" target="_blank" rel="external">https://github.com/wequick/Small/issues/423</a></li>
<li>Activity launch mode为singletop时在activity style中设置透明背景无效 <a href="https://github.com/wequick/Small/issues/94" target="_blank" rel="external">https://github.com/wequick/Small/issues/94</a></li>
<li>无法通过Small.openUri()方法启动页面怎么办？一定是你用法不对，debug找原因。</li>
</ol>
<h4 id="0x04_Small插件化规范">0x04 Small插件化规范</h4><ol>
<li>不要在宿主中添加业务代码</li>
<li>native module so放在宿主中, 原因关注Github issue: <a href="https://github.com/wequick/Small/issues/560" target="_blank" rel="external">增加或修改插件中ndk module覆盖安装不生效 </a></li>
<li>不同插件模块中依赖相同第三方aar或jar的版本号要相同，建议将aar或jar的版本号统一声明在gradle.properties中，将共同依赖的第三方sdk声明在宿主分身中</li>
<li>所有Theme的定义都放在宿主和宿主分身中，具体原因看我的另一篇问题总结：<a href="https://ivonhoe.github.io/2018/03/14/small-bug-555-fix/">Android插件化之资源加载</a></li>
</ol>
<p><strong>Small插件化项目的完全体</strong></p>
<p><img src="/res/small/small-2.png" alt="Small插件化完全体"></p>
<h4 id="0x05_Small框架原理">0x05 Small框架原理</h4><p>详情查看这篇–&gt;&gt;</p>
<p><a href="https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/">《Small框架原理总结》</a></p>
<p><a href="https://ivonhoe.github.io/2018/03/14/small-bug-555-fix/">《Android插件化之资源加载》</a></p>
<h4 id="0x06_参考">0x06 参考</h4><p>Small官网文档 <a href="http://code.wequick.net/Small/cn/quickstart" target="_blank" rel="external">http://code.wequick.net/Small/cn/quickstart</a></p>
<p>Small github主页 <a href="https://github.com/wequick/Small" target="_blank" rel="external">https://github.com/wequick/Small</a></p>
<p><a href="http://code.wequick.net/small/docs/ppt/gmtc-galen-small.ppsx" target="_blank" rel="external">GMTC演讲PPT</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;0x00_前言&quot;&gt;0x00 前言&lt;/h4&gt;&lt;p&gt;这篇文章主要总结了在使用Small框架改造老项目过程中遇到的问题和相应的解决方案，也总结了使用Small框架的基础知识点，并从一个使用者的角度来分析Small框架的优缺点。如果你的项目也面临业务模块耦合，边界不清晰，没有动态部署方案等等需要插件化方案来解决的问题，不妨先看下这篇文章再试一试Small框架，Small的功能未必全面但绝对聚焦了插件化框架需要解决的的核心问题。&lt;/p&gt;
&lt;p&gt;什么是Small框架？ Small是一个轻量级的插件化框架，Small也是一个dex分包方案，Small也是一个业务模块解耦方案，同时Small也是一个动态化加载和更新方案。先去看官网文档了解Small的基础知识~~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://code.wequick.net/Small/cn/quickstart&quot;&gt;Small官网文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="安卓插件化" scheme="https://ivonhoe.github.io/categories/%E5%AE%89%E5%8D%93%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="插件化" scheme="https://ivonhoe.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android安全之某团请求加密破解</title>
    <link href="https://ivonhoe.github.io/2017/06/18/android-app-gold-flow-hack/"/>
    <id>https://ivonhoe.github.io/2017/06/18/android-app-gold-flow-hack/</id>
    <published>2017-06-18T10:13:19.000Z</published>
    <updated>2018-05-27T08:19:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00_前言">0x00 前言</h3><p>本文记录了破解某外卖App http请求参数加密过程中遇到的问题和解决思路，实现的目标是希望是能够通过一些手段实现自由调用其服务接口。<br>这篇文章主要讲述什么？</p>
<ol>
<li>静态分析和动态调试的基本方法和遇到的问题</li>
<li>如何听过修改android源码实现全局hook</li>
</ol>
<p><img src="/res/meituan_hack/meituan-1.png" alt="想要破解的网络请求"></p>
<a id="more"></a>
<p>可以看到每次请求都会自动生成相应的请求参数，并计算出一个加密后的参数<code>__skcy</code>，服务端根据这些参数信息和请求内容做校验，校验通过服务端才会返回正确的结果。通过抓包和反编译后的代码大致梳理了上图请求参数的含义和生成方法，具体参数如下所示:</p>
<ul>
<li><strong>__skck:</strong>Java层面<strong>常量</strong>，6a375bce8c66a0dc293860dfa83833ef</li>
<li><strong>__skts:</strong>系统时间值，通过Sytem.currentTime()获取，例如：1487054997740</li>
<li><strong>__skua:</strong>通过UserAgent方法，获取ua，并计算出md5，通过动态调试发现该UserAgent方法返回为空，所以该值也为<strong>常量</strong>，d41d8cd98f00b204e9800998ecf8427e</li>
<li><strong>__skno:</strong>通过Java randomUUID获取随机数，例如：eccb0210-c86f-43bb-b12d-04927547b9ea</li>
<li><strong>__skcy:</strong>以上四个参数加上PostContent，调用native方法获取加密后得到该值</li>
</ul>
<!-- more -->
<h3 id="0x01_尝试静态分析">0x01 尝试静态分析</h3><p>首先使用常用的静态分析工具，如apkTools、dex2jar做apk的反编译和转Jar。虽然该App安装包没有加壳，但在反编译过程中依然遇到一些问题。</p>
<h4 id="1-1、遇到问题">1.1、遇到问题</h4><p>该App针对dex2jar工具做了防范. 原理分析请看<a href="https://ivonhoe.github.io/2017/02/09/%E7%BE%8E%E5%9B%A2%E5%A6%82%E4%BD%95%E9%98%B2dex2jar/">Android安全之应用防dex2jar原理及实现</a></p>
<h4 id="1-2、解决方案">1.2、解决方案</h4><ul>
<li>将插入的Exist代码删除，再做smali–&gt;dex–&gt;jar处理。</li>
<li>或者，直接阅读smali代码。</li>
</ul>
<h4 id="1-3、分析结果">1.3、分析结果</h4><ul>
<li>该App在java层处理Http请求的核心类是<code>CandyPreProcessor.java</code></li>
<li>该App调用加密so的JNI类是 <code>CandyJni.java</code></li>
<li>该App执行参数加密的so是<code>libmtguard.so</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class CandyJni&#10;&#123;&#10;  static&#10;  &#123;&#10;    System.loadLibrary(&#34;mtguard&#34;);&#10;  &#125;&#10;  &#10;  static native String getCandyDataWithKey(Object paramObject, byte[] paramArrayOfByte, String paramString);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0x02_尝试动态调试smali">0x02 尝试动态调试smali</h3><p>这里先使用了源apk包在root手机上进行调试，但没有成功。只能尝试重打包调试。</p>
<h4 id="2-1、如何使用AS动态调试">2.1、如何使用AS动态调试</h4><p>参考<a href="http://www.52pojie.cn/thread-502219-1-1.html" target="_blank" rel="external">吾爱破解</a>这篇文章，需要下载AS baksmali插件，需要注意的是：</p>
<ul>
<li>AS remote debug端口号设置为8700</li>
<li>AS没有识别安卓代码情况下工具栏没有Android Device monitor的按钮，这时候通过monitor命令启动monitor</li>
<li>如果monitor启动时提示8700端口已经被占用，可以通过 <code>lsof -n -i4TCP:8700 | grep LISTEN</code> 命令查看8700端口目前对应的进程名</li>
<li>attach前一定要先在monitor里选中想要调试的进程，再debug</li>
</ul>
<h4 id="2-2、重写Java代码，直接调用加密so">2.2、重写Java代码，直接调用加密so</h4><p>动态调试可以比较清楚的看到Java层的内部调用逻辑，通过debug watch功能可以清楚的看到寄存器值，结合反编译和静态分析可以知道调用native方法的入参格式。</p>
<p>现在的思路是解压出源apk包中的so文件，编写java代码直接调用so文件中的native方法获取计算__skcy参数。但测试的结果是一直返回<code>null</code>。这里猜测在native层中对运行环境做了监测，所以一直返回空值。</p>
<p>这里该app的参数签名详细过程是，通过<code>__skck、__skts、__skno、__skua(详细规则见上)</code>，调用<code>CandyPreprocessor.java</code>的<code>getParametersSignature()</code>方法获取<code>__skcy</code>参数。Java层核心方法<code>getParametersSignature()</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * @param paramBuilder https://eapi.*****/api/poi/logon/acctdevice?__skck=6a375bce8c66a0dc293860dfa83833ef&#38;__skts=1486970558719&#38;__skua=d41d8cd98f00b204e9800998ecf8427e&#38;__skno=5ed4629c-098c-489c-b598-81841e0479e0&#10; */&#10;String getParametersSignature(Uri.Builder paramBuilder, Context paramContext) &#123;&#10;    if (paramBuilder == null) &#123;&#10;        throw new RuntimeException(&#34;CandyPreprocessor getParametersSignature builder is null&#34;);&#10;    &#125;&#10;    // &#33719;&#21462;&#32593;&#32476;&#25509;&#21475;&#21517;&#31216; https://eapi.waimai.meituan.com/api/poi/logon/acctdevice&#10;    Object localObject = baseString();&#10;    if (TextUtils.isEmpty((CharSequence) localObject)) &#123;&#10;        throw new RuntimeException(&#34;CandyPreprocessor getParametersSignature normalizedURI is null&#34;);&#10;    &#125;&#10;    ArrayList localArrayList = new ArrayList();&#10;    /**&#10;     * 0 = &#123;CandyPreprocessor$MyEntry@5016&#125; &#34;__skck&#34; -&#62; &#34;6a375bce8c66a0dc293860dfa83833ef&#34;&#10;     1 = &#123;CandyPreprocessor$MyEntry@5017&#125; &#34;__skts&#34; -&#62; &#34;1486970558719&#34;&#10;     2 = &#123;CandyPreprocessor$MyEntry@5018&#125; &#34;__skua&#34; -&#62; &#34;d41d8cd98f00b204e9800998ecf8427e&#34;&#10;     3 = &#123;CandyPreprocessor$MyEntry@5019&#125; &#34;__skno&#34; -&#62; &#34;5ed4629c-098c-489c-b598-81841e0479e0&#34;&#10;     */&#10;    // &#33719;&#21462;&#21442;&#25968;key&#21644;&#21442;&#25968;value&#25918;&#21040;&#25968;&#32452;&#20013;&#10;    appendList(localArrayList, paramBuilder, false);&#10;    // add &#34;__sksc&#34; -&#62; &#34;https&#34;&#10;    // &#33719;&#21462;scheme&#25918;&#20837;&#25968;&#32452;&#20013;&#10;    localArrayList.add(new CandyPreprocessor.MyEntry(&#34;__sksc&#34;, this.candyOriginalMaterial.getScheme()));&#10;    // &#23558;post content&#25918;&#20837;&#25968;&#32452;&#20013;&#10;    if (formURLEncoded()) &#123;&#10;        // /?dVersion=23_6.0&#38;utm_medium=android&#38;password=2222&#38;utm_content=867689027084732&#38;appCode=388&#38;acctId=&#38;wmPoiId=&#38;token=&#38;uuid=03EB35F2C93419DC64AFFBC9EF6BB6BADE4DD72DC1E2F4733198E91C91AEAF93&#38;logType=C&#38;appName=%E7%BE%8E%E5%9B%A2%E5%A4%96%E5%8D%96%E5%95%86%E5%AE%B6%E7%89%88&#38;appType=4&#38;dType=PLK-TL01H&#38;userName=1111&#38;utm_term=4.2.0.388&#38;utm_source=&#38;utm_campaign=&#38;wm_appversion=4.2.0.388&#38;&#10;        // post &#30340;&#20869;&#23481;&#20837;&#21442;&#10;        /**&#10;         * 5 = &#123;CandyPreprocessor$MyEntry@5071&#125; &#34;dVersion&#34; -&#62; &#34;23_6.0&#34;&#10;         6 = &#123;CandyPreprocessor$MyEntry@5072&#125; &#34;utm_medium&#34; -&#62; &#34;android&#34;&#10;         7 = &#123;CandyPreprocessor$MyEntry@5073&#125; &#34;password&#34; -&#62; &#34;123&#34;&#10;         8 = &#123;CandyPreprocessor$MyEntry@5074&#125; &#34;utm_content&#34; -&#62; &#34;867689027084732&#34;&#10;         9 = &#123;CandyPreprocessor$MyEntry@5075&#125; &#34;appCode&#34; -&#62; &#34;388&#34;&#10;         10 = &#123;CandyPreprocessor$MyEntry@5076&#125; &#34;acctId&#34; -&#62;&#10;         11 = &#123;CandyPreprocessor$MyEntry@5077&#125; &#34;wmPoiId&#34; -&#62;&#10;         12 = &#123;CandyPreprocessor$MyEntry@5078&#125; &#34;token&#34; -&#62;&#10;         13 = &#123;CandyPreprocessor$MyEntry@5079&#125; &#34;uuid&#34; -&#62; &#34;03EB35F2C93419DC64AFFBC9EF6BB6BADE4DD72DC1E2F4733198E91C91AEAF93&#34;&#10;         14 = &#123;CandyPreprocessor$MyEntry@5080&#125; &#34;logType&#34; -&#62; &#34;C&#34;&#10;         15 = &#123;CandyPreprocessor$MyEntry@5081&#125; &#34;appName&#34; -&#62; &#34;****&#34;&#10;         16 = &#123;CandyPreprocessor$MyEntry@5082&#125; &#34;appType&#34; -&#62; &#34;4&#34;&#10;         17 = &#123;CandyPreprocessor$MyEntry@5083&#125; &#34;dType&#34; -&#62; &#34;PLK-TL01H&#34;&#10;         18 = &#123;CandyPreprocessor$MyEntry@5084&#125; &#34;userName&#34; -&#62; &#34;***&#34;&#10;         19 = &#123;CandyPreprocessor$MyEntry@5085&#125; &#34;utm_term&#34; -&#62; &#34;4.2.0.388&#34;&#10;         20 = &#123;CandyPreprocessor$MyEntry@5086&#125; &#34;utm_source&#34; -&#62;&#10;         21 = &#123;CandyPreprocessor$MyEntry@5087&#125; &#34;utm_campaign&#34; -&#62;&#10;         22 = &#123;CandyPreprocessor$MyEntry@5088&#125; &#34;wm_appversion&#34; -&#62; &#34;4.2.0.388&#34;&#10;         */&#10;        appendList(localArrayList, Uri.parse(&#34;/?&#34; + new String(this.candyOriginalMaterial.getPostContent())).buildUpon(), true);&#10;    &#125;&#10;    // &#29305;&#27530;&#23383;&#31526;&#36716;&#30721;&#10;    List percentParamList = getPercentList(localArrayList);&#10;    // &#20998;&#21035;&#23545;Value&#21644;Key&#20570;&#21319;&#24207;&#25490;&#21015;&#10;    dictionarySort(percentParamList);&#10;    // &#23558;&#25490;&#24207;&#21518;&#30340;&#25968;&#32452;&#65292;&#25340;&#25509;&#25104;&#23383;&#31526;&#20018;__skck=6a375bce8c66a0dc293860dfa83833ef&#38;__skno=5ed4629c-098c-489c-b598-81841e0479e0&#38;__sksc=https&#38;__skts=1486970558719&#38;__skua=d41d8cd98f00b204e9800998ecf8427e&#38;acctId=&#38;appCode=388&#38;appName=%E7%BE%8E%E5%9B%A2%E5%A4%96%E5%8D%96%E5%95%86%E5%AE%B6%E7%89%88&#38;appType=4&#38;dType=PLK-TL01H&#38;dVersion=23_6.0&#38;logType=C&#38;password=2222&#38;token=&#38;userName=1111&#38;utm_campaign=&#38;utm_content=867689027084732&#38;utm_medium=android&#38;utm_source=&#38;utm_term=4.2.0.388&#38;uuid=03EB35F2C93419DC64AFFBC9EF6BB6BADE4DD72DC1E2F4733198E91C91AEAF93&#38;wmPoiId=&#38;wm_appversion=4.2.0.388&#10;    String paramBuilderString = getNormalizedParameters(percentParamList);&#10;    // POST+&#31354;&#26684;+&#34;&#25509;&#21475;&#21517;&#31216;&#34;+&#31354;&#26684;+&#34;&#21442;&#25968;&#20869;&#23481;&#34;&#10;    // POST http://eapi.waimai.meituan.com/api/poi/logon/acctdevice __skck=6a375bce8c66a0dc293860dfa83833ef&#38;__skno=57749130-26d4-4239-8abd-b99c16584908&#38;__sksc=http&#38;__skts=1486995346041&#38;__skua=d41d8cd98f00b204e9800998ecf8427e&#38;acctId=&#38;appCode=388&#38;appName=%E7%BE%8E%E5%9B%A2%E5%A4%96%E5%8D%96%E5%95%86%E5%AE%B6%E7%89%88&#38;appType=4&#38;dType=PLK-TL01H&#38;dVersion=23_6.0&#38;logType=C&#38;password=2222&#38;token=&#38;userName=1111&#38;utm_campaign=&#38;utm_content=867689027084732&#38;utm_medium=android&#38;utm_source=&#38;utm_term=4.2.0.388&#38;uuid=03EB35F2C93419DC64AFFBC9EF6BB6BADE4DD72DC1E2F4733198E91C91AEAF93&#38;wmPoiId=&#38;wm_appversion=4.2.0.388&#10;    paramBuilderString = this.candyOriginalMaterial.getHttpMethod() + &#34; &#34; + (String) localObject + &#34; &#34; + paramBuilderString;&#10;    // JV1EOT1VZGN8USskB3jZYnVGyyQ=&#10;    // &#35843;&#29992;jni&#33719;&#21462;&#21152;&#23494;&#21518;&#30340;&#21442;&#25968;&#20540;__skcy&#10;    localObject = CandyJni.getCandyDataWithKey(paramContext, paramBuilderString.getBytes(), &#34;candyKey&#34;);&#10;&#10;    // TODO for test&#10;    return (String) localObject;&#10; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3、修改app代码，重打包调用so">2.3、修改app代码，重打包调用so</h4><p>直接调用so的方法失败了，现在尝试反编译APK后，加入包含自己逻辑的smali代码，调用CandyJni的目的。具体的步骤是：</p>
<ul>
<li>利用上2.2的项目，拷贝和该App CandyJni完全相同的类名，方法名。</li>
<li>编写CandyHackActivity.Java和CandyHack.java，去调用新项目中的CandyJni，并打包。</li>
<li>apktools反编译新项目包，获取CandyHack.smali 和CandyHackActivity.smali。</li>
<li>修改反编译后项目的AndroidManifest.xml文件，将CandyHackActivity注册到manifest中进去。</li>
<li>重打包，签名，安装。</li>
<li>通过adb命令启动CandyHackActivity。</li>
</ul>
<p><img src="/res/meituan_hack/meituan_smali1.png" alt=""></p>
<p>结果一点不意外，能够成功调用CandyJni中的方法并且有返回值，但是经过测试在相同入参的情况下，和源APK包的加密结果不一致。问题应该出在签名。猜测应该是so中的方法将应用签名作为了一个加密参数。虽然能正常调用，但结果是错的~~</p>
<h4 id="2-4、尝试IDA_pro反编译so">2.4、尝试IDA pro反编译so</h4><p>一句话，IDA反编译后发现，在function窗口中找不到getCandyDataWithKey或者getCandyData这些在Java层声明的native方法。应该是使用了动态注册的方式注册了native方法，又一次把代码阅读门槛从C升级到了汇编，泪目~~~</p>
<p><img src="/res/meituan_hack/meituan_ida.jpeg" alt="native方法混淆"></p>
<h4 id="2-5、总结问题">2.5、总结问题</h4><ul>
<li>想要在root机器上动态调试dex，但不进行重打包，就需要绕过他的反调试手段。反调试手段是什么？怎么绕过？我不知道</li>
<li>想要通过重打包动态调试dex，重打包必须重新签名，重新签名会导致加密算法计算结果出错。</li>
<li>想要反编译so，需要阅读加密后的C语言和汇编语言。汗！我是菜鸟汇编阅读不来</li>
</ul>
<h3 id="0x03_万金流破解思路">0x03 万金流破解思路</h3><p>根据以上分析的过程，发现不管是重打包、借用so、静态分析、动态调试等基础的破解方式，该app都做了相应的防护措施，总的破解思路都是破坏了app原有环境。在一次逛安全论坛的过程中，看到通过修改Android原生代码加载特定so的思路，其实这种破解思路也适用于app的破解。如果在app启动时，让app进程的DexClassLoader能够加载你自己的代码，那么不管在任何的app运行环境中，诸如修改内存变量、调用方法或者是改变原有app系统的处理流程等目的都能够轻松达到。当然前提是运行在自己编译的Android源码或者是已经root的机器上。下面就以这个思路针对该外卖app做具体的破解实操，目标是在pc上能够自由调用该app服务端的http接口。</p>
<h4 id="3-1-_下载并修改源码">3.1. 下载并修改源码</h4><p>如何下载编译源码这里不废话，没有尝试过的可以参考这篇<a href="http://ivonhoe.github.io/2017/01/20/MacOS%E4%B8%8A%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81/">《Mac OS上编译Android源码》</a>。<br>在<code>ActivityThread.java</code>的<code>handleBindApplication()</code>方法中增加dex注入的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;&#10;    // &#30465;&#30053;&#28304;&#30721;...&#10;    &#10;    //=================&#20840;&#23616;&#27880;&#20837;&#20043;&#20462;&#25913;java&#23618;===================================================&#10;    checkFrameworkInject(data.processName);&#10;    //=============================================================================&#10;&#125;&#10;&#10;private void checkFrameworkInject(String processName) &#123;&#10;    //=================&#20840;&#23616;&#27880;&#20837;&#20043;&#20462;&#25913;java&#23618;===================================================&#10;    Log.e(&#34;frameworkInjector&#34;, &#34;--processName=&#34; + processName);&#10;    invokeJarLoader(processName);&#10;    //=============================================================================&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>从指定路径加载配置文件，配置信息包括要dex注入的进程名，dex路径，dex中main函数信息。<br>当相应的进程启动时，加载指定路径的dex，并运用其中的main函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10;     * &#26681;&#25454;&#37197;&#32622;&#21152;&#36733;jar&#65292;&#25191;&#34892;&#25351;&#23450;&#31867;&#30340;main&#26041;&#27861;&#10;     */&#10;    public void invokeJarLoader(String processName) &#123;&#10;        List&#60;String&#62; config = readHookConfig(&#34;/data/local/jarHookConfig.txt&#34;);&#10;&#10;        if (config == null || config.size() &#60; 3) &#123;&#10;            return;&#10;        &#125;&#10;&#10;        String configProcessName = config.get(0);&#10;        String configJarPath = config.get(1);&#10;        String configClassName = config.get(2);&#10;&#10;        if (processName.equals(configProcessName) &#38;&#38; !TextUtils.isEmpty(configJarPath)&#10;                &#38;&#38; !TextUtils.isEmpty(configClassName)) &#123;&#10;            Log.e(&#34;frameworkInjector&#34;, &#34;targetPackage:&#34; + configProcessName +&#10;                    &#34;,start-load-jarPath&#34; + configJarPath + &#34;, class name:&#34; + configClassName);&#10;            jarInvokeTest(configJarPath, configClassName);&#10;        &#125;&#10;    &#125;&#10;&#10;    public void jarInvokeTest(String jarPath, String className) &#123;&#10;        final File optimizedDexOutputPath = new File(jarPath);&#10;        Context context = getApplication();&#10;        File dexOutputDir = context.getDir(&#34;dex&#34;, 0);&#10;        DexClassLoader cl = new DexClassLoader(&#10;                optimizedDexOutputPath.getAbsolutePath(),&#10;                dexOutputDir.getAbsolutePath(), null, context.getClassLoader());&#10;        Class libProviderClazz = null;&#10;&#10;        try &#123;&#10;            libProviderClazz = cl.loadClass(className);&#10;            Method method = libProviderClazz.getMethod(&#34;main&#34;);&#10;            method.invoke(null, (Object[]) null);&#10;        &#125; catch (ClassNotFoundException e) &#123;&#10;            e.printStackTrace();&#10;        &#125; catch (IllegalAccessException e) &#123;&#10;            e.printStackTrace();&#10;        &#125; catch (NoSuchMethodException e) &#123;&#10;            e.printStackTrace();&#10;        &#125; catch (InvocationTargetException e) &#123;&#10;            e.printStackTrace();&#10;        &#125;&#10;    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2_生成注入的dex">3.2 生成注入的dex</h4><p>在这里具体的注入代码就不啰嗦了，总的来说你可以针对任何app中的任何方法变量任意操作。如果你想在pc上实现请求的自由收发要稍微复杂些，你需要实现一个简单的Hook socket server（简称HSS），将HSS打包成dex做注入，将参与参数加密的数据发送给HSS，HSS调用app中的加密方法获取加密结果，并将最终的加密结果发送出来就可以啦。具体的实现如下图所示:</p>
<p><img src="/res/meituan_hack/meituan_hook.png" alt="hook结构图"></p>
<h3 id="0x04_严重声明">0x04 严重声明</h3><p><strong>本文的意图只有一个，就是通过分析app学习更多的逆向技术，如果有人利用本文知识和技术进行非法操作进行牟利，带来的任何法律责任都将由操作者本人承担，和本文作者无任何关系，最终还是希望大家能够秉着学习的心态阅读此文。</strong></p>
<h3 id="0x05_参考文档">0x05 参考文档</h3><ul>
<li><a href="http://www.jianshu.com/p/730c6e3e21f6" target="_blank" rel="external">Smali语法</a></li>
<li><a href="http://blog.csdn.net/niexinming/article/details/54318634" target="_blank" rel="external">逆向加固的apk详细教程</a></li>
<li><a href="http://www.52pojie.cn/thread-564459-1-1.html" target="_blank" rel="external">修改源码实现全局(无需root)注入躲开注入检测</a></li>
<li><a href="http://www.jianshu.com/p/6438f161875a" target="_blank" rel="external">Android动态加载jar</a></li>
<li><a href="http://www.jianshu.com/p/61cfa1347894" target="_blank" rel="external">Java之jar打包</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00_前言&quot;&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;本文记录了破解某外卖App http请求参数加密过程中遇到的问题和解决思路，实现的目标是希望是能够通过一些手段实现自由调用其服务接口。&lt;br&gt;这篇文章主要讲述什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态分析和动态调试的基本方法和遇到的问题&lt;/li&gt;
&lt;li&gt;如何听过修改android源码实现全局hook&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/res/meituan_hack/meituan-1.png&quot; alt=&quot;想要破解的网络请求&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="移动安全" scheme="https://ivonhoe.github.io/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="移动安全" scheme="https://ivonhoe.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>捕获线程池任务异常引发的血案</title>
    <link href="https://ivonhoe.github.io/2017/05/12/executor-eat-exception/"/>
    <id>https://ivonhoe.github.io/2017/05/12/executor-eat-exception/</id>
    <published>2017-05-12T08:41:53.000Z</published>
    <updated>2018-05-27T08:23:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言">一、前言</h3><p>今天遇到一个很诡异的问题，在多款Android 4.2.2版本的手机上发现处理后台任务的服务对前台请求毫无响应。这里的后台服务是一个RemoteService，目的为了处理更新&amp;上传等任务。本来以为是跨进程组件间通讯出现兼容性问题，后来根据分析发现问题没有那么简单，这里记录下问题原因。</p>
<a id="more"></a>
<h3 id="二、第一个错误">二、第一个错误</h3><p>在后台服务处理任务请求时使用自定义线程池处理异步更新任务，而Java 线程池java.util.concurrent.ThreadPoolExecutor会抓住所有的运行时异常，即便是你运行例如下面的代码也不会抛出异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = new Runnable() &#123;&#10;    @Override&#10;    public void run() &#123;&#10;        Test test = null;&#10;        System.out.println(test.toString());&#10;    &#125;&#10;&#125;;&#10;&#10;mExecutor.submit(runnable);</span><br></pre></td></tr></table></figure>
<p>在处理线程池异常捕获的问题时，犯下了第一个错误，使用了下面的submit方法完成多线程任务时会阻塞当前线程以拿到任务执行结果，可能阻塞的方法<code>future.get()</code>获取异常让线程池变得没有意义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Future&#60;?&#62; submit(Runnable task) &#123;&#10;    Future&#60;?&#62; future = mExecutor.submit(task);&#10;    try &#123;&#10;        future.get();&#10;    &#125; catch (InterruptedException e) &#123;&#10;        Thread.currentThread().interrupt(); // Reset interrupted status&#10;    &#125; catch (ExecutionException e) &#123;&#10;        Throwable exception = e.getCause();&#10;        // Forward to exception reporter&#10;        if (exception instanceof UncatchException) &#123;&#10;            throw (UncatchException) exception;&#10;        &#125;&#10;    &#125;&#10;&#10;    return future;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、第二个错误">三、第二个错误</h3><p>在错误一的基础上，使用了一个开源并发库<a href="https://github.com/litesuits/android-lite-go" target="_blank" rel="external">android-lite-go</a>，先看它的异步任务是如何调度的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int coreSize = CPU_CORE;&#10;int queueSize = coreSize * 32;&#10;&#10;synchronized (lock) &#123;&#10;    if (runningList.size() &#60; coreSize) &#123;&#10;        runningList.add(scheduler);&#10;        threadPool.execute(scheduler);&#10;    &#125; else if (waitingList.size() &#60; queueSize) &#123;&#10;        waitingList.addLast(scheduler);&#10;    &#125; else &#123;&#10;       //...&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当正在运行的任务数小于设定的coreSize时，submit的任务会提交到线程池。</li>
<li>coreSize由系统核心数确定。</li>
<li>当正在运行的任务数小于queueSize时，submit的任务会提交到等待队列中。</li>
<li>当一个任务执行完后，会从等待队列中获取一个任务提交给线程池执行。</li>
</ul>
<p>在一个异步任务中使用阻塞当前线程的方法，把另一个任务提交给了executor。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void runTaskOne() &#123;&#10;    Runnable runnable = new Runnable() &#123;&#10;        @Override&#10;        public void run() &#123;&#10;            // do something&#10;            runTaskTwo();&#10;        &#125;&#10;    &#125;;&#10;&#10;    mTaskController.submit(runnable);&#10;&#125;&#10;&#10;private void runTaskTwo() &#123;&#10;    Runnable runnable = new Runnable() &#123;&#10;        @Override&#10;        public void run() &#123;&#10;            // do task2&#10;            // ......&#10;        &#125;&#10;    &#125;;&#10;&#10;    mTaskController.submit(runnable);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、问题原因及解决方案">三、问题原因及解决方案</h3><p>当正在运行的任务使用阻塞当前进程的submit方法提交另一个异步任务时，后提交的任务被放入等待队列等待线程池执行，但在Running list中的任务又在等待后任务执行的结果，这样就造成了死锁！！这个问题跟Android系统版本并没有关系，但因为Android 4.2.2版本的手机低端较多核心数较少，所以runningList的大小就比较小，Running List很容易就被填满。</p>
<p><img src="/res/deadlock/deadlock.png" alt=""></p>
<h4 id="解决方案">解决方案</h4><ol>
<li>使用非阻塞的方法提交异步任务</li>
<li>自定义线程池，重写<code>afterExecute()</code>方法，在该中获取线程池运行的异步任务运行时异常。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(11, 100, 1, TimeUnit.MINUTES, //&#10;        new ArrayBlockingQueue&#60;Runnable&#62;(10000),//&#10;        new DefaultThreadFactory()) &#123;&#10;&#10;    protected void afterExecute(Runnable r, Throwable t) &#123;&#10;        super.afterExecute(r, t);&#10;        printException(r, t);&#10;    &#125;&#10;&#125;;&#10;&#10;private static void printException(Runnable r, Throwable t) &#123;&#10;    if (t == null &#38;&#38; r instanceof Future&#60;?&#62;) &#123;&#10;        try &#123;&#10;            Future&#60;?&#62; future = (Future&#60;?&#62;) r;&#10;            if (future.isDone())&#10;                future.get();&#10;        &#125; catch (CancellationException ce) &#123;&#10;            t = ce;&#10;        &#125; catch (ExecutionException ee) &#123;&#10;            t = ee.getCause();&#10;        &#125; catch (InterruptedException ie) &#123;&#10;            Thread.currentThread().interrupt(); // ignore/reset&#10;        &#125;&#10;    &#125;&#10;    if (t != null)&#10;        log.error(t.getMessage(), t);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、参考文档">四、参考文档</h3><ol>
<li><a href="http://imxylz.com/blog/2013/08/02/handling-the-uncaught-exception-of-java-thread-pool/" target="_blank" rel="external">捕获Java线程池执行任务抛出的异常
</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;一、前言&lt;/h3&gt;&lt;p&gt;今天遇到一个很诡异的问题，在多款Android 4.2.2版本的手机上发现处理后台任务的服务对前台请求毫无响应。这里的后台服务是一个RemoteService，目的为了处理更新&amp;amp;上传等任务。本来以为是跨进程组件间通讯出现兼容性问题，后来根据分析发现问题没有那么简单，这里记录下问题原因。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="https://ivonhoe.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="多线程" scheme="https://ivonhoe.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="死锁" scheme="https://ivonhoe.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化之一刀流优化[持续更新]</title>
    <link href="https://ivonhoe.github.io/2017/05/05/android-performance-tips/"/>
    <id>https://ivonhoe.github.io/2017/05/05/android-performance-tips/</id>
    <published>2017-05-05T14:59:14.000Z</published>
    <updated>2018-05-27T08:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用windowBackground实现应用秒开">使用windowBackground实现应用秒开</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;style name=&#34;SplashTheme&#34; parent=&#34;@android:style/Theme.Black.NoTitleBar.Fullscreen&#34;&#62;&#10;    &#60;item name=&#34;android:windowBackground&#34;&#62;@drawable/bg_splash_activity&#60;/item&#62;&#10;    &#60;item name=&#34;@android:windowAnimationStyle&#34;&#62;@style/myact&#60;/item&#62;&#10;&#60;/style&#62;</span><br></pre></td></tr></table></figure>
<h3 id="使用windowBackground减少过度绘制">使用windowBackground减少过度绘制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;style name=&#34;AppMainTheme&#34; parent=&#34;@android:style/Theme.Holo.Light&#34;&#62;&#10;    &#60;item name=&#34;android:windowBackground&#34;&#62;@color/white&#60;/item&#62;&#10;    &#60;item name=&#34;android:windowNoTitle&#34;&#62;true&#60;/item&#62;&#10;    &#60;item name=&#34;@android:windowAnimationStyle&#34;&#62;@style/myact&#60;/item&#62;&#10;&#60;/style&#62;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="/res/performance-tips/overdraw.png" alt="使用windowBackground前后对比"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用windowBackground实现应用秒开&quot;&gt;使用windowBackground实现应用秒开&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#60;style name=&amp;#34;SplashTheme&amp;#34; parent=&amp;#34;@android:style/Theme.Black.NoTitleBar.Fullscreen&amp;#34;&amp;#62;&amp;#10;    &amp;#60;item name=&amp;#34;android:windowBackground&amp;#34;&amp;#62;@drawable/bg_splash_activity&amp;#60;/item&amp;#62;&amp;#10;    &amp;#60;item name=&amp;#34;@android:windowAnimationStyle&amp;#34;&amp;#62;@style/myact&amp;#60;/item&amp;#62;&amp;#10;&amp;#60;/style&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;使用windowBackground减少过度绘制&quot;&gt;使用windowBackground减少过度绘制&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#60;style name=&amp;#34;AppMainTheme&amp;#34; parent=&amp;#34;@android:style/Theme.Holo.Light&amp;#34;&amp;#62;&amp;#10;    &amp;#60;item name=&amp;#34;android:windowBackground&amp;#34;&amp;#62;@color/white&amp;#60;/item&amp;#62;&amp;#10;    &amp;#60;item name=&amp;#34;android:windowNoTitle&amp;#34;&amp;#62;true&amp;#60;/item&amp;#62;&amp;#10;    &amp;#60;item name=&amp;#34;@android:windowAnimationStyle&amp;#34;&amp;#62;@style/myact&amp;#60;/item&amp;#62;&amp;#10;&amp;#60;/style&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="性能优化" scheme="https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化之系统资源预加载的思考</title>
    <link href="https://ivonhoe.github.io/2017/04/26/Zygote-2/"/>
    <id>https://ivonhoe.github.io/2017/04/26/Zygote-2/</id>
    <published>2017-04-25T16:49:27.000Z</published>
    <updated>2018-05-27T08:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、分析一个Hello_World_App中bitmap对象的分布">一、分析一个Hello World App中bitmap对象的分布</h3><p>使用BitmapAnalyzer分析一个Android Hello World App时你会dump出400+张图片，什么是BitmapAnalyzer？BitmapAnalyzer是一个自动分析Android dump heap中bitmap对象的工具，详细请看<a href="https://ivonhoe.github.io/2017/03/22/Bitmap&amp;Memory/">《Android Bitmap的内存大小是如何计算的？》</a>这篇文章的介绍。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/695750-211010ed47103e96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hprof-3.png"></p>
<p>分析仔细看一下可以发现，上图中sPreloadedDrawables数组所引用的预加载Drawable就会占用10M以上的内存空间。这些都是Android系统的主题资源图片，为什么会有这么多主题资源被加载？不需要的无用的系统资源能否避免被加载？那么要如何做到？</p>
<a id="more"></a>
<h3 id="二、为什么有这么多系统资源被加载？">二、为什么有这么多系统资源被加载？</h3><p>使用Android Studio(简称AS)的monitor工具dump内存如上图所示，hprof中的内存信息分为三类，分别是App heap，Image heap，Zygote heap。App heap很好理解，就是应用进程独占的内存空间，在应用中创建的对象都会在App heap上。而在Dalvik虚拟机上运行的app，只有App heap和Zygote heap，并没有Image heap。<a href="https://developer.android.com/studio/profile/am-hprof.html#why" target="_blank" rel="external">Android官网文档</a>的三者的解释是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App heap - The heap used by the current app.&#10;&#10;Image heap - The memory mapped copy of the current app on disk.&#10;&#10;Zygote heap - The common set of libraries and runtime classes and data that all apps are forked from. The zygote space is created during device startup and is never allocated into.</span><br></pre></td></tr></table></figure>
<p>Zygote机制总的来说是<code>app_process</code>启动Zygote并创建第一个虚拟机进程，Zygote启动时会预加载所有需要的Java classes和”必要的”资源文件，这些资源文件就包括我们在hprof文件中看到的被sPreloadedDrawables所直接引用的Bitmap资源。应用进程都是从Zygote中fork出来的，所以所有的应用进程都会包含上面提到的资源文件。这些资源的拷贝可以看成浅拷贝，并不是真正的内存copy，而是作为进程间的共享内存使用。详细的可以查看<a href="https://ivonhoe.github.io/2017/04/25/Zygote/">《Zygote》</a>这篇文章。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/695750-8d0e4feb9a25e8b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hprof-2.png"></p>
<h3 id="三、强制清除未使用的系统资源图片会怎样？">三、强制清除未使用的系统资源图片会怎样？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void clearPreloadedDrawables() &#123;&#10;    try &#123;&#10;        Field mFieldPreloadedDrawables = getField(Resources.class, &#34;sPreloadedDrawables&#34;);&#10;        if (mFieldPreloadedDrawables != null) &#123;&#10;            mFieldPreloadedDrawables.setAccessible(true);&#10;&#10;            boolean access = mFieldPreloadedDrawables.isAccessible();&#10;            if (!access) &#123;&#10;                mFieldPreloadedDrawables.setAccessible(true);&#10;            &#125;&#10;&#10;            if (Build.VERSION.SDK_INT &#60;= 17) &#123;&#10;                LongSparseArray&#60;Drawable.ConstantState&#62; dArray = (LongSparseArray&#60;Drawable.ConstantState&#62;) mFieldPreloadedDrawables.get(getResources());&#10;                if (dArray != null) &#123;&#10;                    dArray.clear();&#10;                &#125;&#10;&#10;                // dArray.put(1, createDrawableConstant());&#10;            &#125; else if (Build.VERSION.SDK_INT &#62;= 18) &#123;&#10;                LongSparseArray&#60;Drawable.ConstantState&#62;[] dArray = (LongSparseArray&#60;Drawable.ConstantState&#62;[]) mFieldPreloadedDrawables.get(getResources());&#10;                if (dArray != null) &#123;&#10;                    for (int i = 0; i &#60; dArray.length; i++) &#123;&#10;                        if (dArray[i] != null) &#123;&#10;                            dArray[i].clear();&#10;                            // dArray[i].put(1, createDrawableConstant());&#10;                        &#125;&#10;                    &#125;&#10;                &#125;&#10;            &#125;&#10;&#10;            mFieldPreloadedDrawables.setAccessible(true);&#10;        &#125;&#10;    &#125; catch (Exception e) &#123;&#10;        e.printStackTrace();&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>当通过上述clearPreloadedDrawables函数清除sPreloadDrawable对这些资源的强引用，然后使用Android Studio的monitor工具发现，gc以后App heap发生了断崖式的内存回收，并且使用<code>adb shell dumpsys meminfo</code>命令可以发现Heap Alloc和Heap Size都发生了显著的减小，但Pss total并没有显著变化。这里的理解是PSS = Private RAM + 按比例计算的Shared RAM，这两部分都没有发生显著变化，所以PSS Total没有变化。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/695750-04d96b82a7dbce97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hprof-7.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/695750-4eebdbaf6e95eff4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hprof-5.png"></p>
<p>那请问，上面👆的内存清理有意义吗？Heap allocated较少了10M，但PSS并没有明显的变化，给我的感觉就像大家在吃大锅饭，我只吃了1碗，别人吃了10碗，付钱的时候却是AA，甚至可能我付的还更多一些。你说你是不是萨？</p>
<h3 id="四、Copy-On-Write(COW)">四、Copy-On-Write(COW)</h3><p>Zygote heap是系统共享内存heap，这里我尝试修改<code>sPreloadDrawable</code>对应数据时，如下图所示，系统默认预加载399张资源图片，当手动插入一张新的图片到缓存后，缓存大小变成了400。但让我觉得诡异的是，不是说Android系统使用COW机制吗？为啥插入前后sPreloadDrawable相关的内存地址根本没有变化？<br><img src="http://upload-images.jianshu.io/upload_images/695750-14ca03d88be43c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hprof-4.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/695750-5f0921dc8e336f51.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hprof-8.jpg"></p>
<p>我的理解是在fork子进程的时候并不会真正拷贝父进程内存数据，而是子进程的虚拟内存空间指向父进程的物理内存空间。子进程和父进程的虚拟空间不同，但物理空间是同一个。当子进程需要重写共享内存数据时，系统才会为子进程分配响应的物理内存。这里的虚拟内存空间对应用程序来说就是逻辑地址，对于CPU来说就是线性地址。</p>
<h3 id="五、总结">五、总结</h3><p>回到之前思考的几个问题：</p>
<ul>
<li><p>为什么会有这么多主题资源被加载？<br>这些主题资源是系统启动时Zygote预加载的系统资源，Zygote认为这些资源每个App都会用到，特别是5.0+的系统会达到400+的默认theme图片，占用10M+的内存空间，不过这些内存是系统共享的你用或不用他们都在那里。改变应用的主题样式并不会改变sPreloadDrawable的加载内容。</p>
</li>
<li><p>不需要的无用资源能否避免被加载？<br>这些默认系统资源无法避免被系统预加载，但是不同ROM厂商针对这些资源的看法差别还是很大的，根据测试的情况看，三星的预加载资源比源码的还要多，清空sPreloadDrawable也不能减少Heap allocte的大小。相反锤子手机对这些预加载资源的作用倒是不太看好，在锤子坚果上看到的预加载资源就很少，几乎可以忽略不计。而在Android 5.0以下的系统版本，这块预加载的资源也不是很夸张。</p>
</li>
<li><p>清空预加载资源对应用内存有无优化作用？<br>说下个人看法，如果你的应用分为UI进程和后台服务进程。在UI进程清除系统预加载资源可能并不是明智的选择，为啥？因为这是一件吃力未必讨好的事情，虽然这10M空间你并没有使用，但系统并没有领情，反而当你想要在使用系统资源的时候，那这些资源就会完全算到你的头上。那样反而会造成应用进程内存的上升。为啥？清除系统的共享内存后，再加载系统资源时分配的就是应用的私有内存了。<br>如果是后台服务进程，打死也不会用到系统主题资源的情况下，清除预加载资源为什么不是对自己有利的事情呢？因为这样做确实让Heap变小了呀！</p>
<p>当然以上都是个人的理解，如有理解错误，恳请能够指出。对于如何获取Java对象的物理地址，我还没有找到更好的办法，所以暂时还没有实践验证COW。</p>
</li>
</ul>
<p>临帖顿首，不知所言，2017.4.26日夜。</p>
<h3 id="参考">参考</h3><p><a href="https://developer.android.com/studio/profile/investigate-ram.html" target="_blank" rel="external"></a></p>
<p><a href="https://developer.android.com/studio/profile/am-hprof.html#why" target="_blank" rel="external">HPROF Viewer and Analyzer</a></p>
<p><a href="http://www.jianshu.com/p/d061fa36a0d9" target="_blank" rel="external">Manage Your App’s Memory</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/deep-android-v1/zygote.html" target="_blank" rel="external">深入理解 Zygote</a></p>
<p><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="external">Linux写时拷贝技术(copy-on-write)</a></p>
<p><a href="http://luodw.cc/2016/02/17/address/" target="_blank" rel="external">linux虚拟地址转物理地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、分析一个Hello_World_App中bitmap对象的分布&quot;&gt;一、分析一个Hello World App中bitmap对象的分布&lt;/h3&gt;&lt;p&gt;使用BitmapAnalyzer分析一个Android Hello World App时你会dump出400+张图片，什么是BitmapAnalyzer？BitmapAnalyzer是一个自动分析Android dump heap中bitmap对象的工具，详细请看&lt;a href=&quot;https://ivonhoe.github.io/2017/03/22/Bitmap&amp;amp;Memory/&quot;&gt;《Android Bitmap的内存大小是如何计算的？》&lt;/a&gt;这篇文章的介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/695750-211010ed47103e96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;hprof-3.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;分析仔细看一下可以发现，上图中sPreloadedDrawables数组所引用的预加载Drawable就会占用10M以上的内存空间。这些都是Android系统的主题资源图片，为什么会有这么多主题资源被加载？不需要的无用的系统资源能否避免被加载？那么要如何做到？&lt;/p&gt;
    
    </summary>
    
      <category term="性能优化" scheme="https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Copy-on-write" scheme="https://ivonhoe.github.io/tags/Copy-on-write/"/>
    
      <category term="Zygote" scheme="https://ivonhoe.github.io/tags/Zygote/"/>
    
      <category term="性能优化" scheme="https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化之如何写出GC友好的Android应用</title>
    <link href="https://ivonhoe.github.io/2017/04/25/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BAGC%E5%8F%8B%E5%A5%BD%E7%9A%84Android%E5%BA%94%E7%94%A8/"/>
    <id>https://ivonhoe.github.io/2017/04/25/如何写出GC友好的Android应用/</id>
    <published>2017-04-25T13:21:23.000Z</published>
    <updated>2018-05-27T08:19:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者：乐蛙科技高级研发经理 易宁</p>
<p>Android应用普遍没有iOS应用流畅，这与Android应用是运行在Java虚拟机上有很大的关系，而关系最大的恐怕就是Java虚拟机上的Garbage Collection（GC）了。Java语言提供了自动内存管理，垃圾对象会在GC过程中自动被释放。这提供了开发效率，使开发者能集中精力在业务逻辑上；但天下没有免费的午餐，你写的Android应用的某些性能上的问题很可能就是GC导致的。</p>
<p>下面是一段非常简单的Java语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span> * <span class="number">512</span> * <span class="number">4</span>];</span><br></pre></td></tr></table></figure></p>
<p>这条语句申请了一块大小相等于512*512大小图片的内存。执行这条语句会消耗多少时间呢？0+ms吗？基本没有性能影响吗？</p>
<a id="more"></a>
<p>实际的情况是：0~200ms，甚至更多！这取决于应用当前Heap使用情况。在一个类似Hello World的测试程序里，执行这条语句有时候只需要0+ms就完成了，但一般情况是16+ms，甚至有时候需要30+ms。我们知道一段流畅的动画每帧绘图消耗的时间应该小于16ms，因为这样才能保证动画有60FPS的帧率。但如果执行上面那句简单的语句就要错过1~2帧，那就难怪动画不流畅了。</p>
<p>不过，有人可能要说了：“没人会傻到在每帧绘图的时候去申请一块这么大的内存，实际情况不会有这个问题”。实际的工程中的确不会这么写，但造成执行这条语句耗时比较长的原因不是因为申请的内存太大，而是申请过程中产生了GC，就算是一个Byte的内存申请也可能消耗比这更长的时间。</p>
<h3 id="Dalvik中GC的原理">Dalvik中GC的原理</h3><p>在Dalvik虚拟机中定义了四种触发GC的条件（参看<a href="http://androidxref.com/4.2.2_r1/xref/dalvik/vm/alloc/Heap.h" target="_blank" rel="external">Heap.h</a>）：</p>
<blockquote>
<ul>
<li><code>GC_CONCURRENT</code>，当Heap的使用率达到某一阈值时自动触发。</li>
<li><code>GC_FOR_MALLOC</code>，当Heap没有足够的空间用于容下新创建的对象时。</li>
<li><code>GC_EXPLICIT</code>，用户主动调用GC时。</li>
<li><code>GC_BEFORE_OOM</code>，当要发生OOM时系统尝试进行最后GC的努力。</li>
</ul>
</blockquote>
<p><code>GC_CONCURRENT</code>和<code>GC_EXPLICIT</code>是并行的，GC过程中应用不会被暂停，只在GC开始和结束时会暂停应用，每次暂停的时间比较短，一般只有3~4ms。<code>GC_FOR_MALLOC</code>是非并行的，GC过程中应用被暂停，耗时比较长，可能几十毫秒也可能几百毫秒。在应用向Dalvik申请内存时，Dalvik先检查当前Heap中有无足够的空余空间用来安排对象，当发现没有足够的空间的时候会先进行<code>GC_FOR_MALLOC</code>以试图释放垃圾对象来获取新的空间，如果发现空间还不够则进行Heap的增长。在每次成功分配完新的空间后，Dalvik会检查当前Heap的使用情况，如果使用空间超过一定的阈值的时候，<code>GC_CONCURRENT</code>就会触发。</p>
<p>每次GC的时候会打印如下的Log信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/dalvikvm(10497): GC_CONCURRENT freed 2940K, 54% free 2885K/6204K, paused 1ms+4ms&#65292; total 38ms</span><br></pre></td></tr></table></figure>
<p>上面的Log信息表明：这次<code>GC_CONCURRENT</code>释放了2940K的空间，当前Heap使用率为54%，总的Heap大小是6204K，空余2885K，GC开始时暂停了1ms，GC结束时暂停了4ms，GC总共花了38ms。</p>
<p>Dalvik虚拟机通过下面几个个属性值来控制Heap的空间配置：</p>
<blockquote>
<ul>
<li><code>targetUtilization</code>，理想的Heap利用率，每当Heap增长时Dalvik会使增长后的Heap维持在这个利用率附近。</li>
<li><code>minFree</code>，空余空间最小值。</li>
<li><code>maxFree</code>，空余空间最大值。</li>
<li><code>startSize</code>，虚拟机启动时初始的Heap大小。</li>
<li><code>growthLimit</code>，用户设置的允许的最大Heap大小。</li>
<li><code>maximumSize</code>， Heap空间最大极限值。</li>
</ul>
</blockquote>
<p>这些属性值都可以通过<code>system/build.prop</code>来配置，zygote启动dalvik虚拟机时会从该文件中读取这些参数。通常来说，Heap空余空间越大应用越流畅，消耗的内存也更多。</p>
<p>下图为一次“顺利”的4M内存申请:<br><img src="/res/dalvik_gc/1.png" alt="Alt text"><br>可以看到在申请之前，空余的空间达到8M，申请4M的内存很顺利没有任何GC发生。</p>
<p>下图为一次“不顺利”的8M内存申请：<br><img src="/res/dalvik_gc/2.png" alt="Alt text"><br>虽然空余的空间已经有8M，但是为了保证正常的Heap利用率，Heap空间还是增长了，并且增长Heap之前进行了一次<code>GC_FOR_MALLOC</code>。</p>
<p>下图为继续申请8M的内存：<br><img src="/res/dalvik_gc/3.png" alt="Alt text"><br>相应的输出Log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/dalvikvm&#65109; GC_FOR_ALLOC freed 8195K, 34% free 16726K/24972K, paused 23ms, total 23ms</span><br></pre></td></tr></table></figure></p>
<p>上图和Log更加清晰的表明Heap空间不够时会先进行一次GC，GC的类型就是<code>GC_FOR_MALLOC</code>。</p>
<h3 id="Android流畅的关键：GC_FOR_MALLOC">Android流畅的关键：<code>GC_FOR_MALLOC</code></h3><p><code>GC_CONCURRENT</code>和<code>GC_FOR_MALLOC</code>虽然都是系统自动调用的，都暂停了应用，但它们花费的时间不在一个数量级。通过上面的分析我们知道每次申请内存空间不够时就会产生<code>GC_FOR_MALLOC</code>，我们不可能不申请内存，所以也不可能完全避免<code>GC_FOR_MALLOC</code>，但还是有些策略能降低<code>GC_FOR_MALLOC</code>的影响：</p>
<ol>
<li><p>避免不必要的<code>GC_FOR_MALLOC</code></p>
<blockquote>
<ul>
<li>Heap空间都有其理想的利用率，在理想的利用空间内，申请内存是不会发生<code>GC_FOR_MALLOC</code>。</li>
<li>应用应该避免内存开销的波动，将内存的波动维持在<code>maxFree</code>和<code>mixFree</code>之间。</li>
<li>避免大的内存需求。比如，不要轻易去用<code>WallpaperManager</code>，因为壁纸占用巨大的内存。</li>
<li>应该尽量复用对象。比如，使用<code>BitmapFactory</code>加载图片时使用<code>BitmapFactory.Option.inBitmap</code>复用Bitmap，避免申请内存。</li>
<li>对于已知有垃圾对象的情况下，先进行手动的<code>System.gc()</code>来释放空间，而不是等到系统自动调用<code>GC_FOR_MALLOC</code>。因为<code>GC_EXPLICIT</code>是异步的，暂停应用的时间远小于<code>GC_FOR_MALLOC</code>。</li>
<li>不要在循环中申请创建对象。循环中申请的对象会不断累积，直到空间不够发生<code>GC_FOR_MALLOC</code>。</li>
</ul>
</blockquote>
</li>
<li><p>减少<code>GC_FOR_MALLOC</code>的影响</p>
<blockquote>
<ul>
<li>不要在Android应用运行的关键阶段申请内存。比如，不要在<code>onDraw</code>, <code>onLayout</code>, <code>onXXX</code>中创建对象。在关键阶段创建对象可能使应用出现随机性卡顿。</li>
<li>尽量在<code>onCreate</code>和<code>onStart</code>阶段创建对象，同时在<code>onStop</code>和<code>onDestroy</code>阶段释放对象。</li>
<li>尽量复用<code>ListView</code>中Item，在<code>ListView</code>滑动时不要创建对象。</li>
</ul>
</blockquote>
</li>
<li><p>降低每次<code>GC_FOR_MALLOC</code>的时间消耗</p>
<blockquote>
<ul>
<li>避免大量的，细小的对象。这些对象会增加Heap空间的复杂度，在GC时会严重影响GC的耗时。</li>
<li>对于不用的对象近早将其引用消除，减少Heap空间占用和复杂度。</li>
<li>尽量用数据结构，数组来组织对象。</li>
<li>明确对象之间的关系，使对象之间的依赖关系简单明了。</li>
<li>减少View的数量。每个View包含大量属性，对于没有交互的View，大多数的属性都是没有用的，可以用Drawable替代。</li>
</ul>
</blockquote>
</li>
</ol>
<p><em>需要注意的是</em>：本文讨论的只限于Dalvik虚拟机。对于Art虚拟机，<a href="https://developer.android.com/guide/practices/verifying-apps-art.html#GC_Migration" target="_blank" rel="external">官方文档</a>已经表明Art虚拟机有极大的改进，其中就特别提到<strong>不用</strong>主动调用<code>System.gc()</code>来避免产生<code>GC_FOR_MALLOC</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：乐蛙科技高级研发经理 易宁&lt;/p&gt;
&lt;p&gt;Android应用普遍没有iOS应用流畅，这与Android应用是运行在Java虚拟机上有很大的关系，而关系最大的恐怕就是Java虚拟机上的Garbage Collection（GC）了。Java语言提供了自动内存管理，垃圾对象会在GC过程中自动被释放。这提供了开发效率，使开发者能集中精力在业务逻辑上；但天下没有免费的午餐，你写的Android应用的某些性能上的问题很可能就是GC导致的。&lt;/p&gt;
&lt;p&gt;下面是一段非常简单的Java语句：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] data = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;512&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;512&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这条语句申请了一块大小相等于512*512大小图片的内存。执行这条语句会消耗多少时间呢？0+ms吗？基本没有性能影响吗？&lt;/p&gt;
    
    </summary>
    
      <category term="性能优化" scheme="https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="Delvik" scheme="https://ivonhoe.github.io/tags/Delvik/"/>
    
      <category term="GC" scheme="https://ivonhoe.github.io/tags/GC/"/>
    
      <category term="性能优化" scheme="https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="转载" scheme="https://ivonhoe.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Zygote</title>
    <link href="https://ivonhoe.github.io/2017/04/15/Zygote/"/>
    <id>https://ivonhoe.github.io/2017/04/15/Zygote/</id>
    <published>2017-04-15T15:32:51.000Z</published>
    <updated>2018-05-27T08:21:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://anatomyofandroid.com/2013/10/15/zygote/" target="_blank" rel="external">Zygote https://anatomyofandroid.com/2013/10/15/zygote/</a></p>
<p>Zygote（受精卵）是一个启动应用的守护进程，在Server Manager之后被init.rc触发，但其实他是真正被app_process启动的，下面是启动这个特殊进程的流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server&#10;class main&#10;socket zygote stream 660 root system&#10;onrestart write /sys/android_power/request_state wake&#10;onrestart write /sys/power/state on&#10;onrestart restart media&#10;onrestart restart netd</span><br></pre></td></tr></table></figure>
<p>你可以发现Zygote是如何当做系统服务启动的，你也可以看到app_process为什么说app_process是启动Zygote的真正命令。就像之前说的，Zygote是一个以专门启动应用为的守护进程。这意味着Zygote是所有App进程的父进程。当app_process启动Zygote时，它通过调用Zygote的main()方法创建了第一个Dalvik虚拟机。当Zygote启动后，zygote会预加载所有必须的Java类和资源，启动System Server并打开一个名为/dev/socket/zygote的socket服务，去监听所有启动应用的请求。 想之前的文章所说，System Server 是一个和它的父进程完全分离的进程。一旦System Server创建完成，它会初始化一系列不同的System Services并启动Activity Manager。那Zygote是如何启动新的应用的呢？</p>
<a id="more"></a>
<p>Zygote 通过/dev/socket/zygote(一个sockete Socket Server)接收启动应用的请求，就会触发一次fork()调用，会在另一个存储空间创建一个自身的拷贝。这个过程是很高效的。当Zygote执行fork时，它会精准创建一个预加载了应用进程所需的所有必要类和资源的Dalvik虚拟机，这样就会把创建虚拟机和加载资源的过程变得很高效。但这个设计不仅仅是这样。由于Android运行在Linux内核上，Linux Kernal实现了一个叫做Copy On Write（COW）的策略，在fork进程的过程中并不会真正的拷贝内存。一个进程想要修改这个共享的内存是，kernel会拦截这个请求，并对要修改的内存做一个拷贝。当一些Android的类库是不可写的情况下，那就意味着所有从Zygote fork出来的进程都在共享一份系统类文件和资源。另一个好处就是真的节省内存。不管启动多少应用进程在内存的增长上都会小很多。</p>
<p>If you are in an early stage of a porting process, Zygote is another big process that you don’t need to start. You can disable it by adding the keyword “disabled” at the end of the boot sequence in init.rc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server&#10;class main&#10;socket zygote stream 660 root system&#10;onrestart write /sys/android_power/request_state wake&#10;onrestart write /sys/power/state on&#10;onrestart restart media&#10;onrestart restart netd&#10;disabled</span><br></pre></td></tr></table></figure>
<p>下面是一张说明Zygote在Android平台中作用的关系图(from Embedded Android)。</p>
<p><img src="/res/zygote/zygote-1.png" alt=""></p>
<p>zygote的main()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;&#10; try &#123;&#10;     // Start profiling the zygote initialization.&#10;     SamplingProfilerIntegration.start();&#10;&#10;    registerZygoteSocket();&#10;    EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,&#10;    SystemClock.uptimeMillis());&#10;    preload();&#10;    EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,&#10;    SystemClock.uptimeMillis());&#10;&#10;    // Finish profiling the zygote initialization.&#10;    SamplingProfilerIntegration.writeZygoteSnapshot();&#10;&#10;    // Do an initial gc to clean up after startup&#10;    gc();&#10;&#10;    // Disable tracing so that forked processes do not inherit stale tracing tags from&#10;    // Zygote.&#10;    Trace.setTracingEnabled(false);&#10;&#10;    // If requested, start system server directly from Zygote&#10;    if (argv.length != 2) &#123;&#10;        throw new RuntimeException(argv[0] + USAGE_STRING);&#10;    &#125;&#10;&#10;    if (argv[1].equals(&#34;start-system-server&#34;)) &#123;&#10;        startSystemServer();&#10;    &#125; else if (!argv[1].equals(&#34;&#34;)) &#123;&#10;        throw new RuntimeException(argv[0] + USAGE_STRING);&#10;    &#125;&#10;&#10;    Log.i(TAG, &#34;Accepting command socket connections&#34;);&#10;&#10;    runSelectLoop();&#10;&#10;    closeServerSocket();&#10; &#125; catch (MethodAndArgsCaller caller) &#123;&#10;     caller.run();&#10; &#125; catch (RuntimeException ex) &#123;&#10;     Log.e(TAG, &#34;Zygote died with exception&#34;, ex);&#10;     closeServerSocket();&#10;     throw ex;&#10; &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>通过下面代码可以看到Zygote是如何启动System Server的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * Prepare the arguments and fork for the system server process.&#10; */&#10;private static boolean startSystemServer()&#10;        throws MethodAndArgsCaller, RuntimeException &#123;&#10;    /* Hardcoded command line to start the system server */&#10;    String args[] = &#123;&#10;            &#34;--setuid=1000&#34;,&#10;            &#34;--setgid=1000&#34;,&#10;            &#34;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,3001,3002,3003,3006,3007&#34;,&#10;            &#34;--capabilities=130104352,130104352&#34;,&#10;            &#34;--runtime-init&#34;,&#10;            &#34;--nice-name=system_server&#34;,&#10;            &#34;com.android.server.SystemServer&#34;,&#10;    &#125;;&#10;    ZygoteConnection.Arguments parsedArgs = null;&#10;&#10;    int pid;&#10;&#10;    try &#123;&#10;        parsedArgs = new ZygoteConnection.Arguments(args);&#10;        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);&#10;        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);&#10;        &#10;        /* Request to fork the system server process */&#10;        pid = Zygote.forkSystemServer(&#10;                parsedArgs.uid, parsedArgs.gid,&#10;                parsedArgs.gids,&#10;                parsedArgs.debugFlags,&#10;                null,&#10;                parsedArgs.permittedCapabilities,&#10;                parsedArgs.effectiveCapabilities);&#10;    &#125; catch (IllegalArgumentException ex) &#123;&#10;        throw new RuntimeException(ex);&#10;    &#125;&#10;    &#10;    /* For child process */&#10;    if (pid == 0) &#123;&#10;        handleSystemServerProcess(parsedArgs);&#10;    &#125;&#10;&#10;    return true;&#10;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://anatomyofandroid.com/2013/10/15/zygote/&quot;&gt;Zygote https://anatomyofandroid.com/2013/10/15/zygote/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Zygote（受精卵）是一个启动应用的守护进程，在Server Manager之后被init.rc触发，但其实他是真正被app_process启动的，下面是启动这个特殊进程的流程。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server&amp;#10;class main&amp;#10;socket zygote stream 660 root system&amp;#10;onrestart write /sys/android_power/request_state wake&amp;#10;onrestart write /sys/power/state on&amp;#10;onrestart restart media&amp;#10;onrestart restart netd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以发现Zygote是如何当做系统服务启动的，你也可以看到app_process为什么说app_process是启动Zygote的真正命令。就像之前说的，Zygote是一个以专门启动应用为的守护进程。这意味着Zygote是所有App进程的父进程。当app_process启动Zygote时，它通过调用Zygote的main()方法创建了第一个Dalvik虚拟机。当Zygote启动后，zygote会预加载所有必须的Java类和资源，启动System Server并打开一个名为/dev/socket/zygote的socket服务，去监听所有启动应用的请求。 想之前的文章所说，System Server 是一个和它的父进程完全分离的进程。一旦System Server创建完成，它会初始化一系列不同的System Services并启动Activity Manager。那Zygote是如何启动新的应用的呢？&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://ivonhoe.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Zygote" scheme="https://ivonhoe.github.io/tags/Zygote/"/>
    
      <category term="翻译" scheme="https://ivonhoe.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>如何使用ddmlib dump出堆文件</title>
    <link href="https://ivonhoe.github.io/2017/04/09/how-to-dump-heap/"/>
    <id>https://ivonhoe.github.io/2017/04/09/how-to-dump-heap/</id>
    <published>2017-04-09T11:03:01.000Z</published>
    <updated>2018-05-27T08:20:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下如果我想要较详细的分析内存状况，会使用android monitor(下简称monitor)和Memory Analyzer工具(下简称MAT)，但步骤有些麻烦。</p>
<ol>
<li>使用monitor dump堆文件</li>
<li>使用hprof-conv工具，将hprof转换成MAT能够识别的格式</li>
<li>使用MAT分析</li>
</ol>
<p>需要手动dump hprof再使用hprof-conv工具手动转码，上篇<a href="https://ivonhoe.github.io/2017/03/22/Bitmap&amp;Memory/">Android Bitmap的内存大小是如何计算的？</a>说到使用square的<a href="https://github.com/square/haha" target="_blank" rel="external">haha</a>来做内存堆中Bitmap的分析。所以在思考如何一键完成内存dump和analyze的过程，当然也可以任意其他Java对象做分析。<br>如何完成dump和转码，思路还是Read the fucking source code，看下monitor是如何dump hprof文件的。打开Android sdk目录，monitor和其依赖的jar分别在<code>/tools</code>和’/tools/lib’目录，核心代码在<code>ddmlib.jar</code>中，Java swring代码在<code>ddms.jar</code>和<code>ddmuilib.jar</code>中，ddmlib需要依赖<code>common.jar</code>和<code>guava.jar</code>。</p>
<a id="more"></a>
<p><img src="/res/hprof/hprof-1.png" alt=""></p>
<h3 id="如何使用ddmlib获取adb连接的设备">如何使用ddmlib获取adb连接的设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;&#10;        IDevice device;&#10;        // &#36825;&#37324;&#38656;&#35201;&#20256;&#21442;true&#65292;&#19981;&#28982;&#24453;&#20250;&#20250;&#25343;&#19981;&#21040;&#25163;&#26426;&#19978;&#30340;client&#10;        AndroidDebugBridge.init(true);&#10;        AndroidDebugBridge bridge = AndroidDebugBridge.createBridge(&#10;                &#34;/Users/Ivonhoe/Library/Android/sdk/platform-tools/adb&#34;, false);&#10;        waitForDevice(bridge);&#10;        IDevice devices[] = bridge.getDevices();&#10;        device = devices[0];&#10;    &#125;&#10;&#10;    private static void waitForDevice(AndroidDebugBridge bridge) &#123;&#10;        int count = 0;&#10;        while (!bridge.hasInitialDeviceList()) &#123;&#10;            try &#123;&#10;                Thread.sleep(100);&#10;                count++;&#10;            &#125; catch (InterruptedException ignored) &#123;&#10;            &#125;&#10;            if (count &#62; 300) &#123;&#10;                System.err.print(&#34;Time out&#34;);&#10;                break;&#10;            &#125;&#10;        &#125;&#10;    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何dump_hprof">如何dump hprof</h3><p><strong>这里不说看ddms源码的过程了，主要还是通过关键字搜索跟一下dump操作的处理逻辑</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#35774;&#32622;HprofDumpHandler&#65292;&#23545;dump&#20107;&#20214;&#20570;&#30417;&#21548;&#22788;&#29702;dump&#25104;&#21151;&#25110;&#32773;&#22833;&#36133;&#30340;&#22238;&#35843;&#65292;&#10; * &#24182;&#20445;&#23384;hprof&#25991;&#20214;&#25968;&#25454;&#10; *&#10; * @param device&#10; */&#10;public HprofDump(Device device) &#123;&#10;    mDevice = device;&#10;&#10;    ClientData.IHprofDumpHandler hprofDumpHandler = new ClientData.IHprofDumpHandler() &#123;&#10;&#10;        @Override&#10;        public void onSuccess(String remoteFilePath, Client client) &#123;&#10;            String hprofPath = getHprofPath(client.getClientData().getClientDescription());&#10;            mDevice.pull(hprofPath, remoteFilePath);&#10;&#10;            conversionAndRemoveHprof(hprofPath);&#10;&#10;            isDumping = false;&#10;        &#125;&#10;&#10;        @Override&#10;        public void onSuccess(byte[] bytes, Client client) &#123;&#10;            String hprofPath = getHprofPath(client.getClientData().getClientDescription());&#10;            Utilities.saveFile(bytes, hprofPath);&#10;&#10;            conversionAndRemoveHprof(hprofPath);&#10;&#10;            isDumping = false;&#10;        &#125;&#10;&#10;        @Override&#10;        public void onEndFailure(Client client, String s) &#123;&#10;            isDumping = false;&#10;        &#125;&#10;    &#125;;&#10;    ClientData.setHprofDumpHandler(hprofDumpHandler);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里默认选择栈顶进程做dump操作，通过adb shell dumpsys activity top命令获取栈顶TASK的ApplicationId，通过IDevice接口的getClient方法获取Client对象，执行dumpHprof操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * dump&#26632;&#39030;&#36827;&#31243;&#30340;hprof&#10; */&#10;public void dumpTopTaskHprof() &#123;&#10;    if (isDumping) &#123;&#10;        return;&#10;    &#125;&#10;&#10;    IDevice iDevice = mDevice.getIDevice();&#10;&#10;    /**&#10;     * &#36825;&#37324;&#33258;&#21160;&#36873;&#25321;&#25163;&#26426;&#19978;&#26632;&#39030;&#36827;&#31243;&#20570;dump&#25805;&#20316;&#65292;&#33719;&#21462;applicationName&#10;     */&#10;    String topApp = getTopApplication();&#10;    Client client = iDevice.getClient(topApp);&#10;&#10;    if (client == null) &#123;&#10;        throw new RuntimeException(&#34;Can not dump app:&#34; + topApp);&#10;    &#125;&#10;    client.dumpHprof();&#10;    isDumping = true;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在IHprofDumpHandler的回调中, 保存hprof文件，做格式转换，分析Bitmap对象的状况。BitmapAnalyzer.java的代码在上文说过。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void conversionAndRemoveHprof(String hprofPath) &#123;&#10;    String convHprofPath = getConvHprofPath(hprofPath);&#10;    hprofConv(hprofPath, convHprofPath);&#10;    removeFile(hprofPath);&#10;&#10;    analyzerBitmap(convHprofPath);&#10;&#125;&#10;&#10;private void hprofConv(String hprofPath, String convHprofPath) &#123;&#10;    String adbPath = Adb.instance().getAdbPath();&#10;    String hprofConvPath = adbPath.replace(&#34;adb&#34;, &#34;hprof-conv&#34;);&#10;    ShellCommand.exec(hprofConvPath + &#34; &#34; + hprofPath + &#34; &#34; + convHprofPath);&#10;&#125;&#10;&#10;private void analyzerBitmap(String hprofPath) &#123;&#10;    String[] args = new String[2];&#10;    args[0] = hprofPath;&#10;    args[1] = &#34;bitmap&#34;;&#10;    BitmapAnalyzer.main(args);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于BitmapAnalyzer的那些发现">关于BitmapAnalyzer的那些发现</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下如果我想要较详细的分析内存状况，会使用android monitor(下简称monitor)和Memory Analyzer工具(下简称MAT)，但步骤有些麻烦。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用monitor dump堆文件&lt;/li&gt;
&lt;li&gt;使用hprof-conv工具，将hprof转换成MAT能够识别的格式&lt;/li&gt;
&lt;li&gt;使用MAT分析&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要手动dump hprof再使用hprof-conv工具手动转码，上篇&lt;a href=&quot;https://ivonhoe.github.io/2017/03/22/Bitmap&amp;amp;Memory/&quot;&gt;Android Bitmap的内存大小是如何计算的？&lt;/a&gt;说到使用square的&lt;a href=&quot;https://github.com/square/haha&quot;&gt;haha&lt;/a&gt;来做内存堆中Bitmap的分析。所以在思考如何一键完成内存dump和analyze的过程，当然也可以任意其他Java对象做分析。&lt;br&gt;如何完成dump和转码，思路还是Read the fucking source code，看下monitor是如何dump hprof文件的。打开Android sdk目录，monitor和其依赖的jar分别在&lt;code&gt;/tools&lt;/code&gt;和’/tools/lib’目录，核心代码在&lt;code&gt;ddmlib.jar&lt;/code&gt;中，Java swring代码在&lt;code&gt;ddms.jar&lt;/code&gt;和&lt;code&gt;ddmuilib.jar&lt;/code&gt;中，ddmlib需要依赖&lt;code&gt;common.jar&lt;/code&gt;和&lt;code&gt;guava.jar&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="性能优化" scheme="https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="dump heap" scheme="https://ivonhoe.github.io/tags/dump-heap/"/>
    
      <category term="内存" scheme="https://ivonhoe.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Android Bitmap的内存大小是如何计算的？</title>
    <link href="https://ivonhoe.github.io/2017/03/22/Bitmap&amp;Memory/"/>
    <id>https://ivonhoe.github.io/2017/03/22/Bitmap&amp;Memory/</id>
    <published>2017-03-22T11:35:36.000Z</published>
    <updated>2018-05-27T08:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言">一、前言</h3><p>本来只想说下Bitmap和内存的基本关系，但发现如果真的想把这看似简单的事情说清楚，实际上未必那么简单，你不信？不妨先尝试下回答下面几个问题！</p>
<ul>
<li>问1：什么是dpi？什么是dp？答：你在侮辱我？我拒绝回答！（：无辜脸</li>
<li>问2：以Nexus6为例，分辨率1440*2560，5.96英寸，ppi是什么？dpi是什么？1dp是多少像素？</li>
<li>问3：还以Nexus6为例，一张180*180的图片，放置在设置了<code>wrap_content</code>属性的ImageView中，当这张图片，分别放在<code>drawable-nodpi</code>,<code>drawable-mdpi</code>,<code>drawable-hdpi</code>, <code>drawable-xxhdpi</code>,<code>drawable-xxxhdpi</code>这几个资源目录中，在屏幕上分别显示多大(像素)的图片？</li>
<li>问4：这张图片占用的内存大小分别为多少？</li>
<li>问5：如果设置ImageView的宽和高为固定的值，如50px，那么上述情况下，加载的Bitmap占用内存大小分别为多大？</li>
</ul>
<p>本文主要围绕上述问题，介绍Android图片资源加载的基本机制，图片的内存大小如何计算，以及内存图片分析工具。</p>
<a id="more"></a>
<h3 id="二、基础概念">二、基础概念</h3><ul>
<li>px：像素(pixel)，指的是屏幕上的物理点，最小的独立显示单位</li>
<li>ppi：每英寸像素点(Pixels Per Inch)，之前我自己的理解就是使用勾股定理，通过屏幕长宽计算出对角线的长度，再除以屏幕对角线英寸值。</li>
<li>dpi：每英寸点(Dots Per Inch)，和ppi有什么区别？</li>
<li>dp：像素无关点(Density-Independent pixel)，这个Android定义的虚拟值，和px关系式是<code>px = dp * (dpi / 160)</code>，为啥？</li>
</ul>
<p><strong>ppi</strong></p>
<p>ppi指的是水平方向或者竖直方向上每英寸的像素值，先说为啥很多对ppi的理解都有问题。很多文章利用勾股定理计算手机屏幕对角线像素个数！！但是手机屏幕的像素分布是点阵分布，点阵的对角线像素点不是用勾股定理算出来的，而是等于它的行数或者列数，为啥用对角线计算？因为一般手机的尺寸说的就是对角线英寸值，而不知道长宽的英寸值。这里有个公式推导：<br>设 X/x = Y/y = ppi，这里X为水平像素值，x为水平英寸值，Y为竖直像素值，y为竖直英寸值。则(X²+Y²）/（x²+y²）=（X/x）²=（Y/y）²，这个公式可通过勾股定理和相似三角形原理证明。ppi的计算只是形式和勾股定理一样但并不是勾股定理的意思，分子也不是对角线的像素数！！ppi的计算公式可表示为：√(X²+Y²）/对角线英寸。但不意味着ppi是使用勾股定理计算对角线像素值获得的~~</p>
<p><img src="/res/bitmap/2.png" alt=""></p>
<p><a href="https://www.zhihu.com/question/21220154/answer/69672901" target="_blank" rel="external">DPI、PPI、DP、PX 的详细计算方法及算法来源是什么？fsk的回答</a></p>
<p><strong>dpi</strong></p>
<p>dpi是由ppi确定的，还是以Nexue6为例，通过ppi的计算公式，可以计算出Nexues6的ppi为<code>492</code>,参照下表，应该在xxxhdpi的范围内，但它的dpi并不是<code>492</code>。实际上dpi只有120(low)、160(medium)、240(high)、260、280、300、320(xhigh)、340、360、400、420、480（xxhpdi）、560、640（xxxhpi）这几种，可以参照<code>android.util.DisplayMetrics</code>的源码。通过<code>getResources().getDisplayMetrics().densityDpi</code>可以获取手机实际的dpi。</p>
<p><img src="/res/bitmap/dpi.png" alt=""></p>
<p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/util/DisplayMetrics.java" target="_blank" rel="external">DisplayMetrics.java源码链接</a></p>
<p><strong>dp</strong></p>
<p>1dp在Nexues6上是多少像素？<br><code>1dp * (560/160) = 3.5px</code></p>
<p><strong>如何更改手机的dpi</strong></p>
<ul>
<li>需要root的手机</li>
<li>更改/system/build.prop中的ro.sf.lcd_density属性，这个值越小，屏幕密度越高</li>
<li>adb reboot 重启手机</li>
</ul>
<p><strong>如何快速查看手机屏幕信息</strong></p>
<p><code>adb shell dumpsys display | findstr DisplayDeviceInfo</code></p>
<h3 id="三、回到问题">三、回到问题</h3><p>以Nexus6为例，一张180*180的图片，放在设置了<code>wrap_content</code>属性的ImageView中，当这张图片，分别放置在<code>drawable-nodpi</code>,<code>drawable-mdpi</code>,<code>drawable-hdpi</code>, <code>drawable-xxhdpi</code>,<code>drawable-xxxhdpi</code>这几个资源目录中，在屏幕上分别显示多大(像素)的图片？</p>
<p>答：根据上面的分析，可以看到nexus6，是属于xxxhpi的屏幕，获取到dpi为560。如果把180大小的图片只放在xxxhdpi目录中，是不是屏幕就会显示180px的大小？其实并不是，dpi=640的才是真正的xxxhdpi(这里需要看DisplayMetrics的源码)，当Android系统加载图片时，会针对当前系统的dpi和图片目录的source dpi比较做相应比例的缩放，如果一张图片放在drawable-xxxhdpi目录，这是告诉系统，针对dpi为640的手机屏幕上，这张图片是刚刚好的，它的scale为1.0，同理，drawable-xxhpi对应480dpi，drawable-xhdpi对应的是320dpi。如果希望<code>180*180</code>在nexues6的屏幕上按照原有尺寸显示，只有将其放在drawable-nodpi或者drawable-560dpi目录中才可以。</p>
<p>回到问题，如果将<code>180*180</code>放入hdpi目录中，那实际显示的图片大小应该为：<code>int (180 * (560 / 240) +0.5f ) = 420px</code>，实际图片的大小应该为420px！同理:<br>放入xhdpi目录中，实际大小应该为<code>int (180 * (560 / 320) +0.5f ) = 315px</code><br>放入xxhdpi目录中，实际大小应该为<code>int (180 * (560 / 480) +0.5f ) = 210px</code></p>
<p><a href="https://android.googlesource.com/platform/frameworks/base/+/7b2f8b8/core/jni/android/graphics/BitmapFactory.cpp" target="_blank" rel="external">BitmapFactory.cpp源码链接</a></p>
<p>如果用小的Bitmap容器，放置较大的Bitmap，那这个Bitmap的尺寸大小是按照容器的大小计算？还是按照dpi缩放的规则计算？</p>
<h3 id="四、一张图片占多大内存">四、一张图片占多大内存</h3><p>现在我们已经知道了一张图片放置在不同的资源目录中，系统decode的bitmap的尺寸大小是如何计算的了。一张图片大概占用多少内存，其实只用看一个像素占用多少内存就可以喽？我们都知道屏幕上的颜色是有R，G，B加透明度表示的，Android官方支持的RGB格式，主要是<code>ALPHA_8</code>，<code>RGB_565</code>，<code>ARGB_4444</code>，<code>ARGB_8888</code>这几种。</p>
<p>以ARGB_8888为例，表示一个像素点，使用8位表示透明度，8位表示Red，8位表示Green，8位表示Blue。加起来，一个像素就需要4byte，同理，RGB_565一个像素需要2byte。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public enum Config &#123;&#10;    ALPHA_8     (1),&#10;    RGB_565     (3),&#10;    @Deprecated&#10;    ARGB_4444   (4),&#10;    ARGB_8888   (5);&#10;    final int nativeInt;&#10;    Config(int ni) &#123;&#10;        this.nativeInt = ni;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Android decode资源图片时默认会选择ARGB_8888，如果将<code>180*180</code>放入hdpi目录中，那实际大小应该为<code>int (180 * (560 / 240) +0.5f ) = 420px</code>，像素内存大小为 <code>420 * 420 * 4 = 705600byte = 689kb</code>。同理:<br>放入xhdpi目录中，实际大小应该为<code>int (180 * (560 / 320) +0.5f ) = 315px</code>，像素内存大小为<code>315 * 315 * 4 = 396900byte = 387.6kb</code><br>放入xxhdpi目录中，实际大小应该为<code>int (180 * (560 / 480) +0.5f ) = 210px</code>，像素内存大小为<code>210 * 210 * 4 = 176400byte = 172.2kb</code></p>
<h3 id="五、如何分析内存中的图片问题？">五、如何分析内存中的图片问题？</h3><p>说了这么多，终于到了我原本想说的。Android的内存优化需要重点关注的几个方面，Bitmap的加载，Activity的泄露，webview内存等。图片的内存问题，是很多Android应用，特别是电商APP需要首要关注的问题。那如何简单的分析出内存中Bitmap的情况，这里提供一个工具。借助leakcanary的思路，通过分析内存堆dump文件中<code>android.graphics.Bitmap</code>对象的情况，<strong>将内存中Bitmap对象批量保存到图片文件中</strong>，这样就可以直观的看到内存中加载的Bitmap个数、内容和大小，进而分析可能的内存问题。</p>
<p><img src="/res/bitmap/bitmap_buffer.png" alt=""></p>
<p><img src="/res/bitmap/1.png" alt=""></p>
<p><strong>示例</strong></p>
<p>以分析蘑菇街APP内存中bitmap为例:</p>
<ul>
<li>先使用Android monitor dump hprof</li>
<li>hprof-conv做格式转换</li>
<li><code>java -jar ./bitmap-analyzer-0.0.1-SNAPSHOT.jar /Users/Ivonhoe/hprof/com.mogujie-conv.hprof 蘑菇街</code></li>
</ul>
<p><strong>参数说明</strong>：</p>
<ul>
<li>参数1：需要处理hprof文件的绝对路径</li>
<li>参数2：图片输出的文件夹名称，在hprof文件目录中创建该文件夹,缺省时直接会在hprof文件目录输出文件</li>
</ul>
<p><strong>输出说明</strong></p>
<p><img src="/res/bitmap/bitmap-analyzer.png" alt=""></p>
<ul>
<li>大小排序.txt 按照图片像素尺寸，从大到小排序</li>
<li>个数排序.txt 按照相同尺寸图片个数，从大到小排序</li>
<li>文件名 width*height_index.png</li>
</ul>
<p><strong>Jar包地址</strong></p>
<p><a href="https://raw.githubusercontent.com/Ivonhoe/mvn-repo/master/ivonhoe/java/heapanalyzer/bitmap-analyzer/0.0.1-SNAPSHOT/bitmap-analyzer-0.0.1-20170327.112600-1.jar" target="_blank" rel="external">https://raw.githubusercontent.com/Ivonhoe/mvn-repo/master/ivonhoe/java/heapanalyzer/bitmap-analyzer/0.0.1-SNAPSHOT/bitmap-analyzer-0.0.1-20170327.112600-1.jar</a></p>
<h3 id="六、参考文档">六、参考文档</h3><p><a href="http://blog.csdn.net/guolin_blog/article/details/50727753" target="_blank" rel="external">Android drawable微技巧，你所不知道的drawable的那些细节</a></p>
<p><a href="http://www.10tiao.com/html/336/201703/2652262290/1.html" target="_blank" rel="external">关于Android适配，看完这篇文章就够了</a></p>
<p><a href="http://wangjunyan.github.io/2014/12/02/export-android-bitmap-from-dump-file/" target="_blank" rel="external">批量导出dump文件中的Bitmap</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=403263974&amp;idx=1&amp;sn=b0315addbc47f3c38e65d9c633a12cd6&amp;scene=21#wechat_redirect" target="_blank" rel="external">Android 开发绕不过的坑：你的 Bitmap 究竟占多大内存？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;一、前言&lt;/h3&gt;&lt;p&gt;本来只想说下Bitmap和内存的基本关系，但发现如果真的想把这看似简单的事情说清楚，实际上未必那么简单，你不信？不妨先尝试下回答下面几个问题！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问1：什么是dpi？什么是dp？答：你在侮辱我？我拒绝回答！（：无辜脸&lt;/li&gt;
&lt;li&gt;问2：以Nexus6为例，分辨率1440*2560，5.96英寸，ppi是什么？dpi是什么？1dp是多少像素？&lt;/li&gt;
&lt;li&gt;问3：还以Nexus6为例，一张180*180的图片，放置在设置了&lt;code&gt;wrap_content&lt;/code&gt;属性的ImageView中，当这张图片，分别放在&lt;code&gt;drawable-nodpi&lt;/code&gt;,&lt;code&gt;drawable-mdpi&lt;/code&gt;,&lt;code&gt;drawable-hdpi&lt;/code&gt;, &lt;code&gt;drawable-xxhdpi&lt;/code&gt;,&lt;code&gt;drawable-xxxhdpi&lt;/code&gt;这几个资源目录中，在屏幕上分别显示多大(像素)的图片？&lt;/li&gt;
&lt;li&gt;问4：这张图片占用的内存大小分别为多少？&lt;/li&gt;
&lt;li&gt;问5：如果设置ImageView的宽和高为固定的值，如50px，那么上述情况下，加载的Bitmap占用内存大小分别为多大？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文主要围绕上述问题，介绍Android图片资源加载的基本机制，图片的内存大小如何计算，以及内存图片分析工具。&lt;/p&gt;
    
    </summary>
    
      <category term="性能优化" scheme="https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Bitmap" scheme="https://ivonhoe.github.io/tags/Bitmap/"/>
    
      <category term="Drawable" scheme="https://ivonhoe.github.io/tags/Drawable/"/>
    
      <category term="内存" scheme="https://ivonhoe.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Android安全之应用防dex2jar原理及实现</title>
    <link href="https://ivonhoe.github.io/2017/02/09/%E7%BE%8E%E5%9B%A2%E5%A6%82%E4%BD%95%E9%98%B2dex2jar/"/>
    <id>https://ivonhoe.github.io/2017/02/09/美团如何防dex2jar/</id>
    <published>2017-02-09T13:55:01.000Z</published>
    <updated>2018-05-27T08:19:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、反编译某平台代码">一、反编译某平台代码</h3><p>最近在看某外卖平台的代码，发现某外卖平台最新版本版本无法正常的通过dex2jar工具将dex转换出Java源代码，在转换过程中会提示出错，如图：</p>
<p><img src="https://ivonhoe.github.io/res/dex2jar_error/dex2jar_error1.png" alt="dex2jar异常图"></p>
<p>查看转换出的Java源代码，会发现很多类方法提示下图所示异常，很多方法中都会抛出<code>RuntimeException：can not merge I and Z</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class AsyncTaskService extends IntentService &#123; &#10;  &#10;  protected void onHandleIntent(Intent paramIntent)&#123;&#10;    throw new RuntimeException(&#34;d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat...);&#10;  &#125;&#10;  &#10;  public int onStartCommand(Intent paramIntent, int paramInt1, int paramInt2)&#123;&#10;    throw new RuntimeException(&#34;d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat...&#34;);&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>查看日志文件会发现很多类似的错误信息，可以看到方法内<code>RuntimeException</code>栈信息和反编译的错误信息是相同的，都提示<code>can not merge I and Z</code>。</p>
<p><img src="https://ivonhoe.github.io/res/dex2jar_error/dex2jar_error2.png" alt="dex2jar日志"></p>
<h3 id="二、为什么？">二、为什么？</h3><p>本来以为这是dex2jar工具低版本的一个bug，但更新了dex2jar以后，依然还是会出现上述错误。<br><code>java.lang.RuntimeException: can not merge I and Z</code>这个异常，在<a href="https://sourceforge.net/p/dex2jar/tickets/238/" target="_blank" rel="external">sourceforge</a>上解释的比较清楚，其实是一个dex2jar工具检查出的一个参数异常”，<strong>The problem is caused by strict type calculation, because in java syntaxt, a boolean can not assign to an inteager. so dex2jar forbid merge type Z and I.</strong> 你用布尔类型入参调用一个参数为整型的函数，当然会检查出错，为啥这么说，我使用apktool工具，看了一下apk的smali代码。发现报错的函数的最前面都含有一段奇怪smali的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;&#125;, Lpnf/this/object/does/not/Exist;-&#62;a()Z&#10;&#10;move-result v0&#10;&#10;invoke-static &#123;v0&#125;, Lpnf/this/object/does/not/Exist;-&#62;b(I)V</span><br></pre></td></tr></table></figure>
<p>看上面的代码，<code>pnf.this.object.does.not.Exist.a()</code>方法返回一个boolean类型数据，放入v0寄存器，作为<code>pnf.this.object.does.not.Exist.b(int)</code>函数的入参。正常情况下这样的语法错误在java代码编译时就不会通过的。看到这里你会不会想，如果我不想别人直接看到我的Java代码，是不是可以通过在核心函数中插入上面这段有语法错误的代码，以达到dex2jar工具检查出错的目的呢？从而将代码被阅读的门槛从java提高到smali。</p>
<h3 id="三、手动代码注入">三、手动代码注入</h3><p>为了验证上面的猜想，这里我通过反编译一个apk，手动插入有语法错误的smali代码，以验证防dex2jar的思路，具体步骤如下：</p>
<ul>
<li>1.反编译一个apk。</li>
<li>2.修改smali代码，插入上面这三句有语法错误的代码。</li>
<li>3.重打包，使用dex2jar工具转换新包的dex，看是否能正常转换出Java源代码。并检查运行时是否出错。</li>
</ul>
<p>我这里用一个Hello World应用来测试，使用apktool反编译出smali代码，并在Application的onCreate方法中插入这段有语法错误的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># virtual methods&#10;.method public onCreate()V&#10;    .locals 3&#10;&#10;    invoke-super &#123;p0&#125;, Lcn/trinea/android/lib/h/c;-&#62;onCreate()V&#10;&#10;    invoke-virtual &#123;p0&#125;, Lcn/trinea/android/developertools/MyApplication;-&#62;getApplicationContext()Landroid/content/Context;&#10;&#10;    move-result-object v0&#10;&#10;    invoke-static &#123;&#125;, Lpnf/object/does/not/Exist;-&#62;a()Z&#10;&#10;    move-result v3&#10;&#10;    invoke-static &#123;v3&#125;, Lpnf/object/does/not/Exist;-&#62;b(I)V&#10;&#10;    return-void&#10;.end method</span><br></pre></td></tr></table></figure>
<p>这里不要忘了，你可能需要另外编译出Exist.smali这个文件，不然运行时一定会爆出ClassNotFound异常。将下面的Exist.java<strong>编译出Exist.smali</strong>放入相应的包路径，重打包就可以了。Java代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Exist &#123;&#10;    public static boolean a() &#123;&#10;        return false;&#10;    &#125;&#10;&#10;    public static void b(int test) &#123;&#10;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>最后，验证下果然重新打包后的apk，确实不能正常转换出Java源代码，这里就不贴图了，因为转换出错日志是一样的。并且运行时也不会出错。接下来会写一个Gradle编译插件，针对特定的函数，插入代码，防止dex2jar工具查看Java源代码。</p>
<h3 id="四、实现思路">四、实现思路</h3><p>Android客户端在防止其Java代码被dex2jar转换时其实就是借助dex2jar的语法检查机制，将有语法错误的字节码插入到想要保护的Java函数中里面，以达到dex2jar转换出错的目的。接下来我就大致记录下如何开发Gradle编译插件，在编译过程中实现上述防护思路，先看下Android APK打包流程：</p>
<!--more-->
<p><img src="https://ivonhoe.github.io/res/dexguard/dexguard4.jpeg" alt="Android apk打包流程"></p>
<p>Android APK打包流程如上图所示，Java代码先通过Java Compiler生成.class文件，再通过dx工具生成dex文件，最后使用apkbuilder工具完成代码与资源文件的打包，并使用jarsigner签名，最后可能还有使用zipalign对签名后的apk做对齐处理。</p>
<p>如果需要完成对特定函数的代码注入，可以在Java代码编译生成class文件后，在dex文件生成前，针对class字节码进行操作，以本例为例需要动态生成Exsit类文件的字节码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#21160;&#24577;&#29983;&#25104;Exist.class&#10;public class Exist &#123;&#10;    public static boolean a() &#123;&#10;        return false;&#10;    &#125;&#10;&#10;    public static void b(int test) &#123;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>将下列Java代码转换成字节码插入需要保护的函数中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#25554;&#20837;&#21040;&#29305;&#23450;&#30340;Java&#20989;&#25968;&#20869;&#10;Exist.b(Exist.a());</span><br></pre></td></tr></table></figure>
<p>并将修改后的.class文件放入dex打包目录中，完成dex打包，具体流程如下图所示：</p>
<p><img src="https://ivonhoe.github.io/res/dexguard/dexguard6.png" alt=""></p>
<p>Gradle提供了叫<code>Transform</code>的API，允许三方插件在class文件转换为dex文件前操作编译好的class文件，这个API的目标就是简化class文件的自定义的操作而不用对Task进行处理，并且可以更加灵活地进行操作。详细的可以参考<a href="http://blog.csdn.net/sbsujjbcy/article/details/50839263" target="_blank" rel="external">区长的博客</a>。</p>
<h3 id="五、使用ASM操作Java字节码">五、使用ASM操作Java字节码</h3><p>ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直<br>接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。这里推荐一个IDEA插件:<code>ASM ByteCode Outline</code>。可以查看.class文件的字节码，并可以生成成ASM框架代码。安装<code>ASM Bytecode Outline</code>插件后，可以在<code>Intellij IDEA</code>-&gt;<code>Code</code>-&gt;<code>Show Bytecode Outline</code>查看类文件对应个字节码和ASM框架代码，利用ASM框架代码就可以生成相应的.class文件了。</p>
<p><img src="https://ivonhoe.github.io/res/dexguard/dexguard3.png" alt=""></p>
<p>生成Exist字节码的具体实现，生成Exist.java的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassWriter cw = new ClassWriter(0);&#10;FieldVisitor fv;&#10;MethodVisitor mv;&#10;AnnotationVisitor av0;&#10;&#10;cw.visit(51, ACC_PUBLIC + ACC_SUPER, &#34;ivonhoe/dexguard/java/Exist&#34;, null, &#34;java/lang/Object&#34;, null);&#10;&#10;cw.visitSource(&#34;Exist.java&#34;, null);&#10;&#10;mv = cw.visitMethod(ACC_PUBLIC, &#34;&#60;init&#62;&#34;, &#34;()V&#34;, null, null);&#10;mv.visitCode();&#10;Label l0 = new Label();&#10;mv.visitLabel(l0);&#10;mv.visitLineNumber(7, l0);&#10;mv.visitVarInsn(ALOAD, 0);&#10;mv.visitMethodInsn(INVOKESPECIAL, &#34;java/lang/Object&#34;, &#34;&#60;init&#62;&#34;, &#34;()V&#34;, false);&#10;mv.visitInsn(RETURN);&#10;Label l1 = new Label();&#10;mv.visitLabel(l1);&#10;mv.visitLocalVariable(&#34;this&#34;, &#34;Livonhoe/dexguard/java/Exist;&#34;, null, l0, l1, 0);&#10;mv.visitMaxs(1, 1);&#10;mv.visitEnd();</span><br></pre></td></tr></table></figure>
<p>声明一个函数名为a，返回值为boolean类型的无参函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &#34;a&#34;, &#34;()Z&#34;, null, null);&#10;mv.visitCode();&#10;l0 = new Label();&#10;mv.visitLabel(l0);&#10;mv.visitLineNumber(10, l0);&#10;mv.visitInsn(ICONST_0);&#10;mv.visitInsn(IRETURN);&#10;mv.visitMaxs(1, 0);&#10;mv.visitEnd();</span><br></pre></td></tr></table></figure>
<p>声明一个函数名为b，参数为int型，返回类型为void的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MV = CW.VISITmETHOD(acc_public + acc_static, &#34;b&#34;, &#34;(i)v&#34;, NULL, NULL);&#10;MV.VISITcODE();&#10;L0 = NEW lABEL();&#10;MV.VISITlABEL(L0);&#10;MV.VISITlINEnUMBER(14, L0);&#10;MV.VISITiNSN(return);&#10;L1 = NEW lABEL();&#10;MV.VISITlABEL(L1);&#10;MV.VISITlOCALvARIABLE(&#34;TEST&#34;, &#34;i&#34;, NULL, L0, L1, 0);&#10;MV.VISITmAXS(0, 1);&#10;MV.VISITeND();</span><br></pre></td></tr></table></figure>
<p>在指定函数内，插入<code>Exist.b(Exist.a());</code>对应的字节码的具体实现，绕过Java编译器的语法检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static class InjectClassVisitor extends ClassVisitor &#123;&#10;&#10;        private String methodName;&#10;&#10;        InjectClassVisitor(int i, ClassVisitor classVisitor, String method) &#123;&#10;            super(i, classVisitor)&#10;&#10;            this.methodName = method;&#10;        &#125;&#10;&#10;        @Override&#10;        public MethodVisitor visitMethod(int access, String name, String desc,&#10;                                         String signature, String[] exceptions) &#123;&#10;&#10;            MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);&#10;            mv = new MethodVisitor(Opcodes.ASM4, mv) &#123;&#10;&#10;                @Override&#10;                void visitCode() &#123;&#10;                    // &#22312;&#26041;&#27861;&#20307;&#24320;&#22987;&#35843;&#29992;&#26102;&#10;                    if (name.equals(methodName)) &#123;&#10;                        mv.visitMethodInsn(INVOKESTATIC, &#34;ivonhoe/dexguard/java/Exist&#34;, &#34;a&#34;, &#34;()Z&#34;, false);&#10;                        mv.visitMethodInsn(INVOKESTATIC, &#34;ivonhoe/dexguard/java/Exist&#34;, &#34;b&#34;, &#34;(I)V&#34;, false);&#10;                    &#125;&#10;                    super.visitCode()&#10;                &#125;&#10;&#10;                @Override&#10;                public void visitMaxs(int maxStack, int maxLocal) &#123;&#10;                    if (name.equals(methodName)) &#123;&#10;                        super.visitMaxs(maxStack + 1, maxLocal);&#10;                    &#125; else &#123;&#10;                        super.visitMaxs(maxStack, maxLocal);&#10;                    &#125;&#10;                &#125;&#10;            &#125;&#10;            return mv;&#10;        &#125;&#10;    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="六、总结">六、总结</h3><p>看到这里可能你会有一个疑惑，为什么有语法错误的代码，在运行时不会出错，个人理解不单单是因为bool类型在内存中是以<code>0或1</code>表示，也因为<code>int</code>和<code>bool</code>在Android虚拟机中都存储在32位寄存器中，如果使用<code>int</code>和<code>long</code>类型的参数互换，在dx阶段的编译就会报错。下面是插件源码，有兴趣的同学可以尝试一下~</p>
<h4 id="插件源码">插件源码</h4><p>详细的Gradle源码和实例可参考<a href="https://github.com/Ivonhoe/dexguard" target="_blank" rel="external">https://github.com/Ivonhoe/dexguard</a></p>
<h4 id="使用方法">使用方法</h4><ul>
<li>在root project的build.gradle中添加依赖<code>classpath &#39;ivonhoe.gradle.dexguard:dexguard-gradle:0.0.2-SNAPSHOT&#39;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;&#10;    repositories &#123;&#10;        maven &#123; url &#39;https://raw.githubusercontent.com/Ivonhoe/mvn-repo/master/&#39; &#125;&#10;        mavenCentral()&#10;    &#125;&#10;    dependencies &#123;&#10;        classpath &#39;com.android.tools.build:gradle:2.3.0&#39;&#10;        classpath &#39;ivonhoe.gradle.dexguard:dexguard-gradle:0.0.2-SNAPSHOT&#39;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在app项目的build.gradle中添加插件，map.txt中配置需要保护的方法名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;ivonhoe.dexguard&#39;&#10;dexguard &#123;&#10;    guardConfig = &#34;$&#123;rootDir&#125;/map.txt&#34;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="七、参考文档">七、参考文档</h3><ul>
<li><a href="https://sourceforge.net/p/dex2jar/tickets/238/" target="_blank" rel="external">#238 java.lang.RuntimeException: can not merge I and Z</a></li>
<li><a href="http://www.jianshu.com/p/730c6e3e21f6" target="_blank" rel="external">Smali语法</a></li>
<li><a href="http://blog.csdn.net/sbsujjbcy/article/details/50839263" target="_blank" rel="external">Android 热修复使用Gradle Plugin1.5改造Nuwa插件</a></li>
<li><a href="http://www.wangyuwei.me/2017/01/20/ASM-%E6%93%8D%E4%BD%9C%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%9D%E6%8E%A2/" target="_blank" rel="external">ASM-操作字节码初探</a></li>
<li><a href="https://www.diycode.cc/topics/581" target="_blank" rel="external">手摸手增加字节码往方法体内插代码</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、反编译某平台代码&quot;&gt;一、反编译某平台代码&lt;/h3&gt;&lt;p&gt;最近在看某外卖平台的代码，发现某外卖平台最新版本版本无法正常的通过dex2jar工具将dex转换出Java源代码，在转换过程中会提示出错，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ivonhoe.github.io/res/dex2jar_error/dex2jar_error1.png&quot; alt=&quot;dex2jar异常图&quot;&gt;&lt;/p&gt;
&lt;p&gt;查看转换出的Java源代码，会发现很多类方法提示下图所示异常，很多方法中都会抛出&lt;code&gt;RuntimeException：can not merge I and Z&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class AsyncTaskService extends IntentService &amp;#123; &amp;#10;  &amp;#10;  protected void onHandleIntent(Intent paramIntent)&amp;#123;&amp;#10;    throw new RuntimeException(&amp;#34;d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat...);&amp;#10;  &amp;#125;&amp;#10;  &amp;#10;  public int onStartCommand(Intent paramIntent, int paramInt1, int paramInt2)&amp;#123;&amp;#10;    throw new RuntimeException(&amp;#34;d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat...&amp;#34;);&amp;#10;  &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="移动安全" scheme="https://ivonhoe.github.io/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Gradle" scheme="https://ivonhoe.github.io/tags/Gradle/"/>
    
      <category term="dex2jar" scheme="https://ivonhoe.github.io/tags/dex2jar/"/>
    
      <category term="移动安全" scheme="https://ivonhoe.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android安全之APP去广告</title>
    <link href="https://ivonhoe.github.io/2017/02/04/Android%E5%AE%89%E5%85%A8%E4%B9%8B---APP%E5%8E%BB%E5%B9%BF%E5%91%8A/"/>
    <id>https://ivonhoe.github.io/2017/02/04/Android安全之---APP去广告/</id>
    <published>2017-02-04T05:27:20.000Z</published>
    <updated>2018-05-27T08:20:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、工具介绍">一、工具介绍</h3><ul>
<li><strong>apktool：</strong>google提供Android apk编译与反编译工具，<a href="https://ibotpeaches.github.io/Apktool/" target="_blank" rel="external">https://ibotpeaches.github.io/Apktool/</a></li>
<li><strong>dex2jar：</strong>dex文件转jar文件工具，<a href="https://github.com/pxb1988/dex2jar" target="_blank" rel="external">https://github.com/pxb1988/dex2jar</a></li>
<li><strong>jd-gui：</strong>查看jar文件，<a href="http://jd.benow.ca/" target="_blank" rel="external">http://jd.benow.ca/</a></li>
<li><strong>keytool：</strong>制作和管理数字证书</li>
<li><strong>jarsigner：</strong>使用数字证书对jar和apk进行签名</li>
<li><strong>Android killer：</strong>Window系统中，上述工具的集成工具</li>
</ul>
<p>更多反编译工具可查看：<a href="http://unclechen.github.io/2016/09/07/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" target="_blank" rel="external">Uncle Chen—Android反编译技术总结</a></p>
<h3 id="二、去除应用开发助手的广告">二、去除应用开发助手的广告</h3><p>CodeKK公众号在17年初推出了一个<a href="https://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=2654472664&amp;idx=1&amp;sn=dfc2b5beb90daa8fd068d8064ce0dcce&amp;chksm=803bfaecb74c73fa9a9addfd4d8bce031186c34b7d7b59ee22df41799c7eaa71a34863890f56&amp;mpshare=1&amp;scene=1&amp;srcid=0220tEQNaL7PwIgfBT8sIITK&amp;key=776fc8cdd0b88c0d0b9a6c8e271e4cfe2b2363aeda110198d4250b0a422befd0f43f78e2a17d528112f757336e136c56f488bc174baa56c116045a9bdbb37dbccf508eb8c70e48a2d09ca1da1b4d92d3&amp;ascene=0&amp;uin=MTMzNzYxMDM2MQ%3D%3D&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.12.1+build(16B2555" target="_blank" rel="external">应用开发助手</a>)。V1.0版本是有广告版本的，下面以这个版本为例，简单看下去广告过程。它的后续的V1.1.0和V1.2.0已经去除了广告功能。</p>
<a id="more"></a>
<h4 id="2-1、反编译">2.1、反编译</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool.sh d -f ./dev-tools.apk</span><br></pre></td></tr></table></figure>
<p><img src="/res/dev-tool/dev-tool1.png" alt=""><br><img src="/res/dev-tool/dev-tool2.png" alt=""></p>
<h4 id="2-2、注释广告代码">2.2、注释广告代码</h4><p>这里可以先用dex2jar转jar后查看下源码，会发现使用的是Google AdMob作为广告平台，简单看下代码可以发现在主页面activty_main.xml中包含广告视图的布局文件。所以只需要找到<code>ad_layout.xml</code>将其<code>android:visibility=&quot;gone&quot;</code>属性设置成<code>gone</code>就可以了。</p>
<p><img src="/res/dev-tool/dev-tool3.png" alt=""></p>
<h4 id="2-3、重打包">2.3、重打包</h4><p>这里重打包的过程可能会遇到一些错误，不过认真查看日志并结合Google都是可以找到解决方案的，这里暂且不表。使用apktool b命令，生成的apk默认路径为<code>/dist</code>路径下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool.sh b ./dev-tools</span><br></pre></td></tr></table></figure>
<p><img src="/res/dev-tool/dev-tool4.png" alt=""></p>
<h4 id="2-4、制作一个名为hackapk-keystore的证书,并重新签名应用">2.4、制作一个名为hackapk.keystore的证书,并重新签名应用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#21046;&#20316;&#35777;&#20070;&#65306;&#10;keytool -genkey -keystore hackapk.keystore -keyalg RSA -validity 10000 -alias hackapk&#10;&#10;&#31614;&#21517;&#65306;&#10;jarsigner -verbose -keystore hackapk.keystore -signedjar dev-tools-no-ads.apk ./dev-tools/dist/dev-tools.apk hackapk</span><br></pre></td></tr></table></figure>
<p><img src="/res/dev-tool/dev-tool5.png" alt=""></p>
<p>详细的参数可以参考：<br><a href="http://www.tttabc.com/android/keytool-keystore-jarsigner-apk.htm" target="_blank" rel="external">APK签名之keytool生成keystore和jarsigner签名apk</a></p>
<h4 id="2-5、安装">2.5、安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install -r dev-tools-no-ads.apk</span><br></pre></td></tr></table></figure>
<p><img src="/res/dev-tool/dev-tool6.png" alt=""></p>
<p><img src="/res/dev-tool/dev-tool11.png" alt="有广告版本"></p>
<p><img src="/res/dev-tool/dev-tool10.png" alt="无广告版本"></p>
<h4 id="2-6、下载去广告版本的应用开发助手">2.6、下载去广告版本的应用开发助手</h4><p><img src="/res/dev-tool/dev-tool7.png" alt=""></p>
<h3 id="三、反编译脚本">三、反编译脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh&#10;workDir=./&#10;if [ &#34;$2&#34; ]&#10;then&#10;         mkdir $2&#10;         workDir=./$2/&#10;fi&#10;&#10;echo $workDir&#10;name=`basename $1 .apk`&#10;zipPath=$workDir$name.zip&#10;&#10;##apkTool&#21453;&#32534;&#35793;&#10;smaliDir=$workDir$name@smali&#10;apktool.sh d -f $1 -o $smaliDir&#10;&#10;## &#35299;&#21387;&#32553;&#65292;&#20351;&#29992;dex2jar&#22788;&#29702;&#10;unzipDir=$workDir$name@unzip&#10;cp $1 $zipPath&#10;unzip $zipPath -d $unzipDir&#10;&#10;d2j-dex2jar.sh -f $unzipDir/classes.dex -o $&#123;workDir&#125;dex2jar.jar&#10;d2j-dex2jar.sh -f $unzipDir/classes2.dex -o $&#123;workDir&#125;dex2jar2.jar&#10;d2j-dex2jar.sh -f $unzipDir/classes3.dex -o $&#123;workDir&#125;dex2jar3.jar&#10;open $workDir</span><br></pre></td></tr></table></figure>
<p>将上述内容保存到本地<code>hack.sh</code>文件中，使用下面的命令就会把apktool和dex2jar的结果输出到<code>meipu</code>这个目录中，这样就不需要每次收到敲命令喽，只要知道需要反编译的apk和输出的文件夹名称就可以~</p>
<p><code>./hack.sh ./美铺_1487845975713.apk meipu</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、工具介绍&quot;&gt;一、工具介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;apktool：&lt;/strong&gt;google提供Android apk编译与反编译工具，&lt;a href=&quot;https://ibotpeaches.github.io/Apktool/&quot;&gt;https://ibotpeaches.github.io/Apktool/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dex2jar：&lt;/strong&gt;dex文件转jar文件工具，&lt;a href=&quot;https://github.com/pxb1988/dex2jar&quot;&gt;https://github.com/pxb1988/dex2jar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;jd-gui：&lt;/strong&gt;查看jar文件，&lt;a href=&quot;http://jd.benow.ca/&quot;&gt;http://jd.benow.ca/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;keytool：&lt;/strong&gt;制作和管理数字证书&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;jarsigner：&lt;/strong&gt;使用数字证书对jar和apk进行签名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Android killer：&lt;/strong&gt;Window系统中，上述工具的集成工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多反编译工具可查看：&lt;a href=&quot;http://unclechen.github.io/2016/09/07/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/&quot;&gt;Uncle Chen—Android反编译技术总结&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、去除应用开发助手的广告&quot;&gt;二、去除应用开发助手的广告&lt;/h3&gt;&lt;p&gt;CodeKK公众号在17年初推出了一个&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;amp;mid=2654472664&amp;amp;idx=1&amp;amp;sn=dfc2b5beb90daa8fd068d8064ce0dcce&amp;amp;chksm=803bfaecb74c73fa9a9addfd4d8bce031186c34b7d7b59ee22df41799c7eaa71a34863890f56&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0220tEQNaL7PwIgfBT8sIITK&amp;amp;key=776fc8cdd0b88c0d0b9a6c8e271e4cfe2b2363aeda110198d4250b0a422befd0f43f78e2a17d528112f757336e136c56f488bc174baa56c116045a9bdbb37dbccf508eb8c70e48a2d09ca1da1b4d92d3&amp;amp;ascene=0&amp;amp;uin=MTMzNzYxMDM2MQ%3D%3D&amp;amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.12.1+build(16B2555&quot;&gt;应用开发助手&lt;/a&gt;)。V1.0版本是有广告版本的，下面以这个版本为例，简单看下去广告过程。它的后续的V1.1.0和V1.2.0已经去除了广告功能。&lt;/p&gt;
    
    </summary>
    
      <category term="移动安全" scheme="https://ivonhoe.github.io/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="去广告" scheme="https://ivonhoe.github.io/tags/%E5%8E%BB%E5%B9%BF%E5%91%8A/"/>
    
      <category term="移动安全" scheme="https://ivonhoe.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS上编译Android源码</title>
    <link href="https://ivonhoe.github.io/2017/01/20/MacOS%E4%B8%8A%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81/"/>
    <id>https://ivonhoe.github.io/2017/01/20/MacOS上编译Android源码/</id>
    <published>2017-01-20T14:16:46.000Z</published>
    <updated>2018-05-27T08:24:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、制作一个大小写敏感的磁盘分区">一、制作一个大小写敏感的磁盘分区</h3><h4 id="1-1-Mac_OS磁盘工具">1.1.Mac OS磁盘工具</h4><p>这里我使用一块移动硬盘，将移动硬盘的一个分区使用Mac OS的硬盘工具，抹掉数据，选择MacOS扩展(区分大小写，日志式)，创建成大小写敏感的分区。</p>
<p><img src="/res/compile_android_source/android-source-disk1.jpeg" alt=""></p>
<p>这里会遇到一个问题，抹掉分区数据的时候，<code>会报错：“Mac OSX 抹盘发生错误:Mediakit 报告设备上空间不足以执行此操作”</code>，这里的原因是磁盘没有大于200M的UEFI分区。</p>
<a id="more"></a>
<h4 id="1-2-制作UEFI分区">1.2.制作UEFI分区</h4><blockquote>
<p>我是在windows上操作的，<br>使用DiskGenius工具，在移动硬盘的第一分区前部，划分出200MB的空间。<br>在cmd命令行下运行下列命令,记得分步执行啊，小心出错，数据无价。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskpart&#10;list disk&#10;select disk 1 ###&#36825;&#37324;&#36873;&#20013;&#35201;&#20998;&#21306;&#30340;&#30913;&#30424;&#65292;&#22240;&#20026;&#25105;&#26159;&#31227;&#21160;&#30828;&#30424;&#65292;index&#26159;1&#65292;&#36825;&#37324;&#24212;&#35813;&#20250;&#30475;&#21040;&#36873;&#25321;&#20809;&#26631;&#19981;&#35201;&#36873;&#38169;&#20102;&#10;&#10;create partition efi size=200</span><br></pre></td></tr></table></figure>
<p>详细的图文请参考:</p>
<p><a href="https://blog.zzzmode.com/2016/05/02/osx-mediakit-reports-partition-map-too-small/" target="_blank" rel="external">Mac OSX 抹盘发生错误:Mediakit 报告设备上空间不足以执行此操作的解决办法
</a></p>
<h3 id="二、下载Android源码">二、下载Android源码</h3><h4 id="2-1-repo_sync_出错">2.1.repo sync 出错</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: RPC failed; result=56, HTTP code = 200&#60;br&#62;&#10;fatal: The remote end hung up unexpectedly&#60;br&#62;&#10;fatal: early EOF&#60;br&#62;&#10;fatal: index-pack failed</span><br></pre></td></tr></table></figure>
<p>repo sync时会出现如上错误，安装<code>gnutls</code>和<code>wget</code>后,<br>并参考<a href="http://stackoverflow.com/questions/6842687/the-remote-end-hung-up-unexpectedly-while-git-cloning" target="_blank" rel="external">stackoverflow</a>解决。</p>
<h4 id="2-2-如何选择驱动">2.2.如何选择驱动</h4><p><a href="https://source.android.com/source/build-numbers.html#source-code-tags-and-builds" target="_blank" rel="external">Source Code Tags and Builds</a></p>
<p><img src="/res/compile_android_source/android-source2.jpeg" alt=""></p>
<p><a href="https://developers.google.com/android/drivers" target="_blank" rel="external">Android原生设备驱动</a><br><img src="/res/compile_android_source/android-source3.jpeg" alt=""></p>
<p>详细的图文请参考:</p>
<p><a href="http://wl9739.github.io/2016/05/09/Android%E6%BA%90%E7%A0%81%E7%9A%84%E4%B8%8B%E8%BD%BD%E3%80%81%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AF%BC%E5%85%A5%E5%88%B0Android-Studio/" target="_blank" rel="external">Android源码的下载、编译与导入到Android Studio</a></p>
<p><a href="http://www.jianshu.com/p/1c3d47b2031f" target="_blank" rel="external">Mac OS X下编译Android M源码</a></p>
<h3 id="三、编译">三、编译</h3><p><code>一定要下载并安装驱动，下载nexus5 6.0.1_r17版本为例，需要下载执行下图三个sh</code></p>
<p><img src="/res/compile_android_source/android-source4.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$chmod a+x ./*****.sh&#10;$./*****.sh&#10;&#10;&#36755;&#20837;I ACCEPT&#23436;&#25104;&#23433;&#35013;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$source build/envsetup.sh&#10;&#10;$lunch&#10;&#10;$make -j16</span><br></pre></td></tr></table></figure>
<h3 id="四、如何将编译好的Android_img刷入模拟器">四、如何将编译好的Android img刷入模拟器</h3><p>需要设置<code>ANDROID_PRODUCT_OUT</code>变量到<code>~/.bash_profile</code>文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Android &#28304;&#30721;&#32534;&#35793;&#30446;&#24405;&#10;export PATH=$PATH:/Volumes/AOSP/android-6.0.1_r17-x86_64/out/host/darwin-x86/bin&#10;export ANDROID_PRODUCT_OUT=/Volumes/AOSP/android-6.0.1_r17-x86_64/out/target/product/generic_x86_64&#10;export PATH=$PATH:$ANDROID_PRODUCT_OUT</span><br></pre></td></tr></table></figure>
<p>使用命令启动emulator，加载指定的kernel内核和img</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kans-MacBook-Pro:android-6.0.1_r17-x86_64 Ivonhoe$&#10;emulator -kernel  /Volumes/AOSP/android-6.0.1_r17-x86_64/prebuilts/qemu-kernel/x86_64/kernel-qemu -sysdir ./out/target/product/generic_x86_64/ -system /Volumes/AOSP/android-6.0.1_r17-x86_64/out/target/product/generic_x86_64/system.img -data /Volumes/AOSP/android-6.0.1_r17-x86_64/out/target/product/generic_x86_64/userdata.img -ramdisk /Volumes/AOSP/android-6.0.1_r17-x86_64/out/target/product/generic_x86_64/ramdisk.img</span><br></pre></td></tr></table></figure>
<p>参考老罗的博客<a href="http://blog.csdn.net/luoshengyang/article/details/6559955" target="_blank" rel="external">在Ubuntu上下载、编译和安装Android最新源代码</a></p>
<h3 id="五、刷入Nexus6真机">五、刷入Nexus6真机</h3><p>Nexus6关机状态下,长按音量下+电源,进入recovery模式</p>
<p>然后在源码根目录下(Android根目录下)执行下面命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot -w flashall</span><br></pre></td></tr></table></figure>
<p><img src="/res/compile_android_source/android-source5.png" alt=""></p>
<p>使用<code>mmm framework/base</code>单独编译framework代码</p>
<p>adb push可能会提示 <code>Read-only file system</code></p>
<p><code>failed to copy &#39;out/target/product/shamu/system/framework/framework.jar&#39;
 to &#39;/system/framework/framework.jar&#39;: Read-only file system</code></p>
<p>通过下列命令解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb root&#10;adb remount&#10;adb disable-verity&#10;adb reboot&#10;adb root&#10;adb remount</span><br></pre></td></tr></table></figure>
<h3 id="六、参考文档">六、参考文档</h3><p><a href="http://blog.csdn.net/ljphhj/article/details/51512263" target="_blank" rel="external">Android系统源码下载与编译、刷机–Nexus6实测</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、制作一个大小写敏感的磁盘分区&quot;&gt;一、制作一个大小写敏感的磁盘分区&lt;/h3&gt;&lt;h4 id=&quot;1-1-Mac_OS磁盘工具&quot;&gt;1.1.Mac OS磁盘工具&lt;/h4&gt;&lt;p&gt;这里我使用一块移动硬盘，将移动硬盘的一个分区使用Mac OS的硬盘工具，抹掉数据，选择MacOS扩展(区分大小写，日志式)，创建成大小写敏感的分区。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/res/compile_android_source/android-source-disk1.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里会遇到一个问题，抹掉分区数据的时候，&lt;code&gt;会报错：“Mac OSX 抹盘发生错误:Mediakit 报告设备上空间不足以执行此操作”&lt;/code&gt;，这里的原因是磁盘没有大于200M的UEFI分区。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="https://ivonhoe.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="源码编译" scheme="https://ivonhoe.github.io/tags/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Mac/Linux下gcc编译动态链接库[.so文件]</title>
    <link href="https://ivonhoe.github.io/2016/12/16/Mac-Linux%E4%B8%8Bgcc%E7%BC%96%E8%AF%91%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93-so%E6%96%87%E4%BB%B6/"/>
    <id>https://ivonhoe.github.io/2016/12/16/Mac-Linux下gcc编译动态链接库-so文件/</id>
    <published>2016-12-16T05:47:55.000Z</published>
    <updated>2018-05-27T08:24:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、以bsdiff-c和bspatch-c为例编译bsdiff-so">一、以bsdiff.c和bspatch.c为例编译bsdiff.so</h2><p>bsdiff.c和bspatch.c分别依赖bzip2</p>
<h3 id="项目结构">项目结构</h3><h3 id="步骤">步骤</h3><ul>
<li><p>使用BsDiff.java生成BsDiff.class文件</p>
<p><strong>javac</strong> ivonhoe/spring/wrcenter/jni/BsDiff.java</p>
</li>
<li><p>生成BsDiff.h文件</p>
<p><strong>javah</strong> ivonhoe.spring.wrcenter.jni.BsDiff </p>
</li>
<li><p>生成bspatch.o</p>
<a id="more"></a>
<p><strong>gcc -fPIC -D_REENTRANT</strong> -I<strong>JAVA_INCLUDE1</strong> -I/JAVA_INCLUDE2/ -I/Users/Ivonhoe/Downloads/VelocityDemo/src/main/java/jni/bzip2 -I/Users/Ivonhoe/Downloads/VelocityDemo/src/main/java/jni -c ./jni/bspatch.c</p>
</li>
<li><p>生成bsdiff.o</p>
<p><strong>gcc -fPIC -D_REENTRANT</strong> -I/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/include/darwin -I/Users/Ivonhoe/Downloads/VelocityDemo/src/main/java/jni/bzip2 -I/Users/Ivonhoe/Downloads/VelocityDemo/src/main/java/jni -c ./jni/bsdiff.c</p>
</li>
<li><p>将bzip2下的c文件生成相应的.o文件</p>
<p><strong>gcc -fPIC -D_REENTRANT</strong> -I/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/include/darwin -I/Users/Ivonhoe/Downloads/VelocityDemo/src/main/java/jni/bzip2 -c ./jni/bzip2/*.c</p>
</li>
<li><p>生成so文件</p>
<p><strong>gcc *.o -o bsdiff.so -shared  -v</strong></p>
</li>
</ul>
<ul>
<li>注:</li>
</ul>
<p>  JAVA_INCLUDE1:/usr/local/java/jdk1.7.0_40/include<br>  JAVA_INCLUDE2:/usr/local/java/jdk1.7.0_40/include/linux<br>  是 jdk 中的 jni.h 文件的所在目录，这两个目录需要大家替换为自己的对应路径</p>
<p>  BZIP2_INCLUDE:</p>
<p>参考文档：<br><a href="http://www.cppblog.com/deane/articles/165216.html" target="_blank" rel="external">http://www.cppblog.com/deane/articles/165216.html</a><br><a href="http://blog.csdn.net/hongquan1991/article/details/12426615" target="_blank" rel="external">http://blog.csdn.net/hongquan1991/article/details/12426615</a><br><a href="http://codepub.cn/2015/05/19/How-to-load-dll-file-in-Java-Web-Project/" target="_blank" rel="external">http://codepub.cn/2015/05/19/How-to-load-dll-file-in-Java-Web-Project/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、以bsdiff-c和bspatch-c为例编译bsdiff-so&quot;&gt;一、以bsdiff.c和bspatch.c为例编译bsdiff.so&lt;/h2&gt;&lt;p&gt;bsdiff.c和bspatch.c分别依赖bzip2&lt;/p&gt;
&lt;h3 id=&quot;项目结构&quot;&gt;项目结构&lt;/h3&gt;&lt;h3 id=&quot;步骤&quot;&gt;步骤&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用BsDiff.java生成BsDiff.class文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;javac&lt;/strong&gt; ivonhoe/spring/wrcenter/jni/BsDiff.java&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成BsDiff.h文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;javah&lt;/strong&gt; ivonhoe.spring.wrcenter.jni.BsDiff &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成bspatch.o&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="https://ivonhoe.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="动态链接库" scheme="https://ivonhoe.github.io/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Android动画总结之有赞、邮箱大师进度条实现原理</title>
    <link href="https://ivonhoe.github.io/2015/09/01/Android%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%E4%B9%8B%E6%9C%89%E8%B5%9E%E3%80%81%E9%82%AE%E7%AE%B1%E5%A4%A7%E5%B8%88%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://ivonhoe.github.io/2015/09/01/Android动画总结之有赞、邮箱大师进度条实现原理/</id>
    <published>2015-09-01T15:17:29.000Z</published>
    <updated>2018-05-27T08:23:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、效果">一、效果</h2><p><img src="/res/android_animation2/xiaoguo.gif" alt=" "></p>
<h2 id="二、有赞加载进度条">二、有赞加载进度条</h2><p>四个正方形的运动可以分解成两个分运动，一个是平移运动，一个是自身的旋转运动。在实现这个动画上有两个思路：</p>
<ul>
<li>一个是通过Android提供的Animation或者Animator操作视图，让一个正方形的视图在translate动画的同时进行rotate动画，只需要设置rotate动画的pivot坐标为视图的中心点就可以了。</li>
<li>另一个是直接在canvas上绘制正方形，通过canvas的坐标变换实现动画。</li>
</ul>
<a id="more"></a>
<p>下面主要说第二种方式的原理：</p>
<ul>
<li><p>平移：平移canvas，在平行与手机屏幕的平面坐标系中，水平向右方向为X轴，竖直向下方向为Y轴，把原点平移到视图的中心点，只需要在水平和竖直的正方向平移就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.translate(mBounds.width() / 2, mBounds.height() / 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>旋转：想要完成一个矩形围绕其中心点顺时针旋转一个角度，首先要意识到旋转的过程中，只改变了坐标系的方向并没有改变坐标系的原点位置。换句话说，如果你需要围绕坐标系原点做旋转，那么你只需要旋转操作，如果你需要围绕除了原点以外的另外一个点（比如当前现在正方形的中心点），那么你需要先做平移操作，先把坐标系平移到一个正确的点在做旋转操作。如图所示：<br><img src="/res/android_animation2/xuanzhuanzuobiao.png" alt=" "></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.translate((float) (x + (1 - 1.414f * Math.sin((45 - degree) / 180f * Math.PI)) * halfLength),(float) (y - (1.414f * Math.cos((45 - degree) / 180f * Math.PI) - 1) * halfLength));&#10;canvas.rotate(degree);&#10;drawable.draw(canvas);</span><br></pre></td></tr></table></figure>
<ul>
<li>动画插值：可以看到，每个正方形的平移运动周期是从起始点回到起始点，在时间的中点上达到平移的最大值。反应在平面坐标中的情况就是，一条通过(0, 0), (0.5, 1),(1, 0)三点，在(0.5, 1)达到最大值的一元二次方程。可以间接得到这个插值器是：<br><img src="/res/android_animation2/chazhiqi.jpg" alt=" "></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#36807;&#65288;0,0&#65289;&#65292;&#65288;0.5,1&#65289;&#65292;&#65288;1,0&#65289;&#30340;&#19968;&#20803;&#20108;&#27425;&#26041;&#31243;&#10;Interpolator mInterpolator = new Interpolator() &#123;&#10;    @Override&#10;    public float getInterpolation(float input) &#123;&#10;        return -4 * input * input + 4 * input;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三、网易邮箱大师加载进度条">三、网易邮箱大师加载进度条</h2><p>圆弧的动画需要分解成四个分动画：</p>
<ul>
<li>画笔宽度变化：绘制圆弧的画笔宽度在动画</li>
<li>圆弧长度变化：绘制圆弧的长度在动画</li>
<li>旋转变化：绘制每段圆弧的起点在动画</li>
<li>圆弧半径变化：绘制圆弧的半径在动画</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ObjectAnimator[] getAtomAnimator(Atom atom, Rect bound) &#123;&#10;    ObjectAnimator[] result = new ObjectAnimator[4];&#10;    result[0] = ObjectAnimator.ofFloat(atom, &#34;delta&#34;, 4f, 9f);&#10;    result[0].setInterpolator(mPaintInterpolator);&#10;    switch (atom.getId()) &#123;&#10;        case 0:&#10;            result[1] = ObjectAnimator.ofInt(atom, &#34;rotate&#34;, 0, 360);&#10;            break;&#10;        case 1:&#10;            result[1] = ObjectAnimator.ofInt(atom, &#34;rotate&#34;, 120, 480);&#10;            break;&#10;        case 2:&#10;            result[1] = ObjectAnimator.ofInt(atom, &#34;rotate&#34;, 240, 600);&#10;            break;&#10;        default:&#10;            throw new RuntimeException();&#10;    &#125;&#10;    result[1].setInterpolator(mRotateInterpolator);&#10;    result[2] = ObjectAnimator.ofFloat(atom, &#34;length&#34;, 80f, 59f);&#10;    result[2].setInterpolator(mPaintInterpolator);&#10;    result[3] = ObjectAnimator.ofFloat(atom, &#34;r&#34;, 0, mScaleFactor * getIntrinsicWidth());&#10;    result[3].setInterpolator(mPaintInterpolator);&#10;    return result;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、Canvas图形变换原理">四、Canvas图形变换原理</h2><h3 id="2-1、平移">2.1、平移</h3><p>设图形上点P(x, y)，在x轴和y轴方向分别移动Tx和Ty，结果生成新的点P’(x’, y’)，则:<br> <img src="/res/android_animation2/pingy0.png" alt=" "></p>
<p>用矩阵形式可表示为:<br><img src="/res/android_animation2/pingyi.png" alt=" "><br>平移变换矩阵为：<br><img src="/res/android_animation2/pingyi2.png" alt=" "><br><img src="/res/android_animation2/pingyimatrix_副本.png" alt=" "></p>
<h3 id="2-2、缩放">2.2、缩放</h3><p>设图形上的点P(x, y)在x轴和y轴方向分别作Sx倍和Sy倍的缩放，结果生成新的点坐标P’(x’, y’)，则:<br><img src="/res/android_animation2/suofang.png" alt=" "><br>用矩阵表示为：<br><img src="/res/android_animation2/suofang2.png" alt=" "><br>比例变换矩阵为：<br><img src="/res/android_animation2/suofang 3.png" alt=" "><br><img src="/res/android_animation2/suofangMatrix_副本.png" alt=" "></p>
<h3 id="2-3、旋转">2.3、旋转</h3><p>设点P(x, y)绕原点旋转变换θ角度(假设按逆时针旋转为正角)，生成的新的点坐标P’(x’, y’)，则：<br><img src="/res/android_animation2/xuanzhuan1.png" alt=" "><br>用矩阵表示为：<br><img src="/res/android_animation2/xuanzhuan2.png" alt=" "><br>旋转变换矩阵为：<br><img src="/res/android_animation2/xuanzhuan3.png" alt=" "><br><img src="/res/android_animation2/xuanzhuanMatrix_副本.png" alt=" "></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、效果&quot;&gt;一、效果&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/res/android_animation2/xiaoguo.gif&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、有赞加载进度条&quot;&gt;二、有赞加载进度条&lt;/h2&gt;&lt;p&gt;四个正方形的运动可以分解成两个分运动，一个是平移运动，一个是自身的旋转运动。在实现这个动画上有两个思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是通过Android提供的Animation或者Animator操作视图，让一个正方形的视图在translate动画的同时进行rotate动画，只需要设置rotate动画的pivot坐标为视图的中心点就可以了。&lt;/li&gt;
&lt;li&gt;另一个是直接在canvas上绘制正方形，通过canvas的坐标变换实现动画。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="其他" scheme="https://ivonhoe.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="动画" scheme="https://ivonhoe.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="进度条" scheme="https://ivonhoe.github.io/tags/%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据解析工具</title>
    <link href="https://ivonhoe.github.io/2015/08/19/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <id>https://ivonhoe.github.io/2015/08/19/数据解析工具设计文档/</id>
    <published>2015-08-19T13:49:49.000Z</published>
    <updated>2018-05-27T08:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、设计目标">一、设计目标</h2><ul>
<li>设计一个相对通用的数据解析工具，高效解析通过抓包工具抓取的网络数据内容</li>
<li>只需要添加少量代码，实现不同数据格式的解析，并支持不同文件格式保存</li>
</ul>
<h2 id="二、实施步骤">二、实施步骤</h2><p>总的来说，就是使用MonkeyRunner自动测试脚本对手机进行某一些具体的操作时，通过Fiddler工具截取手机App的Http通讯数据，通过对这些数据进行解析从而达到获取应用数据的过程。</p>
<h3 id="2-1、编写MonkeyRunner自动脚本">2.1、编写MonkeyRunner自动脚本</h3><ul>
<li>环境和工具：Python，Android SDK开发环境， Android手机一台（debug选项连接PC）</li>
<li>脚本目标：循环对手机屏幕进行上划操作</li>
<li>代码：<a id="more"></a>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8&#10;from com.android.monkeyrunner import MonkeyRunner,MonkeyDevice,MonkeyImage&#10;device = MonkeyRunner.waitForConnection(5,&#39;351BBJHUHDPU&#39;)&#10;sleepTime = 0.2&#10;for x in xrange(1,10000):&#10;&#9;MonkeyRunner.sleep(sleepTime)&#10;&#9;device.drag((436,1234),(378,346),1,10)</span><br></pre></td></tr></table></figure>
<ul>
<li>注：MonkeyRunner.waitForConnection方法参数为adb devices 下的手机设备名</li>
</ul>
<h3 id="2-2、抓取应用流量信息">2.2、抓取应用流量信息</h3><ul>
<li>下载并安装需要抓取数据的Android应用</li>
<li>Google搜索获得<a href="http://jingyan.baidu.com/article/fd8044faebfaa85030137a72.html" target="_blank" rel="external">Android手机设置代理上网</a>方法，并成功设置手机通过PC代理上网功能</li>
<li>安装Fiddler，通过设置Fiddler host过滤可以获取固定host的HTTP Request和Response</li>
<li>使用MonkeyRunner测试脚本，循环触发手机上划操作，自动浏览手机应用商店的应用分类界面，通过Fiddler抓取手机的HTTP请求和响应消息内容，并导出</li>
</ul>
<h3 id="2-3、数据解析实现">2.3、数据解析实现</h3><h4 id="2-3-1、数据处理流程">2.3.1、数据处理流程</h4><p><img src="/res/parser/liuchentu.png" alt="Alt text"></p>
<h4 id="2-3-2、使用生产者消费者模式处理数据">2.3.2、使用生产者消费者模式处理数据</h4><p>生产者线程读取源数据文件，生产出待解析的字符串数据放入数据池中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10;  * &#29983;&#20135;&#32773;&#30340;&#29983;&#20135;&#23481;&#22120;&#10;  */&#10;private LinkedList&#60;Object&#62; mProductPool = new LinkedList&#60;Object&#62;();&#10;&#10;private void addProduct(List&#60;Object&#62; data) &#123;&#10;    while (!data.isEmpty()) &#123;&#10;        synchronized (mProductPool) &#123;&#10;             while (mProductPool.size() &#62;= MAX_SIZE) &#123;&#10;                try &#123;&#10;                    mProductPool.wait();&#10;                &#125; catch (InterruptedException e) &#123;&#10;                    e.printStackTrace();&#10;                &#125;&#10;            &#125;&#10;&#10;        getDataProducer().startProduce();&#10;&#10;        for (int i = 0; i &#60; Math.min(MAX_SIZE, data.size()) &#38;&#38;&#10;                mProductPool.size() &#60; MAX_SIZE; i++) &#123;&#10;                if (!data.isEmpty()) &#123;&#10;                    mProductPool.add(data.get(0));&#10;                    data.remove(0);&#10;                &#125;&#10;            &#125;&#10;            mProductPool.notifyAll();&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>多个消费者线程每次从数据池中获取一定数量的数据内容用来解析，并把解析结果放入最终的处理结果池中。这里并没有使用二级的消费者去做数据保存操作，因为可能需要把所有数据解析完成后做统一的分类、统计、筛选操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10;  * &#28040;&#36153;&#32773;&#22788;&#29702;&#25968;&#25454;&#21518;&#30340;&#23481;&#22120;&#10;  */&#10;private List&#60;Unit&#62; mConsumedPool = new ArrayList&#60;Unit&#62;()&#65307;&#10;&#10;public class Consumer implements Runnable &#123;&#10;&#10;    @Override&#10;    public void run() &#123;&#10;        while (true) &#123;&#10;            List&#60;Object&#62; queue = mEngine.getProductPool();&#10;            if (queue == null) &#123;&#10;                return;&#10;            &#125;&#10;&#10;            List&#60;Object&#62; temp = new ArrayList&#60;Object&#62;();&#10;            synchronized (queue) &#123;&#10;                while (queue.size() == 0 &#38;&#38; !mEngine.isProduceComplete()) &#123;&#10;                    try &#123;&#10;                        queue.wait();&#10;                    &#125; catch (InterruptedException e) &#123;&#10;                        e.printStackTrace();&#10;                        queue.notify();&#10;                    &#125;&#10;                &#125;&#10;&#10;                int size = queue.size();&#10;                int k = Math.max(0, size - NUM_PER_CONSUME);&#10;                for (int i = size - 1; i &#62;= k; i--) &#123;&#10;                    temp.add(queue.get(i));&#10;                    queue.remove(i);&#10;                &#125;&#10;&#10;                queue.notifyAll();&#10;            &#125;&#10;&#10;            for (Object str : temp) &#123;&#10;                ArrayList&#60;Unit&#62; result = onParse((String) str);&#10;                if (result != null) &#123;&#10;                    mEngine.addParsedUnit(result);&#10;                &#125;&#10;            &#125;&#10;&#10;            if (mEngine.isProduceComplete() &#38;&#38; queue.isEmpty()) &#123;&#10;                complete(this);&#10;                Thread t = Thread.currentThread();&#10;                t.interrupt();&#10;                return;&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>Engine.java作为整个解析过程的引擎，不同的数据需要不同的解析实现和保存格式实现,使用Reader读取数据的数据，将读取的数据填充到数据池中，当池满时，Reader线程阻塞当池空时，解析线程阻塞。在数据全部读取并解析完成之后，通过IWriter将结果保存到文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Engine implements IParser.ParseListener &#123;&#10;    // &#25351;&#23450;&#35299;&#26512;&#30340;&#25968;&#25454;&#36335;&#24452;&#10;    public void setSourcePath(String path) &#123;&#125;&#10;    // &#35774;&#32622;Reader&#10;    public void setReader(IReader reader) &#123;&#125;&#10;    // &#35774;&#32622;&#35299;&#26512;&#22120;&#10;    public void setParser(IParser parser) &#123;&#125;&#10;    // &#35774;&#32622;Writer&#10;    public void setWriter(IWriter writer) &#123;&#125;&#10;    // &#35299;&#26512;&#22120;&#35299;&#26512;&#23436;&#25104;&#30340;&#22238;&#35843;&#10;    public void onParseComplete() &#123;&#125;&#10;    // &#21551;&#21160;&#65292;&#24320;&#22987;&#22788;&#29702;&#25968;&#25454;&#10;    public void start()&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、针对第三方应用商店分类数据的解析">三、针对第三方应用商店分类数据的解析</h2><h3 id="2-1、定义不同类型的解析器">2.1、定义不同类型的解析器</h3><p>在分析第三方商店数据的过程中发现，每个应用市场都会选择性的屏蔽竞品信息的行为，例如除非通过搜索功能，你很难在360应用商店看到直接百度的应用。淘宝应用商店的屏蔽行为相对较少，但是会刻意提高一些推广应用的下载排名。很难在应用商店中抓取完全的应用信息，可能需要解析一些自己手动收集的应用分类信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#20570;&#20855;&#20307;&#38024;&#23545;&#28120;&#23453;&#25968;&#25454;&#30340;JSON&#23383;&#31526;&#20018;&#36827;&#34892;&#25968;&#25454;&#35299;&#26512;&#10;public class TBParser extends IParser &#123;&#10;    @Override&#10;    public ArrayList&#60;Unit&#62; onParse(String source) &#123;&#10;    &#125;&#10;&#125;&#10;//&#20570;&#20855;&#20307;&#38024;&#23545;360&#30340;JSON&#23383;&#31526;&#20018;&#36827;&#34892;&#25968;&#25454;&#35299;&#26512;&#10;public class QHParser extends IParser &#123;&#10;    @Override&#10;    public ArrayList&#60;Unit&#62; onParse(String source) &#123;&#10;    &#125;&#10;&#125;&#10;// &#38024;&#23545;&#33258;&#24049;&#23450;&#20041;&#30340;&#25968;&#25454;&#36827;&#34892;&#35299;&#26512;&#10;public class CustomParser extends IParser &#123;&#10;    @Override&#10;    public ArrayList&#60;Unit&#62; onParse(String source) &#123;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2、Zip压缩和Huffman编码数据压缩的比较">2.2、Zip压缩和Huffman编码数据压缩的比较</h3><p>针对ZIP压缩，java提供了标准的接口<br>针对Huffman编码压缩文本的原理，可以参照<a href="http://coolshell.cn/articles/7459.html" target="_blank" rel="external">这里</a>,具体实现在工程代码在：com.ivonhoe.parser.huffman.HuffmanCode.java的实现<br>比较发现针对字符的压缩，直接ZIP压缩比先Huffman压缩后ZIP压缩的压缩比率高。</p>
<h3 id="2-3、保存文本格式">2.3、保存文本格式</h3><p>保存的数据文件包含两个部分</p>
<ul>
<li>第一部分表示各种分类数据的条目数量<br>{健康运动:81}<br>{通讯社交:326}<br>{生活休闲:485}<br>……</li>
<li>第二部分表示所有的包名，按照文件开始部分的分类顺序和条目数依次保存<br>com.hk515.patient<br>com.guokr.zhixing<br>com.yidian.health<br>……</li>
<li>如上所示，健康运动应用数量81个，分别是第二部分的1~81条目，通讯社交应用有326个，分别是第二部分的82~408条目，依次类推。</li>
</ul>
<h2 id="四、针对京东商品评论数据的解析">四、针对京东商品评论数据的解析</h2><p>针对京东的评论数据信息，通过继承IParser的接口实现具体针对京东数据的解析方式。<br>针对解析数据的保存，通过继承IWriter的保存接口，实现针对Excel文件格式的保存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**&#10; * &#38024;&#23545;JD&#30340;&#35780;&#35770;&#25968;&#25454;&#35299;&#26512;&#10; *&#10; * @author ivonhoe&#10; */&#10;public class JDWebParser extends IParser &#123;&#10;    @Override&#10;    public ArrayList&#60;Unit&#62; onParse(String source) &#123;&#10;    &#125;&#10;&#125;&#10;&#10;**&#10; * &#36890;&#36807;&#25509;&#21475;&#20445;&#23384;&#21040;Excel&#34920;&#26684;&#20013;&#10; *&#10; * @author ivonhoe&#10; */&#10;public class JDCommentWriter extends ExlWriter &#123;&#10;    @Override&#10;    public void onWrite(List&#60;Unit&#62; list) &#123;&#10;        // TODO Auto-generated method stub&#10;        exportToSheet(&#34;comments&#34;, TITLE_STRINGS, list);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="五、总结">五、总结</h2><ul>
<li>在python部分，在实现上只需要通过简单的循环让手机屏幕不停的滑动就可以了。针对移动端数据传输的特点，绝大多数的客户端应用和服务器数据传输的格式都是通过JSON或者XML。你不再需要想办法在爬取网站页面的基础上进行数据收集，不再需要考虑如何从繁杂的网页上筛选你想要的正文。通过抓包分析的方式，这就像一个漏斗，你不需要再去筛选数据。你拿到的都是格式化的数据了。</li>
<li>如果能够集合一些更智能的自动化测试工具如百度的MTC测试工具，录制一些特殊的操作脚本，那应该可以做更多的事情。</li>
<li>如果针对复杂的业务需求，可以增加二级的消费者针对数据进行进一步的处理。</li>
<li>针对应用分类数据的筛选，因为不同数据源的信息（如下载量）也并不是完全可信的。还需要做进一步的筛选。目前的做法是根据不同数据源进行加权平均取排名的方式（测试效果并不好），或者根据数据源的并集和应用下载量的排名综合筛选，应该可以有更好的方式。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、设计目标&quot;&gt;一、设计目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;设计一个相对通用的数据解析工具，高效解析通过抓包工具抓取的网络数据内容&lt;/li&gt;
&lt;li&gt;只需要添加少量代码，实现不同数据格式的解析，并支持不同文件格式保存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;二、实施步骤&quot;&gt;二、实施步骤&lt;/h2&gt;&lt;p&gt;总的来说，就是使用MonkeyRunner自动测试脚本对手机进行某一些具体的操作时，通过Fiddler工具截取手机App的Http通讯数据，通过对这些数据进行解析从而达到获取应用数据的过程。&lt;/p&gt;
&lt;h3 id=&quot;2-1、编写MonkeyRunner自动脚本&quot;&gt;2.1、编写MonkeyRunner自动脚本&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;环境和工具：Python，Android SDK开发环境， Android手机一台（debug选项连接PC）&lt;/li&gt;
&lt;li&gt;脚本目标：循环对手机屏幕进行上划操作&lt;/li&gt;
&lt;li&gt;代码：
    
    </summary>
    
      <category term="其他" scheme="https://ivonhoe.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="数据解析" scheme="https://ivonhoe.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="生产者消费者模式" scheme="https://ivonhoe.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Drawable,从简化布局谈起</title>
    <link href="https://ivonhoe.github.io/2015/04/28/Drawable-%E4%BB%8E%E7%AE%80%E5%8C%96%E5%B8%83%E5%B1%80%E8%B0%88%E8%B5%B7/"/>
    <id>https://ivonhoe.github.io/2015/04/28/Drawable-从简化布局谈起/</id>
    <published>2015-04-28T15:31:29.000Z</published>
    <updated>2018-05-27T08:23:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Drawble是干嘛的？">一、Drawble是干嘛的？</h2><p>说到Drawable肯定会第一时间想到图片资源，可能有人会认为Drawable就是图片。Drawble从字面上说就是“可绘制的”，google文档的描述:“A Drawable is a general abstraction for “something that can be drawn.””，Drawable其实就是为那些”可以被绘制的’’提供的抽象类。</p>
<ul>
<li><strong>哪些东西是”can be drawn”？</strong></li>
<li><strong>绘制在哪里的？</strong></li>
</ul>
<p>看下android原生的Drawable和Canvas提供了的绘图的接口：<a href="http://developer.android.com/reference/android/graphics/drawable/package-summary.html" target="_blank" rel="external">android.graphics.drawable</a><br><a href="http://developer.android.com/reference/android/graphics/Canvas.html" target="_blank" rel="external">android.graphics.Canvas</a>。Canvas提供了一系列的接口去实现绘制想要的图形、图片、颜色或者其他something，Drawable就是为了这些”something”提供的。</p>
<a id="more"></a>
<h2 id="二、如何自定义Drawable？如何简化布局？">二、如何自定义Drawable？如何简化布局？</h2><p><img src="/res/drawable/1.jpg" alt="Canvas和布局实现"></p>
<p>相信一定见过类似这样的布局，在Android系统中如何把想要的图形绘制处理，一般有两种方式：</p>
<ul>
<li>把你想要的视图简单的定义到布局文件中，系统读取布局文件绘制视图</li>
<li>把想要的图形通过canvas的绘图接口直接进行绘制<br>在第二种方式中，你需要通过比如Drawable，比如自定义的View的onDraw()方法，或者调用Canvas的draw…()方法，而View的方式实际上也是Canvas绘制的方式，View也可以看做是对Canvas绘图接口的包装。而直接绘制到Canvas上的方式也单单是这些，在主线程上你可以通过调用View的invalidate()方法触发绘制，在onDraw()方法处理绘图的回调。另一种非主线程绘制的方式就是SurfaceView了。</li>
</ul>
<p>通过Drawable绘制想要的图形是个不错的选择，Drawable是一个抽象类，draw()方法提供了绘制的Canvas，invalidateSelf()方法提供了重绘的可能。Drawable的抽象方法分别是：</p>
<ul>
<li><p><strong>draw(Canvas canvas)</strong>将想要的东西绘制到这个canvas对象上</p>
</li>
<li><p><strong>setAlpha(int alpha)</strong> 为drawable指定一个alpha值，0代表全透明，255代表全不透明。</p>
</li>
<li><p><strong>setColorFilter(ColorFilter cf)</strong> 为drawable指定一个颜色过滤器</p>
</li>
<li><p><strong>getOpacity()</strong> 获取透明度</p>
</li>
</ul>
<p>实现自定义的Drawable只需要继承Drawable.java，并且在draw方法里通过canvas绘制需要的图形就可以了，听起来很简单。无论是一组图片、一条曲线还是一个色块，所有你想要的图形都可通过canvas参数绘制上去。举个例子，如何使用Drawable简化上图所示的网格布局？假设你需要在网格布局里显示不同的图片，就可以把场景微信朋友群组的图标。当然你可以使用view布局来做，当然也可以使用canvas方式。根据Drawable添加的顺序依次确定每个图片的坐标位置，在draw()方法里根据每个图片的坐标位置和图片显示位置绘制到canvas上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Override&#10;public void draw(Canvas canvas) &#123;&#10;    final int N = Math.min(mChildDrawable.size(), mRowCount * mColumnCount);&#10;    for (int i = 0; i &#60; N; i++) &#123;&#10;        ChildDrawable itemToDraw = mChildDrawable.get(i);&#10;        Drawable drawable = itemToDraw.mDrawable;&#10;        if (drawable != null) &#123;&#10;            itemToDraw.mDrawable.setBounds(itemToDraw.mInsetL, itemToDraw.mInsetT, itemToDraw.mInsetR, itemToDraw.mInsetB);&#10;            drawable.draw(canvas);&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、让Drawable动起来怎么样？">三、让Drawable动起来怎么样？</h2><ul>
<li><strong>首先看下Drawable的Canvas从哪里来</strong></li>
</ul>
<p>一般使用ImageView显示drawable，看下ImageView的onDraw(Canvas canvas)，可以看到Drawable在ImageView里的绘制发生在View的onDraw回调里，根据scaleType和padding确定绘制的方式和位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void onDraw(Canvas canvas) &#123;&#10;    super.onDraw(canvas);&#10;    ....&#10;&#10;    // mDrawMatrix&#26681;&#25454;ImageView&#30340;ScaleType&#26469;&#30830;&#23450;&#30340;&#10;    if (mDrawMatrix == null &#38;&#38; mPaddingTop == 0 &#38;&#38; mPaddingLeft == 0) &#123;&#10;        mDrawable.draw(canvas);&#10;    &#125; else &#123;&#10;        ......&#10;        mDrawable.draw(canvas);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>View绘制Background Drawable在draw(Canvas canvas)方法，并在setBackgroundDrawable时会执行background.setCallback(this)操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Step 1, draw the background, if needed&#10;if (background != null) &#123;&#10;     ......&#10;     if ((scrollX | scrollY) == 0) &#123;&#10;         background.draw(canvas);&#10;     &#125; else &#123;&#10;         ......&#10;         background.draw(canvas);&#10;         ......&#10;     &#125;&#10; &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>再看Drawable如何重绘</strong>，<br>Drawable是依赖Canvas绘制的，查看Drawable源码发现调用invalidateSelf()方法需要获取Callback，在Callback是空的情况下无法重绘Drawable。那么在View里如何实现Drawable的重绘，显然需要先设置Drawable的重绘回调，View.java实现了Drawable.Callback接口，在View里调用setImageDrawable()方法里会首先设置当前View为Drawable的回调。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void invalidateSelf() &#123;&#10;    final Callback callback = getCallback();&#10;    if (callback != null) &#123;&#10;        callback.invalidateDrawable(this);&#10;    &#125;&#10;&#125;&#10;&#10;public static interface Callback &#123;&#10;    public void invalidateDrawable(Drawable who);&#10;    public void scheduleDrawable(Drawable who, Runnable what, long when);&#10;    public void unscheduleDrawable(Drawable who, Runnable what);&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>ImageView调用invalidate触发重绘，回调ImageView的onDraw()方法，完成Drawable的重绘。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Override&#10;public void invalidateDrawable(Drawable dr) &#123;&#10;    if (dr == mDrawable) &#123;&#10;        /* we invalidate the whole view in this case because it&#39;s very&#10;         * hard to know where the drawable actually is. This is made&#10;         * complicated because of the offsets and transformations that&#10;         * can be applied. In theory we could get the drawable&#39;s bounds&#10;         * and run them through the transformation and offsets, but this&#10;         * is probably not worth the effort.&#10;         */&#10;        invalidate();&#10;    &#125; else &#123;&#10;        super.invalidateDrawable(dr);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>了解了Drawable绘制的画布和重绘的方法，如何实现动画的Drawable只需要按时重绘Drawable就可以了，用动画控制重绘效果。具体实现可以看<a href="https://github.com/Ivonhoe/FancyDrawable" target="_blank" rel="external">https://github.com/Ivonhoe/FancyDrawable</a>，现在看如何实现我在<a href="https://ivonhoe.github.io/2015/04/17/%E5%9F%BA%E4%BA%8E%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E7%9A%84Android%E5%8A%A8%E7%94%BB%E5%B7%AE%E5%80%BC%E5%99%A8/">贝赛尔插值器</a>里说过的BallsLine进度条效果，只需要在每次重绘的回调里动态的控制每个小球点的位置就可以了，需要的动画插值器参数可以参考<a href="http://thecodeplayer.com/walkthrough/windows-phone-loading-animation" target="_blank" rel="external">Web代码</a>。</p>
<p><img src="/res/drawable/2.jpg" alt="动态Drawable和GridDrawable"></p>
<pre><code><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> FRAME_DURATION = <span class="number">1000</span> / <span class="number">60</span>;

<span class="keyword">protected</span> Runnable mUpdater = <span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        onFrame();

        scheduleSelf(mUpdater, SystemClock.uptimeMillis() + FRAME_DURATION);
        invalidateSelf();
    }
};

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (!isRunning()) {
        mIsRunning = <span class="keyword">true</span>;

        <span class="comment">// start</span>
        onStart();
        scheduleSelf(mUpdater, SystemClock.uptimeMillis() + FRAME_DURATION);
        invalidateSelf();
    }
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (isRunning()) {
        mIsRunning = <span class="keyword">false</span>;
        unscheduleSelf(mUpdater);

        <span class="comment">//stop</span>
        onStop();
    }
}
</code></pre><h1 id="五、参考文档">五、参考文档</h1><p><a href="http://developer.android.com/reference/android/graphics/drawable/Drawable.html" target="_blank" rel="external">http://developer.android.com/reference/android/graphics/drawable/Drawable.html</a></p>
<p><a href="http://developer.android.com/guide/topics/graphics/2d-graphics.html" target="_blank" rel="external">http://developer.android.com/guide/topics/graphics/2d-graphics.html</a></p>
<p><a href="http://wiresareobsolete.com/2012/12/textdrawable-draw-some-text/" target="_blank" rel="external">http://wiresareobsolete.com/2012/12/textdrawable-draw-some-text/</a></p>
<p><a href="http://cyrilmottier.com/2012/11/27/actionbar-on-the-move/" target="_blank" rel="external">http://cyrilmottier.com/2012/11/27/actionbar-on-the-move/</a></p>
<p><a href="http://antoine-merle.com/blog/2013/11/12/make-your-progressbar-more-smooth/" target="_blank" rel="external">http://antoine-merle.com/blog/2013/11/12/make-your-progressbar-more-smooth/</a></p>
<h2 id="六、Github">六、Github</h2><p><a href="https://github.com/Ivonhoe/FancyDrawable" target="_blank" rel="external">https://github.com/Ivonhoe/FancyDrawable</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Drawble是干嘛的？&quot;&gt;一、Drawble是干嘛的？&lt;/h2&gt;&lt;p&gt;说到Drawable肯定会第一时间想到图片资源，可能有人会认为Drawable就是图片。Drawble从字面上说就是“可绘制的”，google文档的描述:“A Drawable is a general abstraction for “something that can be drawn.””，Drawable其实就是为那些”可以被绘制的’’提供的抽象类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;哪些东西是”can be drawn”？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绘制在哪里的？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看下android原生的Drawable和Canvas提供了的绘图的接口：&lt;a href=&quot;http://developer.android.com/reference/android/graphics/drawable/package-summary.html&quot;&gt;android.graphics.drawable&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://developer.android.com/reference/android/graphics/Canvas.html&quot;&gt;android.graphics.Canvas&lt;/a&gt;。Canvas提供了一系列的接口去实现绘制想要的图形、图片、颜色或者其他something，Drawable就是为了这些”something”提供的。&lt;/p&gt;
    
    </summary>
    
      <category term="性能优化" scheme="https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="Drawable" scheme="https://ivonhoe.github.io/tags/Drawable/"/>
    
      <category term="性能优化" scheme="https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
