<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>病已的博客</title>
  <icon>https://www.gravatar.com/avatar/67e58323dd67029db2c4cf9876795431</icon>
  <subtitle>枕上，马上，厕上</subtitle>
  <link href="https://ivonhoe.github.io/atom.xml" rel="self"/>
  
  <link href="https://ivonhoe.github.io/"/>
  <updated>2022-08-22T11:49:58.037Z</updated>
  <id>https://ivonhoe.github.io/</id>
  
  <author>
    <name>病已</name>
    <email>yangfan3687@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用位运算进行状态管理</title>
    <link href="https://ivonhoe.github.io/2022/08/22/bit-operation-status-management/"/>
    <id>https://ivonhoe.github.io/2022/08/22/bit-operation-status-management/</id>
    <published>2022-08-22T11:47:40.000Z</published>
    <updated>2022-08-22T11:49:58.037Z</updated>
    
    <content type="html"><![CDATA[<p>在稍微复杂的项目中，经常会遇到需要对当前业务场景进行状态判断的需求，并且这里的状态可能是多种状态组合的方式，可能只一种状态，也可能是多种状态共存。这里就可以借助位运算来解决，用一个整型数值上不同二进制位上的0、1数值来表示不同的状态。这样做既可以避免使用多个状态flag时重复if else逻辑判断，也有利于并发场景下状态更新和判断。在很多时候可以起到事半功倍的效果。这里就简单介绍如何进行状态设计和状态判断。</p><span id="more"></span><p>以淘宝app为例，可以看到在淘宝逛逛页面中，同时存在「关注」、「发现」、「视频」三个子tab，而在「发现」页面，同时存在「全部」、「玩乐」、「文创」、「家居」、「汽车」等子类目。当然在淘宝的实际业务中这些子类目应该是根据营销投放的数据接口动态配置类目名称和相关数据的，未必会有多状态管理的实际场景。这里只是以该页面结构作为演示，现在假设一种业务场景，需要判断是否是在「发现」-&gt;「玩乐」，如果是那就进行xxxx操作。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/411436/1660792442661-9c6ce85f-4d59-4bd9-9051-fa8f883ebdd9.jpeg#clientId=uc197c86f-a7ac-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=634&id=u05c4b4b3&margin=%5Bobject%20Object%5D&name=IMG_4889F4572496-1.jpeg&originHeight=2532&originWidth=1170&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2037118&status=done&style=none&taskId=u9c1540c0-f3ac-4413-aab0-2ce4aef4b50&title=&width=293" alt="IMG_4889F4572496-1.jpeg"><br>代码应该如何设计？这里推荐借助位运算，在同一个状态值上标记不同状态位的方式来进行状态管理。<br><strong>1. 通过 &lt;&lt; 定义数据的状态</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static final int CONST_TAB = 0x00000001;</span><br><span class="line">static final int CONST_FILTER = 0x000100;</span><br><span class="line">// 关注</span><br><span class="line">static final int TAB_FOLLOW = CONST_TAB &lt;&lt; 0;</span><br><span class="line">// 发现</span><br><span class="line">static final int TAB_DISCOVER = CONST_TAB &lt;&lt; 1;</span><br><span class="line">// 视频</span><br><span class="line">static final int TAB_VIDEO = CONST_TAB &lt;&lt; 2;</span><br><span class="line">// 2-全部</span><br><span class="line">static final int MODEL_ALL = CONST_FILTER &lt;&lt; 1;</span><br><span class="line">// 2-玩乐</span><br><span class="line">static final int MODEL_PLAY = CONST_FILTER &lt;&lt; 2;</span><br><span class="line">// 2-文创</span><br><span class="line">static final int MODEL_CULTURAL = CONST_FILTER &lt;&lt; 3;</span><br><span class="line">// 2-家居</span><br><span class="line">static final int MODEL_HOME = CONST_FILTER &lt;&lt; 4;</span><br><span class="line">// 2-汽车</span><br><span class="line">static final int MODEL_CAR = CONST_FILTER &lt;&lt; 5;</span><br></pre></td></tr></table></figure><h4 id="2-通过-x3D-加入多个状态"><a href="#2-通过-x3D-加入多个状态" class="headerlink" title="2. 通过 |&#x3D; 加入多个状态"></a><strong>2. 通过 |&#x3D; 加入多个状态</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 给当前状态添加指定的状态标记</span><br><span class="line">static int addFlag(int model, int flag) &#123;</span><br><span class="line">    return model | flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 发现-全部</span><br><span class="line">static final int FILTER_FOLLOW_DISCOVER_ALL = TAB_FOLLOW | MODEL_ALL;</span><br><span class="line">// 发现-玩乐</span><br><span class="line">static final int FILTER_FOLLOW_DISCOVER_PLAY = TAB_FOLLOW | MODEL_PLAY;</span><br><span class="line">// 发现-文创</span><br><span class="line">static final int FILTER_FOLLOW_DISCOVER_CULTURAL = TAB_FOLLOW | MODEL_CULTURAL;</span><br><span class="line">// 发现-家居</span><br><span class="line">static final int FILTER_FOLLOW_DISCOVER_HOME = TAB_FOLLOW | MODEL_HOME;</span><br><span class="line">// 发现-汽车</span><br><span class="line">static final int FILTER_FOLLOW_DISCOVER_CAR = TAB_FOLLOW | MODEL_HOME;</span><br></pre></td></tr></table></figure><h4 id="3-m-amp-STATUS-gt-0-判断是否拥有该状态"><a href="#3-m-amp-STATUS-gt-0-判断是否拥有该状态" class="headerlink" title="3.(m &amp; STATUS) &gt; 0 判断是否拥有该状态"></a><strong>3.(m &amp; STATUS) &gt; 0 判断是否拥有该状态</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 判断当前状态model中是否存在状态标记</span><br><span class="line">static boolean checkFlag(int model, int flag) &#123;</span><br><span class="line">    return (model &amp; flag) == flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int model = FILTER_FOLLOW_DISCOVER_ALL;</span><br><span class="line">checkFlag(model, FILTER_FOLLOW_DISCOVER_PLAY);//false</span><br><span class="line">checkFlag(model, TAB_FOLLOW);//true</span><br><span class="line">checkFlag(model, TAB_DISCOVER);//false</span><br><span class="line">checkFlag(model, MODEL_ALL);//true</span><br></pre></td></tr></table></figure><h4 id="4-m-amp-STATUS-扣除该状态"><a href="#4-m-amp-STATUS-扣除该状态" class="headerlink" title="4. (m &amp; ~STATUS)扣除该状态"></a><strong>4. (m &amp; ~STATUS)扣除该状态</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 从当前状态中移除指定的状态标记</span><br><span class="line">static int removeFlag(int model, int flag) &#123;</span><br><span class="line">    return model &amp; ~flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int model = FILTER_FOLLOW_DISCOVER_ALL;</span><br><span class="line">model = removeFlag(model, MODEL_ALL);// 移除all状态</span><br><span class="line">checkFlag(model, MODEL_ALL);//检查MODEL_ALL状态，false</span><br><span class="line">checkFlag(model, TAB_FOLLOW);//检查TAB_FOLLOW状态，true</span><br></pre></td></tr></table></figure><p>试想一下，如果不使用同一个状态值上不同状态位，而是使用多个状态值来表示很多状态的组合，在处理状态逻辑时就要使用很多if else 嵌套来判断组合判断。而使用位运算可以极大减少代码量，让逻辑判断变得更清晰更简单。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在稍微复杂的项目中，经常会遇到需要对当前业务场景进行状态判断的需求，并且这里的状态可能是多种状态组合的方式，可能只一种状态，也可能是多种状态共存。这里就可以借助位运算来解决，用一个整型数值上不同二进制位上的0、1数值来表示不同的状态。这样做既可以避免使用多个状态flag时重复if else逻辑判断，也有利于并发场景下状态更新和判断。在很多时候可以起到事半功倍的效果。这里就简单介绍如何进行状态设计和状态判断。&lt;/p&gt;</summary>
    
    
    
    <category term="方案与设计" scheme="https://ivonhoe.github.io/categories/%E6%96%B9%E6%A1%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="设计模式" scheme="https://ivonhoe.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰器模式</title>
    <link href="https://ivonhoe.github.io/2022/08/05/design-patterns-decorator/"/>
    <id>https://ivonhoe.github.io/2022/08/05/design-patterns-decorator/</id>
    <published>2022-08-05T15:58:58.000Z</published>
    <updated>2022-08-05T16:07:16.170Z</updated>
    
    <content type="html"><![CDATA[<p>装饰器模式的经典应用就是在IO类库的设计上，如下面的用例所示，实现对文件的读取功能，可以选择使用FileInputStream类也可以使用BufferedInputStream嵌套FileInputStream的方式来完成，在具体API的使用上都可以使用read(bytes)的方式。</p><span id="more"></span><h3 id="从Java-IO看装饰器模式"><a href="#从Java-IO看装饰器模式" class="headerlink" title="从Java IO看装饰器模式"></a>从Java IO看装饰器模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void testDataInputStream() &#123;</span><br><span class="line">    File testFile = new File(&quot;/Users/ivonhoe/Workspace/Java/Ant/simlog/pom.xml&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        FileInputStream fileInputStream = new FileInputStream(testFile);</span><br><span class="line">        BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);</span><br><span class="line">        DataInputStream dataInputStream = new DataInputStream(bufferedInputStream);</span><br><span class="line">        char a = dataInputStream.readChar();</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在API调用上两者表现几乎一致，但是在具体的实现上有较大的差别，BufferedInputStream增加了缓存buffer，通过先批量填充buffer再读取内存的方式提高了读取性能并且可以解决两端流速不匹配的问题。通过对象的组合设计对读取方式实现了增强，同样的，想要在buffer读取的基础上增加按照数据类型读取的能力，可以通过嵌套DataInputStream的方式实现。</p><p><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1659608746798-6d0b07af-0c68-49e3-8766-e72d2a5c100e.png#clientId=uf10e6557-d3ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1104&id=JnpIW&margin=%5Bobject%20Object%5D&name=yuque_diagram.png&originHeight=2208&originWidth=1856&originalType=binary&ratio=1&rotation=0&showTitle=false&size=399923&status=done&style=none&taskId=u9d4606ea-fa2f-4bec-9521-88a120b6ae8&title=&width=928" alt="yuque_diagram.png"><br />Java IO类库在设计上选择了组合而不是继承的方式，在实现功能的同时减少了类的数量。通过IO类库可以简单总结下装饰器模式的特点。【<strong>通过向现有的对象添加新的功能，不改变其内部结构，并且在原有功能基础上对其进行增强</strong>】。就像同样是文件读取功能，Buffered能力和readChar能力可以组合使用，并没有改变被包装对象的内部实现，并且增强了不同类型的read能力。</p><h3 id="装饰器模式定义"><a href="#装饰器模式定义" class="headerlink" title="装饰器模式定义"></a>装饰器模式定义</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1659671784828-36541e8f-d713-4642-8aaa-8ac66356c75c.png#clientId=uf10e6557-d3ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=378&id=ud0407aff&margin=%5Bobject%20Object%5D&name=image.png&originHeight=504&originWidth=595&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61563&status=done&style=none&taskId=ucb109f71-6609-4883-871c-5a923db0427&title=&width=446" alt="image.png"><br />装饰器模式的角色有：</p><ul><li>抽象构建（Component）:给出一个抽象接口，已规范准备接收附加责任的对象</li><li>具体构建（ConcreteComponent）:定义一个将要接收附加责任的类</li><li>抽象装饰（Decorator）:持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口</li><li>具体装饰（ConcreteDecorator）：负责给构件对象“贴上”附加的责任</li></ul><p>对比Java IO库中的设计：</p><ul><li>InputStream -&gt; <strong>Component</strong></li><li>FileInputStream -&gt; <strong>ConcreteComponent</strong></li><li>FilterInputStream -&gt;  <strong>Decorator</strong></li><li>BufferedInputStream &#x2F; GZIPInputStream &#x2F; DataInputStream -&gt; <strong>ConcreteDecorator</strong></li></ul><p>装饰器模式的优点:更灵活的扩展对象功能。相比较使用类继承，对象包装的方式更灵活。可以根据实际需要为一个对象任意组合嵌套多种装饰功能。<br />从代码结构的角度来说，装饰器模式和代理模式都使用了对象包装的方式，那么他们的的差异在哪里？在代理模式中，代理类附加的功能和原始类不相关，而在装饰器模式中，装饰器类附加的是和原始类相关的增强功能。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>装饰器模式可以解决继承关系过于复杂的问题，通过组合关系替代继承关系。装饰器模式的主要作用是给原始类增加增强功能。一个原始类可以嵌套多个装饰器类。装饰器类需要与原始类继承相同的抽象类或者接口。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>《王争：设计模式之美》<br /><a href="https://www.cnblogs.com/pluto-charon/p/16030199.html">https://www.cnblogs.com/pluto-charon/p/16030199.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;装饰器模式的经典应用就是在IO类库的设计上，如下面的用例所示，实现对文件的读取功能，可以选择使用FileInputStream类也可以使用BufferedInputStream嵌套FileInputStream的方式来完成，在具体API的使用上都可以使用read(bytes)的方式。&lt;/p&gt;</summary>
    
    
    
    <category term="方案与设计" scheme="https://ivonhoe.github.io/categories/%E6%96%B9%E6%A1%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="设计模式" scheme="https://ivonhoe.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ANR分析记录(三)主线程方法耗时</title>
    <link href="https://ivonhoe.github.io/2022/07/22/android-anr-3/"/>
    <id>https://ivonhoe.github.io/2022/07/22/android-anr-3/</id>
    <published>2022-07-22T15:48:49.000Z</published>
    <updated>2022-08-05T16:20:53.680Z</updated>
    
    <content type="html"><![CDATA[<p>日常Android ANR问题分析记录。</p><span id="more"></span><h3 id="0x01-ANR六看"><a href="#0x01-ANR六看" class="headerlink" title="0x01 ANR六看"></a>0x01 ANR六看</h3><h4 id="一看-Trace"><a href="#一看-Trace" class="headerlink" title="一看 Trace"></a>一看 Trace</h4><p>关键词：Blocked，waiting to lock，locked<br>看堆栈：死锁堆栈，业务调用堆栈，IPC堆栈，系统调用堆栈</p><h4 id="二看logcat关键字"><a href="#二看logcat关键字" class="headerlink" title="二看logcat关键字"></a>二看logcat关键字</h4><p>关键字：Load，CPU，Slow Operation，Kswapd，Mmcqd，Kwork，Lowmemkiller 等等<br>通过日志中这些关键字判断当前系统是否存在 (CPU，Mem，IO) 资源紧张的情况。</p><h4 id="三看系统负载分布"><a href="#三看系统负载分布" class="headerlink" title="三看系统负载分布"></a>三看系统负载分布</h4><p>关键字：user，sys，IOWait<br>通过观察系统负载，则可以进一步明确是 CPU 资源紧张，还是 IO 资源紧张；如果系统负载过高，一定是有某个进程或多个进程引起的。反之系统负载过高又会影响到所有进程调度性能。通过观察 User，Sys 的 CPU 占比，可以进一步发分析当前负载过高是发生在应用空间，还是系统空间，如大量调用逻辑 (如文件读写，内存紧张导致系统不断回收内存等等)，知道这些之后，排查方向又会进一步缩小范围。</p><h4 id="四看进程-CPU"><a href="#四看进程-CPU" class="headerlink" title="四看进程 CPU"></a>四看进程 CPU</h4><p>关键字：CPU usage<br><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1657619596560-a4f0fdaa-7335-4419-8cdb-904adfbe5b07.png#clientId=u6b2c4f83-fe9e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=72&id=u1fffec09&margin=%5Bobject%20Object%5D&name=image.png&originHeight=144&originWidth=1024&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60468&status=done&style=none&taskId=u16fce71a-d91d-449c-aa27-e3a6cdfc78b&title=&width=512" alt="image.png"></p><h4 id="五看-CPU-占比定线程"><a href="#五看-CPU-占比定线程" class="headerlink" title="五看 CPU 占比定线程"></a>五看 CPU 占比定线程</h4><h4 id="六看主线程消息调度"><a href="#六看主线程消息调度" class="headerlink" title="六看主线程消息调度"></a>六看主线程消息调度</h4><h3 id="0x02-错误分析"><a href="#0x02-错误分析" class="headerlink" title="0x02 错误分析"></a>0x02 错误分析</h3><h4 id="2-1-日志分析"><a href="#2-1-日志分析" class="headerlink" title="2.1 日志分析"></a>2.1 日志分析</h4><p>测试同学反馈在测试环境上，某些操作后app必现ANR，通过bugreport命令抓取以下ANR trace。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">DALVIK THREADS (226):</span><br><span class="line">&quot;main&quot; prio=5 tid=1 Runnable</span><br><span class="line">  | group=&quot;main&quot; sCount=0 ucsCount=0 flags=0 obj=0x714acbb0 self=0xb400007416e10800</span><br><span class="line">  | sysTid=14827 nice=-10 cgrp=default sched=0/0 handle=0x74c2f26500</span><br><span class="line">  | state=R schedstat=( 115021450752 1125156276 11142 ) utm=11377 stm=124 core=7 HZ=100</span><br><span class="line">  | stack=0x7fdfbd7000-0x7fdfbd9000 stackSize=8188KB</span><br><span class="line">  | held mutexes= &quot;mutator lock&quot;(shared held)</span><br><span class="line">  at androidx.viewpager.widget.ViewPager.populate(ViewPager.java:1171)</span><br><span class="line">  at androidx.viewpager.widget.ViewPager.populate(ViewPager.java:1092)</span><br><span class="line">  at androidx.viewpager.widget.ViewPager.onMeasure(ViewPager.java:1622)</span><br><span class="line">  at android.view.View.measure(View.java:25977)</span><br><span class="line">  at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:7073)</span><br><span class="line">  at android.widget.FrameLayout.onMeasure(FrameLayout.java:194)</span><br><span class="line">  at android.view.View.measure(View.java:25977)</span><br><span class="line">  at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:7073)</span><br><span class="line">  at android.widget.FrameLayout.onMeasure(FrameLayout.java:194)</span><br><span class="line">  at android.view.View.measure(View.java:25977)</span><br><span class="line">  at android.widget.RelativeLayout.measureChildHorizontal(RelativeLayout.java:735)</span><br><span class="line">  at android.widget.RelativeLayout.onMeasure(RelativeLayout.java:481)</span><br><span class="line">  at android.view.View.measure(View.java:25977)</span><br><span class="line">  at android.widget.RelativeLayout.measureChild(RelativeLayout.java:696)</span><br><span class="line">  at android.widget.RelativeLayout.onMeasure(RelativeLayout.java:499)</span><br><span class="line">  at android.view.View.measure(View.java:25977)</span><br><span class="line">  at android.widget.LinearLayout.measureHorizontal(LinearLayout.java:1185)</span><br><span class="line">  at android.widget.LinearLayout.onMeasure(LinearLayout.java:723)</span><br><span class="line">  at android.view.View.measure(View.java:25977)</span><br><span class="line">  at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:7073)</span><br><span class="line">  at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1552)</span><br><span class="line">  at android.widget.LinearLayout.measureHorizontal(LinearLayout.java:1204)</span><br><span class="line">  at android.widget.LinearLayout.onMeasure(LinearLayout.java:723)</span><br><span class="line">  at android.view.View.measure(View.java:25977)</span><br><span class="line">  at android.widget.RelativeLayout.measureChildHorizontal(RelativeLayout.java:735)</span><br><span class="line">  at android.widget.RelativeLayout.onMeasure(RelativeLayout.java:481)</span><br><span class="line">  at android.view.View.measure(View.java:25977)</span><br><span class="line">  at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:7073)</span><br><span class="line">  at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1552)</span><br><span class="line">  at android.widget.LinearLayout.measureVertical(LinearLayout.java:842)</span><br><span class="line">  at android.widget.LinearLayout.onMeasure(LinearLayout.java:721)</span><br></pre></td></tr></table></figure><p>通过trace日志和viewpage源码并不能第一时间定位原因，只能看出并不是简单的锁同步问题导致的ANR。转而通过logcat日志查找更多有用的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Load: 0.6 / 0.62 / 0.48</span><br><span class="line">CPU usage from 24258ms to 13621ms ago (2022-07-12 12:10:12.021 to 2022-07-12 12:10:22.658) with 99% awake:</span><br><span class="line">  82% 16394/xxxxxxxxxxxx: 71% user + 11% kernel / faults: 4691 minor 1 major</span><br><span class="line">  29% 1115/surfaceflinger: 19% user + 9.9% kernel / faults: 5 minor</span><br><span class="line">  16% 1290/system_server: 9.9% user + 6.8% kernel / faults: 3959 minor</span><br><span class="line">  13% 1045/vendor.qti.hardware.display.composer-service: 9.3% user + 4% kernel</span><br><span class="line">  5.5% 23223/com.heytap.market: 4.2% user + 1.2% kernel / faults: 6350 minor 3 major</span><br><span class="line">  5.3% 387/crtc_commit:111: 0% user + 5.3% kernel</span><br><span class="line">  3.8% 28079/kworker/u24:6-ufs_pm_qos_0: 0% user + 3.8% kernel</span><br><span class="line">  3% 11017/kworker/u24:12-ufs_pm_qos_0: 0% user + 3% kernel</span><br><span class="line">  2.9% 296/kgsl_worker_thr: 0% user + 2.9% kernel</span><br><span class="line">  2.7% 9946/kworker/u24:3-kverityd: 0% user + 2.7% kernel</span><br><span class="line">  2% 2940/com.android.systemui: 1.4% user + 0.5% kernel / faults: 702 minor</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  24% TOTAL: 15% user + 7% kernel + 0% iowait + 1.6% irq + 0.3% softirq</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from 0ms to 6338ms later (2022-07-12 12:05:52.611 to 2022-07-12 12:05:58.950) with 99% awake:</span><br><span class="line">  119% 14827/xxxxxxxxxxxx: 109% user + 10% kernel / faults: 7495 minor</span><br><span class="line">  46% 1290/system_server: 21% user + 25% kernel / faults: 5888 minor</span><br><span class="line">  20% 627/logd: 16% user + 4.4% kernel / faults: 60205 minor</span><br><span class="line">  8.6% 27447/media.codec: 5.5% user + 3.1% kernel / faults: 8918 minor</span><br><span class="line">  4.4% 1036/android.hardware.sensors@2.0-service.multihal: 1.8% user + 2.5% kernel / faults: 559 minor 6 major</span><br><span class="line">  3.7% 3504/com.android.launcher: 2.6% user + 1.1% kernel / faults: 1874 minor</span><br><span class="line">  0.1% 1564/media.swcodec: 0% user + 0% kernel / faults: 4653 minor</span><br><span class="line">  2.9% 9945/kworker/u24:1+DIAG_CTRL: 0% user + 2.9% kernel</span><br><span class="line">  2.8% 1115/surfaceflinger: 1.1% user + 1.7% kernel / faults: 921 minor</span><br><span class="line">  2.6% 9991/kworker/u24:5-adb: 0% user + 2.6% kernel</span><br><span class="line">  2.6% 28079/kworker/u24:6-ufs_pm_qos_0: 0% user + 2.6% kernel</span><br><span class="line">  2.5% 9946/kworker/u24:3-kverityd: 0% user + 2.5% kernel</span><br><span class="line">  2.2% 2940/com.android.systemui: 0.9% user + 1.2% kernel / faults: 239 minor</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  37% TOTAL: 22% user + 11% kernel + 1% iowait + 1.5% irq + 0.3% softirq</span><br></pre></td></tr></table></figure><p>通过以上日志可以看到，</p><blockquote><p>Load: 0.6 &#x2F; 0.62 &#x2F; 0.48</p></blockquote><p>ANR 发生前 1 分钟，前 5 分钟，前 15 分钟，系统的整体负载并不高，具体数值代表单位时间等待系统调度的任务数。</p><blockquote><p>CPU usage from 24258ms to 13621ms ago<br>82% 16394&#x2F;xxxxxxxxxxxx: 71% user + 11% kernel &#x2F; faults: 4691 minor 1 major</p></blockquote><p>ANR问题发生之前（CPU usage from XXX to XXX ago），app进程CPU使用率 82%，其中user占比71%，kernel 占比11%。system_server进程CPU使用率16% 。</p><blockquote><p>CPU usage from 0ms to 6338ms later<br> 119% 14827&#x2F;xxxxxxxxxxxx: 109% user + 10% kernel &#x2F; faults: 7495 minor</p></blockquote><p>ANR问题发生以后（CPU usage from XXX to XXX later），app进程CPU使用率 119%，其中user占比109%，kernel 占比10%。system_server进程CPU使用率46% 。<br><strong>通过以上数据可以判断，问题发生时，系统负载并不高，系统调用不频繁，系统IO负载很低。但是app用户进程的CPU资源很紧张，高CPU使用率应该发生在app的用户进程，大概率还是业务代码实现有问题导致的ANR。</strong></p><h4 id="2-2-借助Layout-Inspector定位问题代码"><a href="#2-2-借助Layout-Inspector定位问题代码" class="headerlink" title="2.2 借助Layout Inspector定位问题代码"></a>2.2 借助Layout Inspector定位问题代码</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1658129918944-faeb6984-e33c-4eac-b6de-ea96e0fffba3.png#clientId=uae18713d-0737-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=607&id=uf6a4b5e7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1214&originWidth=396&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38549&status=done&style=none&taskId=u827dd0d6-8464-43d2-8566-cd925e4ced9&title=&width=198" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1658129923422-bbd9022f-1ade-45ed-933d-b56c9425e7eb.png#clientId=uae18713d-0737-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=444&id=u77c433a5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=539&originWidth=540&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75361&status=done&style=none&taskId=u9225e9bc-692b-459a-afb2-4309f0f132a&title=&width=445" alt="image.png"></p><p>通过日志大致判断问题发生在app业务代码中，梳理了以下的问题排查思路。</p><ol><li>观察trace堆栈可以发现ANR发生在页面布局绘制流程，这样通过调用堆栈可以获取页面布局的层级关系</li><li>借助AS的Layout Inspector工具分析问题发生的页面就可以找到页面中使用viewpager组件的都是哪些业务模块</li><li>结合以上1，2信息定位出发生ANR问题的详细视图位置，再根据具体的视图实现走查业务代码。</li><li>通过查看业务组件的代码实现最终找到了问题原因，业务为了实现图片banner的轮播效果，通过设置Adapter count和Viewpager mCurItem 为一个超大的整数（<strong>Integer.MAX_VALUE</strong>）来实现viewpager无限滚动效果。导致Viewpager的populate方法主线程执行超时。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void populate(int newCurrentItem) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    // Fill 3x the available width or up to the number of offscreen</span><br><span class="line">    // pages requested to either side, whichever is larger.</span><br><span class="line">    // If we have no current item we have no work to do.</span><br><span class="line">    if (curItem != null) &#123;</span><br><span class="line">        for (int pos = mCurItem - 1; pos &gt;= 0; pos--) &#123;</span><br><span class="line">            // 超大整数导致循环执行超时</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>解决方案也比较简单，针对轮播banner效果重新更换了实现方式。</li></ol><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>大部分的ANR问题主要难点在于发现问题和分析问题发生的原因。一般的分析步骤是通过借助分析日志，从ANR Trace、logcat日志、kernel日志到消息队列日志，逐步将可能出现问题的范围缩小，通过CPU、IO、系统调用情况并结合代码走查定位问题原因。本文的分析过程相对比较简单，但是总体遵循这样的分析路径，最终定位并解决了该问题。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://blog.csdn.net/liuwg1226/article/details/118465301">https://blog.csdn.net/liuwg1226/article/details/118465301</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;日常Android ANR问题分析记录。&lt;/p&gt;</summary>
    
    
    
    <category term="性能优化" scheme="https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="anr" scheme="https://ivonhoe.github.io/tags/anr/"/>
    
  </entry>
  
  <entry>
    <title>ANR分析记录(二)线程死锁</title>
    <link href="https://ivonhoe.github.io/2022/05/29/android-anr-2/"/>
    <id>https://ivonhoe.github.io/2022/05/29/android-anr-2/</id>
    <published>2022-05-28T16:29:07.000Z</published>
    <updated>2022-08-05T16:05:59.523Z</updated>
    
    <content type="html"><![CDATA[<p>日常Android ANR问题分析记录。</p><span id="more"></span><h3 id="0x01-获取ANR日志"><a href="#0x01-获取ANR日志" class="headerlink" title="0x01 获取ANR日志"></a>0x01 获取ANR日志</h3><p>我们都知道当应用发生ANR时，系统会将ANR时的日志信息保存到在&#x2F;data&#x2F;anr&#x2F;traces.txt文件中。可以通过分析traces.txt文件对引发ANR问题的原因进行分析，但是在实际发生问题的时候，因为系统文件访问权限的问题，很难在非root的系统中获取到&#x2F;data&#x2F;anr&#x2F;traces.txt问题。所以这里需要借助另一个工具adb bugreport来获取异常日志。<br><a href="https://developer.android.com/studio/debug/bug-report?hl=zh-cn">https://developer.android.com/studio/debug/bug-report?hl=zh-cn</a></p><blockquote><p>默认情况下，ZIP 文件称为 bugreport-<strong>BUILD_ID</strong>-<strong>DATE</strong>.zip，它可能会包含多个文件，但最重要的文件是 bugreport-<strong>BUILD_ID</strong>-<strong>DATE</strong>.txt。此文件就是错误报告，它包含系统服务 (dumpsys)、错误日志 (dumpstate) 和系统消息日志 (logcat) 的诊断输出。系统消息包括设备抛出错误时的堆栈轨迹，以及从所有应用中使用 <a href="https://developer.android.com/reference/android/util/Log?hl=zh-cn">Log</a> 类写入的消息。<br>ZIP 文件中有一个 version.txt 元数据文件，其中包含 Android 版本号，而且启用 systrace 后，ZIP 文件中还会包含 systrace.txt 文件。<a href="https://developer.android.com/topic/performance/tracing/command-line?hl=zh-cn">Systrace 工具</a>可以获取并显示应用进程和其他 Android 系统进程的执行时间，从而帮助分析应用的性能。<br>dumpstate 工具会将文件从设备的文件系统复制到 ZIP 文件的 FS 文件夹下，以便您引用它们。例如，设备中的 <strong>&#x2F;dirA&#x2F;dirB&#x2F;fileC</strong> 文件会在 ZIP 文件中生成 <strong>FS&#x2F;dirA&#x2F;dirB&#x2F;fileC</strong> 条目。</p></blockquote><p><a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn">https://source.android.com/source/read-bug-reports.html?hl=zh-cn</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb bugreport</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1652152425005-0dc4f1c9-cc6b-4479-a05a-6912842c2917.png#clientId=ud117e37e-06ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=55&id=uac2e2dc1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=110&originWidth=1290&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35923&status=done&style=none&taskId=ub479bf6b-8b9a-4105-b33c-f6e540d3f71&title=&width=645" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell ls /bugreports/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1652152126664-475d848d-c73e-444c-a2a4-27c873e5b16f.png#clientId=ud117e37e-06ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=273&id=nASE8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=546&originWidth=1058&originalType=binary&ratio=1&rotation=0&showTitle=false&size=177421&status=done&style=none&taskId=u5e8b338c-a359-4b8f-88b5-211313522b6&title=&width=529" alt="image.png"><br>解压bugreport.zip就可以看到系统logcat和dumpsys日志信息，而我们想要重点分析的ant traces日志就只&#x2F;FS&#x2F;data&#x2F;anr目录中。</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1652152514036-db451eae-5ae9-453c-9aab-732bf0f5612d.png#clientId=ud117e37e-06ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=245&id=u11bdc224&margin=%5Bobject%20Object%5D&name=image.png&originHeight=326&originWidth=605&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36982&status=done&style=none&taskId=ufccaaa7a-9d66-4784-945e-1a14faa096f&title=&width=454" alt="image.png"></h3><h3 id="0x02-日志分析"><a href="#0x02-日志分析" class="headerlink" title="0x02 日志分析"></a>0x02 日志分析</h3><h4 id="2-1-分析traces-txt时需要关注的关键信息"><a href="#2-1-分析traces-txt时需要关注的关键信息" class="headerlink" title="2.1 分析traces.txt时需要关注的关键信息"></a>2.1 分析traces.txt时需要关注的关键信息</h4><ol><li>pid为进程id，sysTid&#x3D;pid，这里主线程的线程号&#x3D;进程号，prio&#x3D;5为线程优先级</li><li>当一个线程占有一个锁的时候，会打印-locked&lt;0xxxxxxx&gt;</li><li>当该线程正在等待别的线程释放该锁，会打印waiting to lock &lt;0xxxxxx&gt;</li><li>如果代码中有wait()调用的话，首先是locked，然后会打印waiting on &lt;0xxxxxx&gt;</li></ol><h4 id="2-2-日志一"><a href="#2-2-日志一" class="headerlink" title="2.2 日志一"></a>2.2 日志一</h4><ul><li>异常信息：  - waiting to lock &lt;0x0c8b6ef5&gt; (a java.lang.Class&lt;xxx.DeviceMeta&gt;) held by thread 60</li><li>异常说明：主线程等待thread 60释放&lt;0x0c8b6ef5&gt;对象，导致主线程被blocked，发生ANR<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; prio=5 tid=1 Blocked</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x722423a8 self=0x7e6f0a0c00</span><br><span class="line">  | sysTid=1840 nice=-10 cgrp=default sched=0/0 handle=0x7e7074c4f8</span><br><span class="line">  | state=S schedstat=( 4835749094 86478588 880 ) utm=442 stm=41 core=6 HZ=100</span><br><span class="line">  | stack=0x7ffba79000-0x7ffba7b000 stackSize=8192KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at xxxxxxxxxxxxxxxxxxxxxxx.DeviceMeta.getInstance(DeviceMeta.java:24)</span><br><span class="line">  - waiting to lock &lt;0x0c8b6ef5&gt; (a java.lang.Class&lt;xxxxxxxxxxxxxxxxxxxxxxx.DeviceMeta&gt;) held by thread 60</span><br><span class="line">  at xxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">  at kotlin.SynchronizedLazyImpl.getValue(LazyJVM.kt:74)</span><br><span class="line">  - locked &lt;0x09ab148a&gt; (a kotlin.SynchronizedLazyImpl)</span><br><span class="line">  at xxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">  at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)</span><br><span class="line">  at kotlinx.coroutines.DispatchedContinuationKt.resumeCancellableWith(DispatchedContinuation.kt:313)</span><br><span class="line">  at kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable(Cancellable.kt:26)</span><br><span class="line">  at kotlinx.coroutines.CoroutineStart.invoke(CoroutineStart.kt:109)</span><br><span class="line">  at kotlinx.coroutines.AbstractCoroutine.start(AbstractCoroutine.kt:158)</span><br><span class="line">  at kotlinx.coroutines.BuildersKt__Builders_commonKt.launch(Builders.common.kt:54)</span><br><span class="line">  at kotlinx.coroutines.BuildersKt.launch(unavailable:1)</span><br><span class="line">  at kotlinx.coroutines.BuildersKt__Builders_commonKt.launch$default(Builders.common.kt:47)</span><br><span class="line">  at kotlinx.coroutines.BuildersKt.launch$default(unavailable:1)</span><br><span class="line">  at xxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">  at androidx.fragment.app.FragmentManagerImpl.moveToState(FragmentManager.java:1471)</span><br><span class="line">  at androidx.fragment.app.FragmentManagerImpl.moveFragmentToExpectedState(FragmentManager.java:1784)</span><br><span class="line">  at androidx.fragment.app.FragmentManagerImpl.moveToState(FragmentManager.java:1852)</span><br><span class="line">  at androidx.fragment.app.BackStackRecord.executeOps(BackStackRecord.java:802)</span><br><span class="line">  at androidx.fragment.app.FragmentManagerImpl.executeOps(FragmentManager.java:2625)</span><br><span class="line">  at androidx.fragment.app.FragmentManagerImpl.executeOpsTogether(FragmentManager.java:2411)</span><br><span class="line">  at androidx.fragment.app.FragmentManagerImpl.removeRedundantOperationsAndExecute(FragmentManager.java:2366)</span><br><span class="line">  at androidx.fragment.app.FragmentManagerImpl.execPendingActions(FragmentManager.java:2273)</span><br><span class="line">  at androidx.fragment.app.FragmentManagerImpl.dispatchStateChange(FragmentManager.java:3273)</span><br><span class="line">  at androidx.fragment.app.FragmentManagerImpl.dispatchActivityCreated(FragmentManager.java:3229)</span><br><span class="line">  at androidx.fragment.app.FragmentController.dispatchActivityCreated(FragmentController.java:201)</span><br><span class="line">  at androidx.fragment.app.FragmentActivity.onStart(FragmentActivity.java:620)</span><br><span class="line">  at androidx.appcompat.app.AppCompatActivity.onStart(AppCompatActivity.java:178)</span><br><span class="line">  at android.app.Instrumentation.callActivityOnStart(Instrumentation.java:1436)</span><br><span class="line">  at android.app.Activity.performStart(Activity.java:8190)</span><br><span class="line">  at android.app.ActivityThread.handleStartActivity(ActivityThread.java:3566)</span><br><span class="line">  at android.app.servertransaction.TransactionExecutor.performLifecycleSequence(TransactionExecutor.java:221)</span><br><span class="line">  at android.app.servertransaction.TransactionExecutor.cycleToPath(TransactionExecutor.java:201)</span><br><span class="line">  at android.app.servertransaction.TransactionExecutor.executeLifecycleState(TransactionExecutor.java:173)</span><br><span class="line">  at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:97)</span><br><span class="line">  at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2136)</span><br><span class="line">  at com.didichuxing.doraemonkit.kit.timecounter.instrumentation.ProxyHandlerCallback.handleMessage(ProxyHandlerCallback.java:38)</span><br><span class="line">  at leakcanary.ServiceWatcher$install$3$2.handleMessage(ServiceWatcher.kt:63)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:236)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:8060)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-日志二："><a href="#2-3-日志二：" class="headerlink" title="2.3 日志二："></a>2.3 日志二：</h4><ul><li>异常信息：pool-1-thread-14，waiting on &lt;0x07f9f1a9&gt;，WebViewChromiumFactoryProvider.getStatics</li><li>异常说明，这里tid&#x3D;60的线程就是pool-1-thread-14，而pool-1-thread-14线程等待&lt;0x07f9f1a9&gt;被释放，涉及到获取默认Webview UA的流程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&quot;pool-1-thread-14&quot; prio=5 tid=60 Waiting</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x12f465b0 self=0x7d7dec6400</span><br><span class="line">  | sysTid=2072 nice=0 cgrp=default sched=0/0 handle=0x7d44671cc0</span><br><span class="line">  | state=S schedstat=( 188559697 24197915 209 ) utm=13 stm=5 core=6 HZ=100</span><br><span class="line">  | stack=0x7d4456e000-0x7d44570000 stackSize=1043KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at java.lang.Object.wait(Native method)</span><br><span class="line">  - waiting on &lt;0x07f9f1a9&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Object.wait(Object.java:442)</span><br><span class="line">  at java.lang.Object.wait(Object.java:568)</span><br><span class="line">  at Lw0.b(chromium-TrichromeWebViewGoogle.apk-stable-451513133:22)</span><br><span class="line">  at Lw0.g(chromium-TrichromeWebViewGoogle.apk-stable-451513133:3)</span><br><span class="line">  - locked &lt;0x07f9f1a9&gt; (a java.lang.Object)</span><br><span class="line">  at com.android.webview.chromium.WebViewChromiumFactoryProvider.getStatics(chromium-TrichromeWebViewGoogle.apk-stable-451513133:4)</span><br><span class="line">  - locked &lt;0x07f9f1a9&gt; (a java.lang.Object)</span><br><span class="line">  at android.webkit.WebSettings.getDefaultUserAgent(WebSettings.java:1355)</span><br><span class="line">  at xxxxxxxxxxxxxxxxxxxxxxx.DeviceMeta.initialize(DeviceMeta.java:73)</span><br><span class="line">  at xxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">  - locked &lt;0x0c8b6ef5&gt; (a java.lang.Class&lt;com.hellobike.deviceinfo.DeviceMeta&gt;)</span><br><span class="line">  at xxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">  at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:462)</span><br><span class="line">  at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:923)</span><br></pre></td></tr></table></figure><h4 id="2-4-日志三"><a href="#2-4-日志三" class="headerlink" title="2.4 日志三"></a>2.4 日志三</h4><ul><li>异常信息：DefaultDispatcher-worker-2，&lt;0x07f9f1a9&gt;，WebViewChromiumFactoryProvider.getStatics</li><li>异常分析：DefaultDispatcher-worker-2线程等待&lt;0x07f9f1a9&gt;被释放，涉及到获取默认Webview UA的流程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&quot;DefaultDispatcher-worker-2&quot; daemon prio=5 tid=88 Waiting</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x12f48e28 self=0x7dcc42b400</span><br><span class="line">  | sysTid=2127 nice=0 cgrp=default sched=0/0 handle=0x7d25aa7cc0</span><br><span class="line">  | state=S schedstat=( 2489276 592551 5 ) utm=0 stm=0 core=1 HZ=100</span><br><span class="line">  | stack=0x7d259a4000-0x7d259a6000 stackSize=1043KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at java.lang.Object.wait(Native method)</span><br><span class="line">  - waiting on &lt;0x07f9f1a9&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Object.wait(Object.java:442)</span><br><span class="line">  at java.lang.Object.wait(Object.java:568)</span><br><span class="line">  at Lw0.b(chromium-TrichromeWebViewGoogle.apk-stable-451513133:22)</span><br><span class="line">  at Lw0.g(chromium-TrichromeWebViewGoogle.apk-stable-451513133:3)</span><br><span class="line">  - locked &lt;0x07f9f1a9&gt; (a java.lang.Object)</span><br><span class="line">  at com.android.webview.chromium.WebViewChromiumFactoryProvider.getStatics(chromium-TrichromeWebViewGoogle.apk-stable-451513133:4)</span><br><span class="line">  - locked &lt;0x07f9f1a9&gt; (a java.lang.Object)</span><br><span class="line">  at android.webkit.WebSettings.getDefaultUserAgent(WebSettings.java:1355)</span><br><span class="line">  at xxxxxxxxxxxxxxxxxxxxxxx.getDefaultUserAgent(UserAgentUtils.java:29)</span><br><span class="line">  at xxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">  at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)</span><br><span class="line">  at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:56)</span><br><span class="line">  at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:561)</span><br><span class="line">  at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:727)</span><br><span class="line">  at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:667)</span><br><span class="line">  at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:655)</span><br></pre></td></tr></table></figure></li></ul><h3 id="0x03-异常分析"><a href="#0x03-异常分析" class="headerlink" title="0x03 异常分析"></a>0x03 异常分析</h3><h4 id="3-1-线索"><a href="#3-1-线索" class="headerlink" title="3.1 线索"></a>3.1 线索</h4><p>通过以上的3条traces日志表现，可以大致得到以下线索：</p><ol><li>因为单例的使用，主线程等待pool-1-thread-14释放单例对象中的锁对象</li><li>而pool-1-thread-14线程和DefaultDispatcher-worker-2都在获取WebSettings.getDefaultUserAgent的流程里，并且这两个线程都在等待状态，webview内核中应该有wait()的调用</li><li>按照常理如果子线程创建UA完毕，结束了等待状态后，主线程就能够获取到想要的锁对象了，也就不会存在ANR问题，但是现在既然出现了ANR，说明很可能是因为两个获取UA的流程都不能结束等待状态。看起来就很像是一个死锁问题了</li></ol><h4 id="3-2-为什么会出现死锁？"><a href="#3-2-为什么会出现死锁？" class="headerlink" title="3.2 为什么会出现死锁？"></a>3.2 为什么会出现死锁？</h4><p>通过查阅网上的资料大致了解一下WebView内核启动的源码，问题就更清晰了。原来在WebView内核的启动流程里，会有一个runnable被提交给主线程，负责在主线程执行startChromiumLocked方法，只有当主线程执行完该方法以后，才会结束等待状态。这也就是为什么上述的DefaultDispatcher-worker-2和pool-1-thread-14两个线程一直处于等待状态的原因。而发生死锁的原因正式因为在此时，主线程想要获取的锁对象正在被tid&#x3D;60的pool-1-thread-14线程持有，startChromiumLocked方法又得不到真正的执行。这样相互持有依赖的锁对象而又都处于等待状态，这就是标准的死锁问题了。</p><p>WebViewFactoryProvider.getStatics()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Statics getStatics() &#123;</span><br><span class="line">    synchronized (mAwInit.getLock()) &#123;</span><br><span class="line">        SharedStatics sharedStatics = mAwInit.getStatics();</span><br><span class="line">        if (mStaticsAdapter == null) &#123;</span><br><span class="line">            mStaticsAdapter = new WebViewChromiumFactoryProvider.Statics() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String findAddress(String addr) &#123;</span><br><span class="line">                    return sharedStatics.findAddress(addr);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public String getDefaultUserAgent(Context context) &#123;</span><br><span class="line">                    return sharedStatics.getDefaultUserAgent(context);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return mStaticsAdapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebViewChromiumAwInit.getStatics()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public SharedStatics getStatics() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (mSharedStatics == null) &#123;</span><br><span class="line">            // TODO: Optimization potential: most these methods only need the native library</span><br><span class="line">            // loaded and initialized, not the entire browser process started.</span><br><span class="line">            // See also http://b/7009882</span><br><span class="line">            ensureChromiumStartedLocked(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return mSharedStatics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebViewChromiumAwInit.ensureChromiumStartedLocked(Boolean)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// This method is not private only because the downstream subclass needs to access it,</span><br><span class="line">// it shouldn&#x27;t be accessed from anywhere else.</span><br><span class="line">/* package */ void ensureChromiumStartedLocked(boolean onMainThread) &#123;</span><br><span class="line">    assert Thread.holdsLock(mLock);</span><br><span class="line"></span><br><span class="line">    if (mStarted) &#123; // Early-out for the common case.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Looper looper = !onMainThread ? Looper.myLooper() : Looper.getMainLooper();</span><br><span class="line">    ThreadUtils.setUiThread(looper);</span><br><span class="line"></span><br><span class="line">    if (ThreadUtils.runningOnUiThread()) &#123;</span><br><span class="line">        startChromiumLocked();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AwThreadUtils.postToUiThreadLooper(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (mLock) &#123;</span><br><span class="line">                startChromiumLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    while (!mStarted) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // Keep trying... eventually the UI thread will process the task we sent it.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-验证以上的分析，通过demo复现"><a href="#3-3-验证以上的分析，通过demo复现" class="headerlink" title="3.3 验证以上的分析，通过demo复现"></a>3.3 验证以上的分析，通过demo复现</h4><p>正如以上分析的那样，可以写出以下的demo代码，就可以100%复现这个问题。解决这个问题的方法也很简单，避免主线程和子线程等待同一个对象锁就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Object lock = new Object();</span><br><span class="line"></span><br><span class="line">private void testUA() &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                WebSettings.getDefaultUserAgent(getApplicationContext());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(30);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        WebSettings.getDefaultUserAgent(getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-复习以下死锁的必要条件"><a href="#3-4-复习以下死锁的必要条件" class="headerlink" title="3.4 复习以下死锁的必要条件"></a>3.4 复习以下死锁的必要条件</h4><ol><li>产生死锁的必要条件：<ol><li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li><li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</li></ol></li><li>预防死锁：<ol><li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</li><li>只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）</li><li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li><li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ol></li></ol><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://ivonhoe.github.io/2018/10/14/android-anr-1/">https://ivonhoe.github.io/2018/10/14/android-anr-1/</a><br><a href="https://juejin.cn/post/6982896002680225800">https://juejin.cn/post/6982896002680225800</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;日常Android ANR问题分析记录。&lt;/p&gt;</summary>
    
    
    
    <category term="性能优化" scheme="https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="anr" scheme="https://ivonhoe.github.io/tags/anr/"/>
    
  </entry>
  
  <entry>
    <title>如何排查flutter性能问题</title>
    <link href="https://ivonhoe.github.io/2022/04/09/flutter-dev-tools/"/>
    <id>https://ivonhoe.github.io/2022/04/09/flutter-dev-tools/</id>
    <published>2022-04-08T16:00:51.000Z</published>
    <updated>2022-05-25T16:54:31.519Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter官方提供了Flutter DevTools和一些IDE Flutter plugin来辅助开发者进行性能评测，除了这些工具以外，还可以借助Dart和skia引擎提供的工具进行性能分析和调试。这里简单介绍下，Dart的Observatory和Skp Debugger的使用。</p><span id="more"></span><h3 id="0x01-Observatory"><a href="#0x01-Observatory" class="headerlink" title="0x01 Observatory"></a>0x01 Observatory</h3><p>Observatory是Dart VM的性能分析工具，可以借助Observatory对Dart VM进行内存，cpu，线程，渲染流程等方面的分析，在进行页面绘制性能分析时，可借助Observatory的timeline工具进行辅助分析。可以通过以下两种方式打开Observatory URL的Web页面。更详细信息可以查看官方文档：<br><a href="https://flutterchina.club/debugging/">https://flutterchina.club/debugging/</a><br><a href="https://dart.cn/tools/dart-devtools">https://dart.cn/tools/dart-devtools</a></p><h4 id="1-通过flutter-run打开Observatory"><a href="#1-通过flutter-run打开Observatory" class="headerlink" title="1.通过flutter run打开Observatory"></a>1.通过flutter run打开Observatory</h4><p>可以使用<code>flutter run --profile | grep 127</code>命令可以看到，在终端中包含了观测台的地址<br><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1649409937097-37f77b3e-2e95-41da-9aac-5157e7176c53.png#clientId=ud356dae1-8f2c-4&crop=0&crop=0.0398&crop=0.9976&crop=1&from=paste&height=125&id=u21d6449d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=251&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&size=289405&status=done&style=none&taskId=u58cfed1a-9fcc-4d92-8e77-6e387e18e0f&title=&width=425" alt="image.png"></p><h4 id="2-通过Android-Studio打开Observatory"><a href="#2-通过Android-Studio打开Observatory" class="headerlink" title="2. 通过Android Studio打开Observatory"></a>2. 通过Android Studio打开Observatory</h4><p>1.通过点击Android studio底部的工具栏图标，打开Devtools</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1649409973795-8b10e74e-3a56-4dde-a057-e5a63e67da12.png#clientId=ud356dae1-8f2c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=ub7c7dcaf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=182&originWidth=272&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57674&status=done&style=none&taskId=ud661ac18-d6bb-4f5d-948a-e37f1a97f52&title=&width=300" alt="image.png"></p><p>2.在截取浏览器中显示的uri参数</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1649409997816-bb65cd58-77c3-4d7f-a11c-cd89d8a41ca4.png#clientId=ud356dae1-8f2c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=44&id=u5dcdfb7f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=75&originWidth=1007&originalType=binary&ratio=1&rotation=0&showTitle=false&size=56900&status=done&style=none&taskId=u0359de90-e714-4ce8-8755-1e3a0e8b965&title=&width=592.5" alt="image.png"></p><p>3.借助urldecode工具解码，两次decode后就是Observatory本地服务地址。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1649410011695-418de8ee-c973-4f8c-9bbe-5cf3742b01f5.png#clientId=ud356dae1-8f2c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=175&id=u9da0eaff&margin=%5Bobject%20Object%5D&name=image.png&originHeight=350&originWidth=1184&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109162&status=done&style=none&taskId=udccaa6b0-3f39-4ffd-b311-63132ed929b&title=&width=592" alt="image.png"></p><h3 id="0x02-Observatory-Timeline"><a href="#0x02-Observatory-Timeline" class="headerlink" title="0x02. Observatory Timeline"></a>0x02. Observatory Timeline</h3><h4 id="1-Flutter-debug-flag"><a href="#1-Flutter-debug-flag" class="headerlink" title="1. Flutter debug flag"></a>1. Flutter debug flag</h4><p>Flutter提供了很多debug flag用来帮助开发者跟踪不同处理流程的执行过程，需要注意的是，所有debug开头的flag只有在debug模式下才会生效，如</p><ul><li>debugProfileBuildsEnable：向Timeline事件中添加每个widget的build信息</li><li>debugProfileLayoutEnabled：向Timeline事件中添加每个renderObject的layout信息</li><li>debugProfilePaintEnabled: 向Timeline事件中添加每个renderObject的paint信息</li><li>debugPaintLayerBoadersEnabled: 来用为每个layer的边界显示橙色边框</li><li>debugPrintRebuildDirtyWidgets：打印标记为dirty的widgets</li><li>debugPrintBeginFrameBanner&#x2F;debugPrintEndFrameBanner：打印每帧开始和结束</li></ul><p>最简单的方式是在程序顶部入口<code>void main()</code>中设置它，如下案例代码所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1649412857515-3bad9652-c5ad-4c79-a8cc-f1d3ebee74ee.png#clientId=u33a1fcc5-9f61-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=158&id=u95100d5f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=552&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93151&status=done&style=none&taskId=u61740690-3bea-462b-a67c-f826f2178f5&title=&width=300" alt="image.png"><br>这样我们就可以在Observatory的Timeline中查看widget build在每一帧中的调用和耗时情况<br><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1649412899577-6777db08-776f-417b-a934-6a8772b46dc0.png#clientId=u33a1fcc5-9f61-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=391&id=ub9fd1e38&margin=%5Bobject%20Object%5D&name=image.png&originHeight=782&originWidth=1212&originalType=binary&ratio=1&rotation=0&showTitle=false&size=680958&status=done&style=none&taskId=u991395f1-4be8-4898-88c3-f310063d31e&title=&width=606" alt="image.png"></p><h4 id="2-自定义Timeline跟踪"><a href="#2-自定义Timeline跟踪" class="headerlink" title="2. 自定义Timeline跟踪"></a>2. 自定义Timeline跟踪</h4><p>要执行自定义性能跟踪和测量Dart任意代码段的wall&#x2F;CPU时间（类似于在Android上使用systrace）。 使用dart:developer的Timeline工具来包含你想测试的代码块，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Timeline.startSync(&#x27;interesting function&#x27;);</span><br><span class="line">// iWonderHowLongThisTakes();</span><br><span class="line">Timeline.finishSync();</span><br></pre></td></tr></table></figure><p>这段代码等同于Android原生端的beginSection和endSection</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Trace.beginSection(&quot;&quot;);</span><br><span class="line">// xxxxx</span><br><span class="line">Trace.endSection();</span><br></pre></td></tr></table></figure><p>然后打开你应用程序的Observatory timeline页面，在”Recorded Streams”中选择’Dart’复选框，并执行你想测量的功能。刷新页面将在Chrome的跟踪工具中显示应用按时间顺序排列的timeline记录。</p><h4 id="3-使用Observatory查看skia绘图指令"><a href="#3-使用Observatory查看skia绘图指令" class="headerlink" title="3. 使用Observatory查看skia绘图指令"></a>3. 使用Observatory查看skia绘图指令</h4><p>使用命令：<code>flutter run --profile --trace-skia</code><br><strong>重点关注saveLayer和clipPath函数的调用</strong></p><h3 id="0x03-skpdebugger"><a href="#0x03-skpdebugger" class="headerlink" title="0x03. skpdebugger"></a>0x03. skpdebugger</h3><p>通过抓取skp，回放每条skia绘图指令的执行过程，可以在屏幕上直观的看到绘制流程的每个步骤，单步分析每一条绘图指令，从而定位在单帧绘制中影响绘制效率的问题。<br><a href="https://player.bilibili.com/player.html?bvid=BV1ab411T7nM">点击查看【bilibili】</a></p><p>使用步骤：</p><ol><li>使用<code>flutter screenshot --type=skia --observatory-uri=uri</code>命令，抓取一帧skia绘图指令的执行过程，截取skp可以单步检测每条绘图指令</li><li>将生成的skp文件上传<a href="https://debugger.skia.org/">https://debugger.skia.org/</a><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4>Android Studio4.1版本更改了插件的安装路径，在Flutter1.23以下，flutter doctor命令可能会找不到AS的flutter&amp;Dart plugin，导致flutter screenshot命令执行失败，这里可使用以下命令解决：<br><code>ln -s ~/Library/Application\ Support/Google/AndroidStudio4.1/plugins ~/Library/Application\ Support/AndroidStudio4.1</code></li></ol><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><ol><li>profile模式是最接近release的性能表现，当需要获取flutter app较为真实的性能评测数据时，要使用profile进行测试。而需要对具体的build paint流程进行详细分析时使用debug模式进行trace</li><li>使用真机，不要使用模拟器，尤其是不要使用iOS的模拟器，模拟器没有硬件加速，所以在模拟器的测试数据和真机的差别会很大</li><li>skpdebugger是神器，通过对单帧绘制指令的采集，可以很清晰的看到在绘制中不合理的部分。针对不合理的绘制进行单帧绘制优化</li><li>重点关注saveLayer和clipPath的调用</li></ol><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.sunmoonblog.com/2020/01/10/flutter-performance-tools/">https://www.sunmoonblog.com/2020/01/10/flutter-performance-tools/</a><br><a href="https://cloud.tencent.com/developer/article/1591997">https://cloud.tencent.com/developer/article/1591997</a><br><a href="https://flutterchina.club/debugging/">https://flutterchina.club/debugging/</a><br><a href="https://flutter.cn/docs/testing/code-debugging">https://flutter.cn/docs/testing/code-debugging</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Flutter官方提供了Flutter DevTools和一些IDE Flutter plugin来辅助开发者进行性能评测，除了这些工具以外，还可以借助Dart和skia引擎提供的工具进行性能分析和调试。这里简单介绍下，Dart的Observatory和Skp Debugger的使用。&lt;/p&gt;</summary>
    
    
    
    <category term="性能优化" scheme="https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="性能优化" scheme="https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="flutter" scheme="https://ivonhoe.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>JDK ServiceLoader加载优化</title>
    <link href="https://ivonhoe.github.io/2022/02/08/java-spi/"/>
    <id>https://ivonhoe.github.io/2022/02/08/java-spi/</id>
    <published>2022-02-08T14:53:51.000Z</published>
    <updated>2022-05-25T16:54:41.175Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录在启动优化项目中解决ServiceLoader加载长耗时问题的方案，介绍了JDK ServiceLoader在安卓平台中会带来哪些问题，方案执行过程中遇到的问题和相应的思考。特别是在一个负责的业务系统中，如何选择技改方案，保证方案的顺利落地。</p><span id="more"></span><h3 id="0x01-什么是Java-SPI？"><a href="#0x01-什么是Java-SPI？" class="headerlink" title="0x01 什么是Java SPI？"></a>0x01 什么是Java SPI？</h3><p>SPI，全称Service Provicer Interface。在JDK1.6内置的一套服务发现机制，主要用来服务架构扩展和替换组件。在面向对象设计中，最基本的原则就是面向接口编程，通过接口暴露模块的功能定义，将具体的接口实现隐藏在模块内部。而服务发现机制，提供了通过接口获取服务实现的能力，实现模块的可插拔、可拓展、可替换。保证了由调用方在调用时选择自己需要的外部实现。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1649403114832-2483028e-558c-40e6-a974-69b7d4b30685.png#clientId=u746e1af0-e590-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=105&id=u40d410af&margin=%5Bobject%20Object%5D&name=image.png&originHeight=202&originWidth=867&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32688&status=done&style=none&taskId=u5cf5c6b2-12bc-49b1-a8cb-8c759cb8427&title=&width=450" alt="image.png"><br />简单来是在利用JDK提供的ServiceLoader机制可以通过以下几个步骤：</p><ol><li>定义接口类</li><li>定义接口实现类</li><li>将实现类的类名保存在<code>META-INFO/services</code>目录中，文件名为接口类的类名</li><li>使用<code>java.util.ServiceLoader.load</code>方法加载接口类，获取到在META-INFO中定义的接口实现类</li></ol><p>在META-INFO中的声明形式大致如下所示：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1649403126452-73a0392d-1725-42f6-bcfb-ec2216ab2682.png#clientId=u746e1af0-e590-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=181&id=u42ebebd2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=228&originWidth=568&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53669&status=done&style=none&taskId=u3551e280-e4e7-42c7-be49-9d9a4f0c643&title=&width=450" alt="image.png"></p><h3 id="0x02-JDK-ServiceLoader存在哪些问题？"><a href="#0x02-JDK-ServiceLoader存在哪些问题？" class="headerlink" title="0x02 JDK ServiceLoader存在哪些问题？"></a>0x02 JDK ServiceLoader存在哪些问题？</h3><h4 id="Autoservice组件解决了什么问题？"><a href="#Autoservice组件解决了什么问题？" class="headerlink" title="Autoservice组件解决了什么问题？"></a>Autoservice组件解决了什么问题？</h4><p>我们经常使用的autoservice（<a href="https://github.com/google/auto">https://github.com/google/auto</a>）解决了什么问题呢？其实autoservice只是提供了注解和注解处理器的能力，通过自定义一个annotationprocessor将<code>@AutoService</code>注解标记的实现类信息，收集起来并保存到<code>META-INFO/services</code>目录中。通过注解的方式将上面的<strong>步骤3</strong>优化掉了，这样既提高了效率，又避免了方案变更时需要手动更新配置文件的问题。</p><h4 id="Android中使用JDK-ServiceLoader会带来什么问题？"><a href="#Android中使用JDK-ServiceLoader会带来什么问题？" class="headerlink" title="Android中使用JDK ServiceLoader会带来什么问题？"></a>Android中使用JDK ServiceLoader会带来什么问题？</h4><p>主要是类配置文件的加载耗时问题。在java项目中，java.util.ServiceLoader通过加载jar文件META-INFO&#x2F;services目录下的配置文件获取实现类信息，当在Android项目中，java.util.ServiceLoader时通过加载apk包目录下META-INFO&#x2F;services中的配置文件，这里都涉及到整个zip文件的遍历，加载效率是非常低的，一般情况下会导致几百毫秒的耗时。而如果在一些关键流程中触发了JDK ServiceLoader的加载，几百毫秒就会带来很差的用户体验。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1649403138515-417e156a-4435-474f-bd85-a2181b2c2510.png#clientId=u746e1af0-e590-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=442&id=udaf30fd2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=883&originWidth=768&originalType=binary&ratio=1&rotation=0&showTitle=false&size=117366&status=done&style=none&taskId=udeffd1ae-b5e7-433b-ba75-f8a384c9daa&title=&width=384" alt="image.png"></p><h3 id="0x03-如何解决JDK-ServiceLoader带来的问题？"><a href="#0x03-如何解决JDK-ServiceLoader带来的问题？" class="headerlink" title="0x03 如何解决JDK ServiceLoader带来的问题？"></a>0x03 如何解决JDK ServiceLoader带来的问题？</h3><p>先梳理现状：</p><ol><li>项目中大量使用了多个改造自autoservice组件的注解处理器，在meta-info目录下生成了多个配置文件</li><li>耗时主要发生在启动流程业务初始化阶段，使用JDK serviceloader加载meta-info下的配置文件导致了长耗时</li></ol><p>ServiceLoader加载耗时过长的主要原因是，需要从zip文件中检索出meta-info目录下的配置文件，想要提升配置加载的效率，解决方法也很简单，可以将配置文件保存到更容易加载的地方，这里可以选择将配置信息保存到安卓原生提供的资源路径下，也可以选择将配置信息保存到类文件中。当然想要在相对复杂的业务系统中解决一个问题，既包括解决技术问题本身，也需要考虑到方案落地的成本和影响面。特别是高业务价值低技术价值的遗产系统中做技术优化，首先保证的是兼容现有业务逻辑。这里优先选择将相关配置信息保存在类文件中，借助android编译插件技术，在编译期间做信息收集，在运行时通过类加载的方式将所需service信息加载出来。这里可以主要参考wmrouter的实现思路，但是又稍有差别。<br />先对比wmrouter的实现方案，可以发现大致可以分为以下几个步骤：</p><ol><li>开发编码流程，定义服务接口，通过注解标记服务实现类</li><li>组件aar发布流程，通过annotationprocessor生成.class的文件，将服务实现的类信息保存在自动生成的.class文件中</li><li>编译打包流程，通过gradle插件收集步骤2中新生成的所有类，因为服务实现可能分布在项目中的多个组件中，所以在apk整包的编译流程，需要将所有服务实现的类信息统一收集起来，并加入到初始化的代码中。</li></ol><p>通过以上流程的说明，可以看到整个流程被分为两步：</p><ol><li>annotationprocessor通过将注解转换成jvm字节码</li><li>通过AGP transform生成初始化代码，将jvm的初始化调用收集起来在初始化时统一调用</li></ol><p>前面也提到，在现有的遗产系统中，如果照搬wmrouter的方案会存在什么问呢？如果照搬上述的方案，在annotationprocessor处理阶段，需要将所有使用autoservice @AutoService的组件使用新的annotationprocessor重新发布一边。<strong>这个工作量和变更范围是巨大的。有没有更优化的方案呢？</strong></p><p>解决思路也很直接，<strong>将注解的收集和配置信息保存到类文件合并成一步。</strong></p><p>通过在AGP transform流程中收集注解，同时使用ASM框架动态生成相关字节码，将相关的实现类信息保存到类文件中。就可以避免重新发布大量业务组件的问题，将变更范围控制到最小。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1649408066234-bc419d60-d2a2-4230-ac9d-5ebeb856d296.png#clientId=u746e1af0-e590-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=632&id=ue4608016&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1264&originWidth=1440&originalType=binary&ratio=1&rotation=0&showTitle=false&size=271359&status=done&style=none&taskId=u863d831e-03aa-411d-80b6-e1e8f26b59c&title=&width=720" alt="image.png"></p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>ServiceLoader带来的性能问题，一旦被发现，解决思路其实是很直接的，并没有太多拐弯的地方。但是在这个技术方案落地的过程中遇到的问题比技术方案本身多很多。特别是在已有大量业务系统在使用的组件中做技改，影响面的评估和回滚方案是要优先被考虑的，所以在运行时加载配置阶段，需要通过配置开关控制是优先加载类信息还是保持原加载流程不变，来做到技改方案可观测可回滚。同时在技术方案的选择上，应该选择影响面尽可能小，变更尽可能少的方案。尽可能避免业务方的更改。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://zhuanlan.zhihu.com/p/28909673">https://zhuanlan.zhihu.com/p/28909673</a><br /><a href="https://github.com/meituan/WMRouter">https://github.com/meituan/WMRouter</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录在启动优化项目中解决ServiceLoader加载长耗时问题的方案，介绍了JDK ServiceLoader在安卓平台中会带来哪些问题，方案执行过程中遇到的问题和相应的思考。特别是在一个负责的业务系统中，如何选择技改方案，保证方案的顺利落地。&lt;/p&gt;</summary>
    
    
    
    <category term="性能优化" scheme="https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="性能优化" scheme="https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="ASM" scheme="https://ivonhoe.github.io/tags/ASM/"/>
    
    <category term="SPI" scheme="https://ivonhoe.github.io/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>访问者模式</title>
    <link href="https://ivonhoe.github.io/2021/03/28/design-patterns-visitor/"/>
    <id>https://ivonhoe.github.io/2021/03/28/design-patterns-visitor/</id>
    <published>2021-03-27T16:19:59.000Z</published>
    <updated>2022-05-25T16:55:11.943Z</updated>
    
    <content type="html"><![CDATA[<p>在实际工作中经常用到访问者模式，是比较常见的设计模式，本文主要通过以下几个方面来学习访问者模式：</p><ol><li>什么是访问者模式，访问者模式想要解决的问题是什么？</li><li>访问者模式的经典应用有哪些?</li></ol><span id="more"></span><h3 id="0x01-单分派和双重分派"><a href="#0x01-单分派和双重分派" class="headerlink" title="0x01 单分派和双重分派"></a>0x01 单分派和双重分派</h3><p>在介绍设计模式之前，先了解几个基础的概念。了解概念的含义并不是为了咬文嚼字，而是希望能从原理上理解设计模式背后想要解决的问题</p><h4 id="重写（override）和重载（overload）"><a href="#重写（override）和重载（overload）" class="headerlink" title="重写（override）和重载（overload）"></a>重写（override）和重载（overload）</h4><ul><li>重写，就是子类重写了父类的方法，返回值和形参都不能改变。当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。</li><li>重载，在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li></ul><h4 id="单分派和双重分派"><a href="#单分派和双重分派" class="headerlink" title="单分派和双重分派"></a>单分派和双重分派</h4><ul><li>分派（Dispatch），在面向对象的语言中，可以把一次函数调动理解成一个消息事件的分发，如<code>a.test(b)</code>，a就是消息的接受者，这个函数的调用方就是消息的发送者。</li><li>单分派（Single Dispatch），这里的单（Single）指的是，哪个对象的方法会被执行，只跟这个对象的运行时类型有关。以<code>a.test(b)</code>为例，如在Java中，在被执行的test函数，只跟a对象的运行时类型有关。</li><li>双重分派(Double Dispatch)，这里的双（double）指的是，哪个对象的方法被执行，跟对象和方法参数的运行时类型都有关。还是以<code>a.test(b)</code>为例，哪个test函数被执行，不单单和a对象的类型有关还和b对象的类型有关。</li></ul><p>可以看到所谓分派就是函数的调用，所谓单分派和双分派就是和语言的多态特性有关，在常见的Java，C++，C#语言中，在语言层面都是只支持单分派的。想要实现双重分派，就要借助设计模式，比如访问者模式。你肯定会问，双重分派的作用是什么？不解决双重分派的问题不行吗？其实这种问题在项目代码中一定俯拾皆是，类似下面的这种代码，我们想要针对不同类型的文件（pdf，ppt，word）执行不同的文件提取和文件压缩操作。试想下，可能是你来实现，你要怎么做？是不是很容易写出下面这样的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Extractor extends Processor &#123;</span><br><span class="line">void processFile(ResourceFile file) &#123;</span><br><span class="line">    if (file instanceof PdfFile) &#123;</span><br><span class="line">        processPrdFile((PdfFile)file);</span><br><span class="line">    &#125; else if (file instanceof PowerPointFile) &#123;</span><br><span class="line">        processPowerPointFile((PowerPointFile)e);</span><br><span class="line">    &#125; else if (file instanceof WordFile) &#123;</span><br><span class="line">        processWordFile((WordFile)e);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Compressor extends Processor &#123;</span><br><span class="line">void processFile(ResourceFile file) &#123;</span><br><span class="line">    if (file instanceof PdfFile) &#123;</span><br><span class="line">        processPrdFile((PdfFile)file);</span><br><span class="line">    &#125; else if (file instanceof PowerPointFile) &#123;</span><br><span class="line">        processPowerPointFile((PowerPointFile)e);</span><br><span class="line">    &#125; else if (file instanceof WordFile) &#123;</span><br><span class="line">        processWordFile((WordFile)e);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这段代码的逻辑执行，既要根据接收者的运行时类型来决定<code>processXXXFile(file)</code>的执行，这里的接收者可以理解成是当前方法所对应的<code>Processor</code>对象。又要根据<code>ResourceFile file</code>对象的运行时的实际类型来做类型的判断，这里就会有很多<code>instanceof</code>和<code>else if</code>,<code>switch case</code>的多重嵌套。这种设计的代码虽然可以实现功能，但是在面对需求变更和扩展时会非常不灵活，既要加很多<code>else if</code>，也不利于功能的内聚和复用。那么这些代码如果用访问者模式，应该怎么来实现呢？这里借用王争在&lt;&lt;设计模式之美&gt;&gt;中的实例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ResourceFile &#123;</span><br><span class="line">  protected String filePath;</span><br><span class="line">  public ResourceFile(String filePath) &#123;</span><br><span class="line">    this.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  abstract public void accept(Visitor vistor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PdfFile extends ResourceFile &#123;</span><br><span class="line">  public PdfFile(String filePath) &#123;</span><br><span class="line">    super(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void accept(Visitor visitor) &#123;</span><br><span class="line">    visitor.visit(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span><br><span class="line"></span><br><span class="line">public interface Visitor &#123;</span><br><span class="line">  void visit(PdfFile pdfFile);</span><br><span class="line">  void visit(PPTFile pdfFile);</span><br><span class="line">  void visit(WordFile pdfFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Extractor implements Visitor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PPTFile pptFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Extract PPT.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PdfFile pdfFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Extract PDF.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(WordFile wordFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Extract WORD.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Compressor implements Visitor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PPTFile pptFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Compress PPT.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PdfFile pdfFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Compress PDF.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(WordFile wordFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Compress WORD.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ToolApplication &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);</span><br><span class="line"></span><br><span class="line">    Extractor extractor = new Extractor();</span><br><span class="line">    for (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(extractor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Compressor compressor = new Compressor();</span><br><span class="line">    for(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(compressor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();</span><br><span class="line">    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br><span class="line">    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));</span><br><span class="line">    resourceFiles.add(new WordFile(&quot;b.word&quot;));</span><br><span class="line">    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));</span><br><span class="line">    return resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x02-ASM中的访问者模式"><a href="#0x02-ASM中的访问者模式" class="headerlink" title="0x02 ASM中的访问者模式"></a>0x02 ASM中的访问者模式</h3><p>上面介绍了访问者模式设计初衷和设计方法，这里再看下访问者模式在实际工程中的应用。访问者模式最常见的应用场景就是访问复杂的结构或者对象，在不改变数据结构的情况下，将数据访问和数据操作分离出来，用回调的方式在访问者中处理业务逻辑。在面对不同的访问处理时，只需要新定义一个访问者实现不同的访问处理逻辑就可以了。这样说可能也很抽象，可以在在ASM中，是如何利用访问者的设计模式，实现字节码文件的读取和修改的。<br />ASM使用ClassReader遍历class文件结构获取文件中的类和对象信息，在其accept方法中接收ClassVisitor，在ClassVisitor的不同回调方法中完成不同的字节码操作。可以通过代码示例看到主要有以下几个类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassReader cr = new ClassReader(inputStream);</span><br><span class="line">ClassWriter cw = new ClassWriter(cr, 0);</span><br><span class="line"></span><br><span class="line">ClassVisitor cv = new InjectCassVisitor(ASM6, cw, methodName);</span><br><span class="line">cr.accept(cv, 0);</span><br><span class="line">return cw.toByteArray();</span><br></pre></td></tr></table></figure><ul><li>ClassReader（Element）：将不同输入类型的字节码读取到内存中，通过accept方法接受ClassVisitor的访问。</li><li>ClassVisitor（Visitor）：完全由开发者自定义不同类型的Visitor，在Visitor的visitXXX回调中接收读取到的字节码信息并进行相应的处理。</li></ul><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>利用访问者模式来解决这样的双重分派问题，如上面的类图所示，通过几个角色来做功能的区分，将文件的访问和处理分离成两个独立的接口。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1648478340921-52d95fa8-489f-4098-b1c7-f86c7337fe4f.png#clientId=u9509d57c-feb4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=390&id=rpEg9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=780&originWidth=830&originalType=binary&ratio=1&rotation=0&showTitle=false&size=134454&status=done&style=none&taskId=u9699865e-5f29-4b7e-a0e9-4eee905c3bd&title=&width=415" alt="image.png"></p><ul><li><strong>访问者（Visitor）</strong>，这里指不同类型的文件操作。用一个接口和一组不同类型的具体实现来定义不同的操作类型。</li><li><strong>被访问者（Element）</strong>，这里指不同类型的文件。定义了accept操作，以Visitor作为参数，来接受不同类型visitor的对象访问。在accept方法中将this传递给访问者，通过回调再回调的操作，实现了双重分派。</li><li><strong>对象结构（ObjectStructure）</strong>，访问的组织者，可以是组合也可以是集合；能够枚举它包含的元素；提供一个接口，允许Vistor访问它的元素。</li></ul><p><strong>理解访问者模式的设计，我觉得重点在理解所谓的回调再回调。这里有两次回调就意味着有两种类型接口，第一次回调是被访问者通过accept接受访问者，第二次回调是访问者通过visit方法访问被访问者，通过两次互相调换类型的调用，也就是通过两次单分派实现了双重分派。</strong></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>王争&lt;&lt;设计模式之美&gt;&gt;<br /><a href="https://www.jianshu.com/p/cd17bae4e949">https://www.jianshu.com/p/cd17bae4e949</a><br /><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319659110433">https://www.liaoxuefeng.com/wiki/1252599548343744/1281319659110433</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在实际工作中经常用到访问者模式，是比较常见的设计模式，本文主要通过以下几个方面来学习访问者模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是访问者模式，访问者模式想要解决的问题是什么？&lt;/li&gt;
&lt;li&gt;访问者模式的经典应用有哪些?&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="方案与设计" scheme="https://ivonhoe.github.io/categories/%E6%96%B9%E6%A1%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="设计模式" scheme="https://ivonhoe.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://ivonhoe.github.io/2021/03/28/design-patterns-proxy/"/>
    <id>https://ivonhoe.github.io/2021/03/28/design-patterns-proxy/</id>
    <published>2021-03-27T16:19:47.000Z</published>
    <updated>2022-07-11T16:04:32.025Z</updated>
    
    <content type="html"><![CDATA[<p>其实在日常生活中我们经常和代理模式打交道，比如当我们需要预定酒店时，我们（使用方）通常选择类似携程这样的平台来进行酒店和机票的预定，这里携程（代理）就代理了和酒店（服务提供方）之间的预订流程，使用方通过代理实现了和真实服务提供者之间的操作，那么为什么会使用代理而不是直接和服务提供方进行业务操作呢？可以通过以下两方面来考量：</p><ol><li>代理提高了扩展性。以订酒店为例，乘客可以通过代理类（携程）调用不同类型的服务(不同酒店)实现。</li><li>代理降低了替换成本。实现了代理类提供的服务和实际业务服务的解耦，降低了服务替换的成本。还是以订酒店为例，让用户只需要关注到订酒店这件事情，和订酒店无关的其他事情都由代理商来做了。</li></ol><span id="more"></span><h5 id="什么是「代理模式」？"><a href="#什么是「代理模式」？" class="headerlink" title="什么是「代理模式」？"></a>什么是「代理模式」？</h5><p>代理控制了对象的真实访问。代理模式是指，在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。<strong>主要解决在直接访问对象时带来的问题</strong>，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。<br />这里直接访问对象时带来的问题，可以类比上面生活中的例子，车站买票太远（对象单次访问成本高）选择用代买点买票。直接去酒店订房间太麻烦（实现功能的对象太多无法直接选择出最佳的对象）而选择在酒店平台预定酒店。</p><h3 id="0x01-Binder中的静态代理"><a href="#0x01-Binder中的静态代理" class="headerlink" title="0x01 Binder中的静态代理"></a>0x01 Binder中的静态代理</h3><p>几乎所有安卓开发应该都应该知道，binder是android中实现进程间通信的方案，也都听说过所谓共享内存、Socket、管道、消息队列等等一系列其他的进程间通信（IPC）的方案，甚至听说过诸如dubbo，spring cloud之类的远程过程调用（RPC）。这里binder作为一个IPC方案同时在设计上又有很多RPC方案的影子，如果说想要理解RPC，<strong>这里一定绕不开代理模式</strong>。不管是Android的binder还是后端消息中间件dubbo都是使用代理模式来做设计的，在通讯的两端分别用代理隐藏实际的通信细节，让调用方像调用自己进程内对象方法一样实现对跨进程对象的调用。你比较熟悉组件化开发的话，也可以先从组件化的视角来类比binder通信，如果让你来实现一个进程间通信的架构方案，有哪些东西是必不可少的呢？</p><p><strong>先类比组件化</strong></p><ol><li><strong>面向接口的设计</strong>，组件间通信，通过接口暴露组件能力</li><li><strong>通过一个manager查询接口对应的服务实例</strong>，组件间相互调用，意味着组件间能够通过某种方式获取定义的组件接口所对应的实例对象，实现调用其他组件的方法就像调用自己内部方法一样</li><li><strong>服务的注册和查询</strong>，想要获取响应的接口实现，意味着有一个类似路由和路由表的东西，通过一个路由服务查询到具体的接口实现对象</li><li>其他高性能、安全性、稳定性的设计</li></ol><p><strong>再看Binder IPC</strong>，</p><ol><li>开发者使用AIDL实现进程间通信接口的定义</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IMyAidlInterface &#123;</span><br><span class="line">    Response aidlGet(in Request request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用者client通过context bindService获取远程服务的代理对象，通过<code>queryLocalInterface</code>和<code>Stub.DESCRIPTOR</code>查询到远程服务在client的代理对象</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static com.android.aidldemo.IMyAidlInterface asInterface(android.os.IBinder obj) &#123;</span><br><span class="line">    if ((obj == null)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    if (((iin != null) &amp;&amp; (iin instanceof com.android.aidldemo.IMyAidlInterface))) &#123;</span><br><span class="line">        return ((com.android.aidldemo.IMyAidlInterface) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    return new com.android.aidldemo.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>对client来说，Binder代理对象<code>Stub.proxy</code>隐藏了和远程服务对象真实通信的细节，client不需要关心这个代理对象是不是真实的服务实现方，就像调用本地方法一样调用原生服务对象。而<code>Stub.proxy</code>实现了调用参数的序列化和响应结果的序列化，帮助client拿到了远程调用的结果。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1648478466765-f2a0a569-415d-4c4e-90ba-3ea37b20bce8.png#clientId=udd0e86b6-737e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=262&id=ua9bbe8f6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=524&originWidth=627&originalType=binary&ratio=1&rotation=0&showTitle=false&size=232289&status=done&style=none&taskId=u7c80ef72-e3a2-46df-a9bb-1272ff293d5&title=&width=313.5" alt="image.png"></li></ol><p>可以对照下图理解代理过程：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1648478479146-a37ec35d-b206-4228-bd82-35cc36736701.png#clientId=udd0e86b6-737e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=260&id=u06c52024&margin=%5Bobject%20Object%5D&name=image.png&originHeight=520&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=243389&status=done&style=none&taskId=u3048a8ed-2f97-4f4e-beb2-4f3da2acc86&title=&width=500" alt="image.png"></p><p>同样的角色分布我们可以再看看系统的ActivityManagerService。IActivityManager是一个服务接口，代表了服务能力。ActivityManagerNative代表系统本地服务，ActivityManagerService是它的具体实现。而ActivityMangerProxy代表在app中的Binder代理对象，实现client到service调用的代理转发。</p><h3 id="0x02-Retrofit中的动态代理"><a href="#0x02-Retrofit中的动态代理" class="headerlink" title="0x02 Retrofit中的动态代理"></a>0x02 Retrofit中的动态代理</h3><p>相比较Binder的静态代理，retrofit使用了动态代理模式。所谓动态代理模式，是指并没有手动创建一个代理类，而是使用动态字节码的方式创建代理类（用class生成class），然后使用反射的方式创建代理类的对象，再使用反射方式调用被代理的方法。可以先看一个在java中最简单的动态代理写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TestProxy &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Subject subject = new RealSubject();</span><br><span class="line"></span><br><span class="line">        InvocationHandler handler = new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                Object result = null;</span><br><span class="line">                //在调用具体函数方法前，执行功能处理</span><br><span class="line">                result = method.invoke(subject, args);</span><br><span class="line">                //在调用具体函数方法后，执行功能处理</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Subject object = (Subject) Proxy.newProxyInstance(subject.getClass().getClassLoader(),</span><br><span class="line">                subject.getClass().getInterfaces(), handler);</span><br><span class="line">        object.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>Proxy.newProxyInstance</code>和<code>InvocationHandler</code>动态构造代理对象，通过获取invoke method注解对请求的描述信息，生成<code>ServiceMethod</code>对象，并根据该对象执行相应的网络请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">validateServiceInterface(service);</span><br><span class="line">return (T)</span><br><span class="line">    Proxy.newProxyInstance(</span><br><span class="line">        service.getClassLoader(),</span><br><span class="line">        new Class&lt;?&gt;[] &#123;service&#125;,</span><br><span class="line">        new InvocationHandler() &#123;</span><br><span class="line">          private final Platform platform = Platform.get();</span><br><span class="line">          private final Object[] emptyArgs = new Object[0];</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)</span><br><span class="line">              throws Throwable &#123;</span><br><span class="line">            // If the method is a method from Object then defer to normal invocation.</span><br><span class="line">            if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              return method.invoke(this, args);</span><br><span class="line">            &#125;</span><br><span class="line">            args = args != null ? args : emptyArgs;</span><br><span class="line">            return platform.isDefaultMethod(method)</span><br><span class="line">                ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                : loadServiceMethod(method).invoke(args);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1648478503438-ecd40a20-c673-4c8f-a9af-3193342b78b5.png#clientId=udd0e86b6-737e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=uc7b7bc1e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=302&originWidth=538&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66420&status=done&style=none&taskId=u15f526ec-58a7-4fc5-a6c3-09d54bdcc7f&title=&width=402" alt="image.png"></p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>这里借用知乎大佬的一张图，同时对比下静态代理和动态代理的差异，主要在于代理类如何生成。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/411436/1648478510603-6db1c76d-0efa-4d68-927e-50d801a4b26c.png#clientId=udd0e86b6-737e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=127&id=uab5d01e8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=201&originWidth=734&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81824&status=done&style=none&taskId=ubd716343-6f89-4764-accd-b30b31c4719&title=&width=463" alt="image.png"></p><p>如果是编译或者编码过程中生成的代理类就是静态代理，所以静态代理的一个缺点就是会生成很多代理类。<br />如果在运行时或者编译时动态生成的代理类，一般就是动态代理。可以通过接口的Class对象，创建一个代理Class，通过代理Class创建代理对象。也就是所谓的用Class造Class。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://weishu.me/2016/01/12/binder-index-for-newer/">http://weishu.me/2016/01/12/binder-index-for-newer/</a><br /><a href="https://zhuanlan.zhihu.com/p/35519585">https://zhuanlan.zhihu.com/p/35519585</a><br /><a href="http://gityuan.com/2016/09/04/binder-start-service/">http://gityuan.com/2016/09/04/binder-start-service/</a><br /><a href="https://www.zhihu.com/question/20794107">https://www.zhihu.com/question/20794107</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实在日常生活中我们经常和代理模式打交道，比如当我们需要预定酒店时，我们（使用方）通常选择类似携程这样的平台来进行酒店和机票的预定，这里携程（代理）就代理了和酒店（服务提供方）之间的预订流程，使用方通过代理实现了和真实服务提供者之间的操作，那么为什么会使用代理而不是直接和服务提供方进行业务操作呢？可以通过以下两方面来考量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代理提高了扩展性。以订酒店为例，乘客可以通过代理类（携程）调用不同类型的服务(不同酒店)实现。&lt;/li&gt;
&lt;li&gt;代理降低了替换成本。实现了代理类提供的服务和实际业务服务的解耦，降低了服务替换的成本。还是以订酒店为例，让用户只需要关注到订酒店这件事情，和订酒店无关的其他事情都由代理商来做了。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="方案与设计" scheme="https://ivonhoe.github.io/categories/%E6%96%B9%E6%A1%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="设计模式" scheme="https://ivonhoe.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="https://ivonhoe.github.io/2021/03/28/design-patterns-chain-of-responsibility/"/>
    <id>https://ivonhoe.github.io/2021/03/28/design-patterns-chain-of-responsibility/</id>
    <published>2021-03-27T16:19:30.000Z</published>
    <updated>2022-05-25T16:55:22.600Z</updated>
    
    <content type="html"><![CDATA[<p>说到责任链模式一定会想到各种拦截器，在很多框架中都有拦截器的使用，如常见的okhttp中的请求处理拦截器，路由框架中的路由拦截器，作为框架的使用方你可能已经对拦截器司空见惯，但是不可否认的是一个好的设计经常会有让人有眼前一亮的感觉。本文尝试总结一下在安卓框架和源码中，责任链模式的使用场景和设计方法。</p><span id="more"></span><h3 id="0x01-什么是责任链模式"><a href="#0x01-什么是责任链模式" class="headerlink" title="0x01 什么是责任链模式"></a>0x01 什么是责任链模式</h3><p>从设计模式的角度，拦截器的设计常常称之为责任链模式（Chain of Responsibility）。责任链模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/411436/1648398302641-53549587-8264-4f7d-8887-9f21106dcda2.jpeg#clientId=u546672ae-3373-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6a2fa50d&margin=%5Bobject%20Object%5D&originHeight=178&originWidth=650&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udaad9ee6-1deb-4453-9855-3ef259e2663&title="></p><p>责任链模式的优点：</p><ol><li>降低耦合，不需要知道整条处理链路的结构，发送者和接受者也无需知道对方的确切信息。</li><li>灵活，扩展性强，可根据需要灵活增加处理流程，可动态调整处理顺序</li><li>功能内聚，单一职责，每个类只需要关注自己处理的工作，不该处理的传递给下一个对象处理</li></ol><p>责任链模式的缺点：</p><ol><li>复杂度较高，性能可能受影响</li><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。<h3 id="0x02-okhttp中的阑尾式拦截器"><a href="#0x02-okhttp中的阑尾式拦截器" class="headerlink" title="0x02 okhttp中的阑尾式拦截器"></a>0x02 okhttp中的阑尾式拦截器</h3>在RealCall.java中内置了5个拦截器。创建一个包含所有拦截器的拦截器链表。在RealInterceptorChain的proceed方法中根据index获取当前拦截器，在拦截器的intercept方法内部递归调用RealInterceptorChain的proceed方法并将index+1，更新到下一个拦截器。这里需要注意的是，最后一个拦截器的实现，在最后一个拦截器CallServerInterceptor中，并不会再调用Chain的proceed方法，而是直接根据网络结果返回response。这里可以看做整个拦截器的尽头，在胡同走到尽头后再根据原路逐级返回response。所以像是走进胡同的拦截器调用算不算半截阑尾？</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/411436/1648398302704-d3aca097-09b8-48c1-8243-dc248a4374a5.jpeg#clientId=u546672ae-3373-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u831a5098&margin=%5Bobject%20Object%5D&originHeight=136&originWidth=994&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u22c7f9be-1c91-412b-b71d-9000a851439&title="></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/// 拦截器起点和终点</span><br><span class="line">  Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">    // Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">        originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/// 拦截器迭代</span><br><span class="line">  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">      RealConnection connection) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    // Call the next interceptor in the chain.</span><br><span class="line">    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/// 单个拦截器递归回调到拦截器链</span><br><span class="line">public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    Response networkResponse = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span><br><span class="line">      if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="0x03-wmrouter中的洋葱式拦截器"><a href="#0x03-wmrouter中的洋葱式拦截器" class="headerlink" title="0x03 wmrouter中的洋葱式拦截器"></a>0x03 wmrouter中的洋葱式拦截器</h3><p>和okhttp的拦截器相比，wmrouter中的拦截器差异在于他并没有response返回值，拦截器之间通过callback的方式返回结果或中断拦截流程。个人理解主要有以下几点考虑。</p><ul><li>并不需要像okhttp那样针对队尾的拦截器做特殊实现，所有拦截器的实现只要考虑是next还是complete即可。这样拦截器组合和嵌套更灵活。</li><li>支持异步拦截回调</li></ul><p>wmrouter在查找路由的过程中，使用了多层UriHandler和Interceptor嵌套的拦截器，在UriHandler的handle方法中，通过shouldHandle是否被当前的Handler拦截，再通过是否包含拦截器来确定是handler拦截还是Interceptor拦截，如果是Interceptor拦截则进入下一层。<br />所以相比较okhttp的拦截器，wmrouter的拦截器模式分层更明显，更像洋葱。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void handle(@NonNull final UriRequest request, @NonNull final UriCallback callback) &#123;</span><br><span class="line">    if (shouldHandle(request)) &#123;</span><br><span class="line">        if (mInterceptor != null &amp;&amp; !request.isSkipInterceptors()) &#123;</span><br><span class="line">            mInterceptor.intercept(request, new UriCallback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onNext() &#123;</span><br><span class="line">                    handleInternal(request, callback);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onComplete(int result) &#123;</span><br><span class="line">                    callback.onComplete(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            handleInternal(request, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        callback.onNext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ChainedInterceptor中根据递归调用next方法更新拦截器迭代，通过Callback回溯到上一层，这里的上一层可能是Interceptor也可能是UriHandler。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void next(@NonNull final Iterator&lt;UriInterceptor&gt; iterator, @NonNull final UriRequest request,</span><br><span class="line">                  @NonNull final UriCallback callback) &#123;</span><br><span class="line">    if (iterator.hasNext()) &#123;</span><br><span class="line">        UriInterceptor t = iterator.next();</span><br><span class="line">        t.intercept(request, new UriCallback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onNext() &#123;</span><br><span class="line">                next(iterator, request, callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete(int resultCode) &#123;</span><br><span class="line">                callback.onComplete(resultCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        callback.onNext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以参照下图理解<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/411436/1648398302774-14a9605a-d187-483a-8b3b-6cf65e1f76c2.jpeg#clientId=u546672ae-3373-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1e4e8e96&margin=%5Bobject%20Object%5D&originHeight=523&originWidth=776&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u80dad5bb-5729-48e5-a0a7-fb999b1bb57&title="></p><p>可以参照wmrouter官方文档的流程图理解ChainedHandler和ChainedInterceptor的多层嵌套关系。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/411436/1648398302816-401efc0f-4e41-4d3f-ae15-b91933573d76.jpeg#clientId=u546672ae-3373-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udb6dcb82&margin=%5Bobject%20Object%5D&originHeight=1000&originWidth=825&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u56434ba8-f55e-4ca8-bf00-7bb5120444c&title="></p><h3 id="0x04-Touch事件分发的贪食蛇拦截"><a href="#0x04-Touch事件分发的贪食蛇拦截" class="headerlink" title="0x04 Touch事件分发的贪食蛇拦截"></a>0x04 Touch事件分发的贪食蛇拦截</h3><p>你一定看过类似这样的事件分发流程图（出自<a href="https://www.gcssloop.com/customview/dispatch-touchevent-theory%EF%BC%89%EF%BC%9A">https://www.gcssloop.com/customview/dispatch-touchevent-theory）：</a><br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/411436/1648398302722-3e24c274-1333-4eb0-8726-eba1f7eeacd2.jpeg#clientId=u546672ae-3373-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9dd305b3&margin=%5Bobject%20Object%5D&originHeight=746&originWidth=850&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua3485184-b498-477f-9a87-ecc583dbfd0&title="></p><p>在touch分发的流程中三个关键的方法，dispatchTouchEvent()，interceptTouchEvent(),touchEvent()分别代表事件分发，事件拦截，事件消费。你也一定听过所谓的U型事件传递路径，从Activity开始分发，到ViewGroup，再到View。根据方法返回值是true还是false来决定上述的三个方法是否分发、拦截或消费touch事件。参考如下伪代码理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    // 默认状态为没有消费过</span><br><span class="line">    boolean result = false;             </span><br><span class="line"></span><br><span class="line">    if (!onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">        // 如果没有拦截就直接分发给子View</span><br><span class="line">        result = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!result) &#123;</span><br><span class="line">        // 如果事件没有子View消费或者是被自己拦截了,询问自身onTouchEvent</span><br><span class="line">        result = onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果从责任链的角度来看，你是否想过<strong>在整个事件分发的流程中，整套机制的最终目标是什么？</strong></p><ul><li>其实事件分发的目标，是为了找到负责消费整个touch流程的view。这里的touch流程包含了DOWN、MOVE和UP事件。而CANCEL事件可以理解成一个error信号，只有当子视图消费的前驱事件，但是又被拦截了当前的事件才会收到CANCEL类型的事件。</li><li>一次触摸流程中产生事件应被同一 View 消费，全部接收或者全部拒绝。</li><li>所以才有了所谓的只有消费了DOWN事件才会接受MOVE和UP事件这样的分发规则。可以想象成一条由DOWN、MOVE和UP事件组成的贪食蛇。蛇身和蛇尾的运动是根据蛇头来的。事件分发机制先找到DOWN事件的消费者，再根据DOWN事件的touchTarget，将MOVE和UP事件分发下去。</li><li>所谓的U型传递，从ViewGroup到View，再从View到ViewGroup的事件传递，只可能是DOWN类型的事件</li></ul><p><strong>当parent和child同时设置了click事件监听，为什么是child优先响应？</strong><br />因为click事件是在onTouchEvent中响应的，而onTouchEvent的消费顺序是先child后parent，当view设置了touchListener或者是clickListener，事件就会被view拦截</p><h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><ul><li>责任链在设计实现上，往往通过链表或者递归调用的方式，将请求或事件依次从头结点向下传递，并回溯</li><li>在责任链的任意节点上，都可以根据情况决定是否终止在责任链上的事件传递，okhttp通过抛异常的方式终止，wmroutor通过callback依次退栈</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://c.biancheng.net/view/1383.html">http://c.biancheng.net/view/1383.html</a><br /><a href="https://www.debug8.com/javascript/t_66952.html">https://www.debug8.com/javascript/t_66952.html</a><br /><a href="https://segmentfault.com/a/1190000012227736">https://segmentfault.com/a/1190000012227736</a><br /><a href="https://www.gcssloop.com/customview/dispatch-touchevent-theory">https://www.gcssloop.com/customview/dispatch-touchevent-theory</a><br /><a href="https://blog.csdn.net/lfdfhl/article/details/50707724">https://blog.csdn.net/lfdfhl/article/details/50707724</a> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;说到责任链模式一定会想到各种拦截器，在很多框架中都有拦截器的使用，如常见的okhttp中的请求处理拦截器，路由框架中的路由拦截器，作为框架的使用方你可能已经对拦截器司空见惯，但是不可否认的是一个好的设计经常会有让人有眼前一亮的感觉。本文尝试总结一下在安卓框架和源码中，责任链模式的使用场景和设计方法。&lt;/p&gt;</summary>
    
    
    
    <category term="方案与设计" scheme="https://ivonhoe.github.io/categories/%E6%96%B9%E6%A1%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="设计模式" scheme="https://ivonhoe.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>升级AndroidX遇到的问题</title>
    <link href="https://ivonhoe.github.io/2020/05/17/update-androidx-exception/"/>
    <id>https://ivonhoe.github.io/2020/05/17/update-androidx-exception/</id>
    <published>2020-05-16T18:44:51.000Z</published>
    <updated>2022-05-25T16:49:48.880Z</updated>
    
    <content type="html"><![CDATA[<p>记录在升级AndroidX时遇到的一个问题，仅供参考。</p><span id="more"></span><h3 id="0x01-问题描述"><a href="#0x01-问题描述" class="headerlink" title="0x01 问题描述"></a>0x01 问题描述</h3><p>在项目中升级AndroidX时遇到一个运行时异常，查看日志可了解到是因为找不到方法<code>addOnTabSelectedListener</code>，异常堆栈如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">E  Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">E      at java.lang.reflect.Constructor.newInstance0(Native Method)</span><br><span class="line">E      at java.lang.reflect.Constructor.newInstance(Constructor.java:343)</span><br><span class="line">E      at android.view.LayoutInflater.createView(LayoutInflater.java:658)</span><br><span class="line">E      at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:801)</span><br><span class="line">E      at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:741)</span><br><span class="line">E      at android.view.LayoutInflater.rInflate(LayoutInflater.java:874)</span><br><span class="line">E      at android.view.LayoutInflater.rInflateChildren(LayoutInflater.java:835)</span><br><span class="line">E      at android.view.LayoutInflater.inflate(LayoutInflater.java:515)</span><br><span class="line">E      at android.view.LayoutInflater.inflate(LayoutInflater.java:423)</span><br><span class="line">E      at android.view.LayoutInflater.inflate(LayoutInflater.java:374)</span><br><span class="line">E      at com.android.internal.policy.PhoneWindow.setContentView(PhoneWindow.java:498)</span><br><span class="line">E      at com.android.internal.policy.HwPhoneWindow.setContentView(HwPhoneWindow.java:342)</span><br><span class="line">E      at android.app.Activity.setContentView(Activity.java:2941)</span><br><span class="line">E      at xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">E      at android.app.Activity.performCreate(Activity.java:7458)</span><br><span class="line">E      at android.app.Activity.performCreate(Activity.java:7448)</span><br><span class="line">E      at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1286)</span><br><span class="line">E      at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3409)</span><br><span class="line">E      at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3614)</span><br><span class="line">E      at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:86)</span><br><span class="line">E      at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:108)</span><br><span class="line">E      at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:68)</span><br><span class="line">E      at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2199)</span><br><span class="line">E      at android.os.Handler.dispatchMessage(Handler.java:112)</span><br><span class="line">E      at android.os.Looper.loop(Looper.java:216)</span><br><span class="line">E      at android.app.ActivityThread.main(ActivityThread.java:7625)</span><br><span class="line">E      at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">E      at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:524)</span><br><span class="line">E      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:987)</span><br><span class="line">E  Caused by: java.lang.NoSuchMethodError: No virtual method addOnTabSelectedListener(Lcom/google/android/material/tabs/TabLayout$OnTabSelectedListener;)V in class Lcom/google/android/material/tabs/TabLayout; or its super classes (declaration of &#x27;com.google.android.material.tabs.TabLayout&#x27; appears in /data/app/xxxxxx-WbxmUkjqMEjNknQppPqeWw==/base.apk!classes2.dex)</span><br></pre></td></tr></table></figure><h3 id="0x02-问题分析"><a href="#0x02-问题分析" class="headerlink" title="0x02 问题分析"></a>0x02 问题分析</h3><p>因为从support27到support28版本，TabLayout的API发生了变更，<code>addOnTabSelectedListener</code>方法入参发生了变化，可通过查看下图中的函数字节码可以看到，AndroidX中的该函数的入参为<code>BaseOnTabSelectedListener</code>，而support27中的该函数的入参为<code>onTabSelectedListener</code>。函数字节码如下：</p><p><img src="/res/update_androidx_exceptiion/1.png"><br><img src="/res/update_androidx_exceptiion/2.png"></p><p>发生改问题的原因是AndroidX是基于Support Library 28的重构。而在当前项目中依赖了27.0.2的TabLayout support包，并在依赖support27的基础上使用进行了AndroidX包名替换转换。所以在动手之前还是建议先把官方看清楚，在官方文档里说的很清楚了，要先把当前的 Support Library 依赖升级至版本28，然后再使用Android Studio的工具转换AndroidX。</p><h3 id="0x03-函数签名"><a href="#0x03-函数签名" class="headerlink" title="0x03 函数签名"></a>0x03 函数签名</h3><h4 id="3-1-先写个demo"><a href="#3-1-先写个demo" class="headerlink" title="3.1 先写个demo"></a>3.1 先写个demo</h4><p>demo说明：</p><ul><li>接口A声明接口方法<code>methodA</code></li><li>接口B继承A</li><li><code>methodTest</code>声明的函数参数为接口A</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class TestMethod &#123;</span><br><span class="line">    void invokeTest() &#123;</span><br><span class="line">        methodTest(new AbsClassB() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void methodA() &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void methodTest(AbsClassA a) &#123;</span><br><span class="line">        System.out.print(&quot;-------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface AbsClassB extends AbsClassA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface AbsClassA &#123;</span><br><span class="line">    void methodA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译以上Java代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;TestMethod.java&quot;</span><br><span class="line">class TestMethod &#123;</span><br><span class="line">  TestMethod();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  void invokeTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: new           #2                  // class TestMethod$1</span><br><span class="line">       4: dup</span><br><span class="line">       5: aload_0</span><br><span class="line">       6: invokespecial #3                  // Method TestMethod$1.&quot;&lt;init&gt;&quot;:(LTestMethod;)V</span><br><span class="line">       9: invokevirtual #4                  // Method methodTest:(LAbsClassA;)V</span><br><span class="line">      12: return</span><br><span class="line"></span><br><span class="line">  void methodTest(AbsClassA);</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #6                  // String -------</span><br><span class="line">       5: invokevirtual #7                  // Method java/io/PrintStream.print:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>由以上可知，所谓的方法签名至于函数定义时声明的参数类型有关，和调用时传递的参数类型无关。</strong></p><h4 id="3-2-什么是函数签名？"><a href="#3-2-什么是函数签名？" class="headerlink" title="3.2 什么是函数签名？"></a>3.2 什么是函数签名？</h4><p>方法签名为了唯一标识一个方法。如果你查询一些资料和文档可能会得到下面的说法：<br><strong>说法一：</strong><br>同一类中不能存在两个名字及描述符完全相同的方法。<br>在Java中方法签名包括：方法名、形参参数列表、泛型方法类型参数列表。Java的方法签名并不包括返回值和访问修饰符。当类中存在签名相同的两个方法时编译会报错，当两个方法的其中一个签名是另一个方法的子签名时也会报错。自签名的定义是一个签名在类型擦除后与另一个签名相同，则称其为第二个签名的的子签名。</p><p><strong>说法二：</strong><br>在同一class文件中，两个方法可以拥有同样的特征签名，前提是返回值不能相同。</p><p><strong>这看起来是自相矛盾的啊，到底一个函数签名包不包含方法的返回值类型呢？</strong></p><p>如下面所示的代码，使用Java编译器编译一定是编译不通过的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class TestMethodSameName &#123;  </span><br><span class="line">    public static void foo(int i) &#123;  </span><br><span class="line">        System.out.println(&quot;TestMethodSameName.foo:(I)V&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static int foo(int i) &#123;  </span><br><span class="line">        System.out.println(&quot;TestMethodSameName.foo:(I)I&quot;);  </span><br><span class="line">        return i;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        foo(123); // foo:(I)V  </span><br><span class="line">        foo(456); // foo:(I)I  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>但是如果你使用使用javac和javap命令查看方法签名时你会发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">javac TestMethodSameName.java</span><br><span class="line">javap -s -p TestMethodSameName.class </span><br><span class="line">Compiled from &quot;TestMethodSameName.java&quot;</span><br><span class="line">public class TestMethodSameName &#123;</span><br><span class="line">  public TestMethodSameName();</span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">  public static int foo(int);</span><br><span class="line">    descriptor: (I)I</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到所谓方法描述是包含函数参数类型和返回值类型的<code>（descriptor: ([Ljava/lang/String;)V)</code>.所以是不是以上说法一和说法二都对呢？<br>其实说法一针对的是Java编译器，说法二针对的是JVM的。在虚拟机的标准里是允许一个类中方法名和形参一样但是返回值不一样，因为这两个方法对应的方法描述不一样，针对字节码层面这种情况是存在的，JVM是也正常运行的。<br>那么为什么JVM支持的东西，JAVA偏偏不支持呢？<br>因为在方法调用的时候并不能保证指定了方法的返回信息，编译器并不知道你实际调用了哪个方法。还是以上面的代码为例，当忽略返回值的调用时就搞不清到底在调用哪个方法了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(1)</span><br></pre></td></tr></table></figure><h4 id="3-3-重载和重写"><a href="#3-3-重载和重写" class="headerlink" title="3.3 重载和重写"></a>3.3 重载和重写</h4><p>重载：同一个类中方法相同方法参数不同的方法。不能通过返回类型是否相同来判断重载。<br>重写：方法签名必定相同，返回值必定相同， 访问修饰符 子 &gt; 父， 异常类 子 &lt; 父</p><h4 id="3-4-父类的private方法子类可以重写吗？"><a href="#3-4-父类的private方法子类可以重写吗？" class="headerlink" title="3.4 父类的private方法子类可以重写吗？"></a>3.4 父类的private方法子类可以重写吗？</h4><p>JVM调用方法有五条指令，分别是</p><ol><li>invokestatic,用来调用static方法（类方法)</li><li>invokespecial,用来调用需要特殊处理的实例方法，私有方法，父类方法(super.)，初始化方法。在对象的创建过程中，new之后很多都会执行<init>方法，就是依赖字节码中是否包含invokespecial指令。静态绑定</li><li>invokevirtual,用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）最常见的。动态绑定 多态例子</li><li>invokeinterface,调用接口方法，在运行时搜索一个实现了这个接口方法的对象，找出适当的方法进行调用。</li><li>invokedynamic。方法动态解析出调用点限定符所引用的方法</li></ol><p><strong>程序绑定：</strong> 指的是一个方法的调用与方法所在的类(方法主体)关联起来。对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。</p><p><strong>静态绑定：</strong> 在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。例如：C。针对java简单的可以理解为程序编译期的绑定。invokespecial和invokestatic是采用静态绑定。</p><p><strong>动态绑定：</strong> 在运行时根据具体对象的类型进行绑定。invokevirtual和invokeinterface是采用动态绑定。</p><p>可以看到，在调用private、super、<init>方法时使用的invokespecial指令，而在实例对象的其他方法时使用的是invokevirtual指令。正是由于这两种绑定的不同，在子类覆盖超类的方法、并向上转型引用后，才产生了多态以及其他特殊的调用结果。运行时，invokespecial选择方法基于引用声明的类型，而不是对象实际的类型。但invokevirtual则选择当前引用的对象的类型。</p><p>回到问题，<strong>父类的private方法子类可以重写吗?</strong></p><p>答案很明显，不能，从invoke指令的角度看，父类的private方法的程序绑定在编译期就已经确定了，跟Java的多态特性是无关的，所以不能被重写。</p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>如果只是针对AndroidX的升级其实很简单，只要关注到一点，AndroidX的升级和转换要保证所有依赖的support包都升级到28.0.0以上。<br>如果从JVM规范和指令角度看，一个很小的点还是有很多值得深挖的地方的。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://mp.weixin.qq.com/s/fmnoKH-R9PCmg-3ATRMIbQ">https://mp.weixin.qq.com/s/fmnoKH-R9PCmg-3ATRMIbQ</a><br><a href="http://wxweven.win/2017/09/15/JVM-invokespecial%E5%92%8Cinvokevirtual/">http://wxweven.win/2017/09/15/JVM-invokespecial%E5%92%8Cinvokevirtual/</a><br><a href="https://hllvm-group.iteye.com/group/topic/27033">https://hllvm-group.iteye.com/group/topic/27033</a><br><a href="https://www.iteye.com/blog/rednaxelafx-479301">https://www.iteye.com/blog/rednaxelafx-479301</a><br><a href="https://www.cnblogs.com/onlywujun/p/3523991.html">https://www.cnblogs.com/onlywujun/p/3523991.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录在升级AndroidX时遇到的一个问题，仅供参考。&lt;/p&gt;</summary>
    
    
    
    <category term="学习总结" scheme="https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="JVM" scheme="https://ivonhoe.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>误用bitmap config导致的故障</title>
    <link href="https://ivonhoe.github.io/2020/03/09/bitmap-preconfig-bug/"/>
    <id>https://ivonhoe.github.io/2020/03/09/bitmap-preconfig-bug/</id>
    <published>2020-03-08T16:27:32.000Z</published>
    <updated>2022-05-25T16:57:39.889Z</updated>
    
    <content type="html"><![CDATA[<p>某周六线上运营报障，在部分用户的Android手机上个别地图图标未能正常显示，只有部分手机有问题(7.0及以下版本)有问题，诡异的是只有个别图标(1个)显示有问题，大部分图标显示并没有问题,开发介入验证后发现更诡异的是，只在release版本才有这个问题，开发debug版本上并没有问题。<br>低版本显示有问题还好理解，这应该是一个版本兼容相关的问题。release和debug上个别图标有差别就有点匪夷所思了，写篇博客记录下。</p><span id="more"></span><h3 id="0x01-问题说明"><a href="#0x01-问题说明" class="headerlink" title="0x01 问题说明"></a>0x01 问题说明</h3><p>问题日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: Attempt to read from field &#x27;int android.graphics.Bitmap$Config.nativeInt&#x27; on a null object reference</span><br><span class="line">10-19 14:27:36.501 20394-20394/? W/System.err:     at android.graphics.Bitmap.copy(Bitmap.java:557)</span><br><span class="line">10-19 14:27:36.501 20394-20394/? W/System.err:     at com.amap.api.maps.model.BitmapDescriptor.&lt;init&gt;(BitmapDescriptor.java:28)</span><br><span class="line">10-19 14:27:36.501 20394-20394/? W/System.err:     at com.amap.api.maps.model.BitmapDescriptorFactory.fromBitmap(BitmapDescriptorFactory.java:258)</span><br></pre></td></tr></table></figure><p>问题代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val opts = BitmapFactory.Options()</span><br><span class="line">opts.inPreferredConfig = Bitmap.Config.RGB_565</span><br><span class="line">opts.inTargetDensity = displayMetrics.densityDpi</span><br><span class="line">opts.inScaled = true</span><br><span class="line">opts.inDensity = DisplayMetrics.DENSITY_XXHIGH//typedValue.density</span><br><span class="line">val var3 = BitmapFactory.decodeStream(var2, null, opts)</span><br></pre></td></tr></table></figure><p>根据日志可以看出是Bitmap的config为null引起的空指针问题，在使用BitmapFactory.decodeStream时，正常解析到了Bitmap对象，但是该图片的Config获取为null，进而引发一个空指针异常，导致了后续图片加载的失败。该段代码也很简单，重新写了个demo应用单独运行这段代码，并特别使用了出现线上故障的资源图片，测试的结果依然是debug版本的demo Bitmap.getConfig获取正常，为ARGB.8888。release版本 Bitmap.getConfig获取为null。尝试修改inPreferredConfig为ARGB_8888或删除这个参数。demo运行正常，Bitmap和Bitmap.Config都能正常获取。<br>这是一个和inPreferredConfig参数有关的问题？考虑到该段代码加载的图片资源可能是透明的png，首先需要承认的是使用565模式解析有alpha通道的图片资源是并不科学的，虽然565配置对非透明图片的加载可以省一般的内存空间。但文档不是这么说的呀？<code>inPreferredConfig</code>参数指定的配置并不是一个非强制的选项，而是建议选项，Android在实际解码时会参考此参数的配置，但如果此配置不满足，Android会重新选取一个合适的配置来对图片进行解码。</p><p><img src="/res/bitmap_preconfig_bug/923F7833-056A-40DE-849B-205EC24F0F73.png"></p><p>所以基于文档的说明，使用RGB_565的配置decode有alpha通道的图片并不会有什么问题，在<strong>正常情况</strong>下Android系统实际还是会选择ARGB_8888的配置进行加载。现在很明显这不是正常情况。不正常的点在哪里？看起来肯定和这张图片有关，换个图片就能解决这个问题了，不然换个图片？不用<code>inPreferredConfig</code>参数也行，但是为什么？问题到底出在哪里？<br>一头扎进BitmapFactory.cpp中，然而并没有什么明显的线索，头大了~~</p><h3 id="0x03-线索分析"><a href="#0x03-线索分析" class="headerlink" title="0x03 线索分析"></a>0x03 线索分析</h3><p>看了大半天BitmapFactory的源码，对加载流程大致有了了解，但是对解决问题并没有什么思路，和大师交流这个问题时，他的一句话点醒了我。</p><p><img src="/res/bitmap_preconfig_bug/CF7A8756-E61A-4A45-88F7-8356DC3BA452.png"></p><p>最最诡异的其实是debug和release差异的问题啊。难道release打包时，资源打包对这个图片动了手脚？所有，手动将release版本的app解压出来，找到有问题的png。果然发现了不一样的地方，使用AS的图片查看器查看png图片，在右上角可以看到，原本在源码中32-bit color的图片在release包中变成了8-bit color。</p><p><img src="/res/bitmap_preconfig_bug/3F44D7B5-08AB-4580-BF59-AC7E6E1B9901.png"></p><p>原本2k的图片在从release包里解压出来后只有700B，aapt对资源做了压缩，难道是压缩引起的问题？在编译文件中配置<code>cruncherEnabled false</code>关闭对png的压缩操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaptOptins&#123;</span><br><span class="line">   cruncherEnabled false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题消失了，实锤！和资源打包时对png的压缩有关~</p><p>什么是alpha通道？</p><h4 id="0x04-调色板模式"><a href="#0x04-调色板模式" class="headerlink" title="0x04 调色板模式"></a>0x04 调色板模式</h4><p>将图像转换为调色板颜色模式时，会给每一个像素分配一个固定的颜色值，这些颜色值储存在简洁的颜色表中，或包含多达256种色的调色板中。因此，调色板颜色模式的图像包含的数据比24位颜色模式的图像小，对于颜色范围有限的图像，通过这个色彩转换模式效果更佳，用户可以设定转换颜色的调色板，从而得到指定颜色的阶数的位图。</p><p>调色板颜色模式也被称为是索引模式，调色板颜色模式只有在图像颜色小于等于256色的时候才有，16位高彩和24位32位真彩是没有调色板色的。它只支持单通道图像(8位&#x2F;像素)，因此，我们通过限制调色板、索引颜色减小文件大小，同时保持视觉上的品质不变——如用于多媒体动画的应用或网页。只有16位以下的才用调色板，真彩色不用调色板。</p><h3 id="0x05-重新理一下问题"><a href="#0x05-重新理一下问题" class="headerlink" title="0x05 重新理一下问题"></a>0x05 重新理一下问题</h3><h4 id="5-1-问题原因"><a href="#5-1-问题原因" class="headerlink" title="5.1 问题原因"></a>5.1 问题原因</h4><ol><li>android aapt针对色值数量小于256个的资源图片，在 <code>aaptOptins cruncherEnabled</code>为<code>true</code>时进行了png压缩操作。将png图片的32位全彩色模式图片转换成了8bit位索引模式</li><li>android较低版本系统在使用PreConfig&#x3D;565模式下解析8bit索引模式图片时能够正常返回解析后的Bitmap，但Bitmap Config为空。导致后续的加载错误。</li><li>基于以上两点原因，才出现了在debug模式下打包正常，在release下正常，有的图标正常，个别图标显示不出来的诡异操作。出问题的图片都是被转换成索引模式的图片，理论上可能并不止一个，只是暂时只发现了一个。</li></ol><h4 id="5-2-解决方案"><a href="#5-2-解决方案" class="headerlink" title="5.2 解决方案"></a>5.2 解决方案</h4><p>选择使用ARGB8888或者不设置<code>inPreferredConfig</code>参数进行bitmap decode。其实默认<code>inPreferredConfig</code>值就是<code>ARGB_8888</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Bitmap.Config inPreferredConfig = Bitmap.Config.ARGB_8888;</span><br></pre></td></tr></table></figure><h4 id="5-3-在使用inPreferredConfig的时候要注意什么？"><a href="#5-3-在使用inPreferredConfig的时候要注意什么？" class="headerlink" title="5.3 在使用inPreferredConfig的时候要注意什么？"></a>5.3 在使用<code>inPreferredConfig</code>的时候要注意什么？</h4><p>参数inpreferredconfig表示图片解码时使用的颜色模式，也就是图片中每个像素颜色的表示方式。参数inpreferredconfig的可选值有四个，分别为ALPHA_8，RGB_565，ARGB_4444，ARGB_8888。它们的含义列举如下。</p><ul><li>ALPHA_8：图片中每个像素用一个字节（8位）存储，该字节存储的是图片8位的透明度值</li><li>RGB_565：图片中每个像素用两个字节（16位）存储，两个字节中高5位表示红色通道，中间6位表示绿色通道，低5位表示蓝色通道</li><li>ARGB_4444：图片中每个像素用两个字节（16位）存储，Alpha，R，G，B四个通道每个通道用4位表示</li><li>ARGB_8888：图片中每个像素用四个字节（32位）存储，Alpha，R，G，B四个通道每个通道用8位表示</li></ul><p>根据Android官方文档的说明，如果inPreferredConfig不为null，解码器会尝试使用此参数指定的颜色模式来对图片进行解码，如果inPreferredConfig为null或者在解码时无法满足此参数指定的颜色模式，解码器会自动根据原始图片的特征以及当前设备的屏幕位深，选取合适的颜色模式来解码，例如，如果图片中包含透明度，那么对该图片解码时使用的配置就需要支持透明度，默认会使用ARGB_8888来解码。<br>inPreferredConfig指定的配置并非是一个强制选项，而是建议的选项，Android在解码时会参考该配置，如果该配置不满足，Android会重新选取一个合适的配置来对图片进行解码。</p><p>详细的验证过程可参考<a href="https://blog.csdn.net/ccpat/article/details/46834089">https://blog.csdn.net/ccpat/article/details/46834089</a></p><h3 id="0x06-为什么Bitmap-getConfig-返回null？"><a href="#0x06-为什么Bitmap-getConfig-返回null？" class="headerlink" title="0x06 为什么Bitmap.getConfig()返回null？"></a>0x06 为什么Bitmap.getConfig()返回null？</h3><p>从 getConfig 方法的文档可以看到这个描述： If the bitmap’s internal config is in one of the public formats, return that config, otherwise return null.<br>如果位图的内部 config 是公开格式的其中之一就返回这个 config，否则返回 null。<br>这里的内部格式，就是指 SkBitmap::Config 枚举值了，这里的公开格式指的是Java层Bitmap.Config的枚举值。如果这个值并未在 Java 层 Bitmap.Config 中公开，就返回 null，像索引颜色对应的 kIndex8_Config 就会导致 getConfig() 会返回 null。</p><p>可查看源码<code>external/skia/include/core/SkBitmap.h</code>，Skia的颜色配置，其中kIndex8_Config表示每像素8bits，使用 SkColorTable 来描述颜色，这个 SkColorTable 顾名思义就是颜色表了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Config &#123;</span><br><span class="line">    kNo_Config,         </span><br><span class="line">    kA1_Config,         </span><br><span class="line">    kA8_Config,         </span><br><span class="line">    // !&lt; 8 -bits per pixel, using SkColorTable to specify the colors</span><br><span class="line">    kIndex8_Config,</span><br><span class="line">    kRGB_565_Config,    </span><br><span class="line">    kARGB_4444_Config,  </span><br><span class="line">    kARGB_8888_Config,  </span><br><span class="line">    kRLE_Index8_Config,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>external/skia/src/images/SkImageDecoder_libpng.cpp</code>的getBitmapConfig方法，如果当前图片是调色板模式，会执行<code>canUpscalePaletteToConfig</code>方法，该方法返回 false 则 configp 被设置为 kIndex8_Config。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool SkPNGImageDecoder::getBitmapConfig(png_structp png_ptr, png_infop info_ptr, SkBitmap::Config* configp, bool* hasAlphap, SkPMColor* theTranspColorp) &#123;</span><br><span class="line">    png_uint_32 origWidth, origHeight;</span><br><span class="line">    int bitDepth, colorType;</span><br><span class="line">    png_get_IHDR(png_ptr, info_ptr, &amp;origWidth, &amp;origHeight, &amp;bitDepth, &amp;colorType, int_p_NULL, int_p_NULL, int_p_NULL);</span><br><span class="line">    // ...</span><br><span class="line">    if (colorType == PNG_COLOR_TYPE_PALETTE) &#123;</span><br><span class="line">        bool paletteHasAlpha = hasTransparencyInPalette(png_ptr, info_ptr);</span><br><span class="line">        *configp = this-&gt;getPrefConfig(kIndex_SrcDepth, paletteHasAlpha);</span><br><span class="line">        // now see if we can upscale to their requested config</span><br><span class="line">        if (!canUpscalePaletteToConfig(*configp, paletteHasAlpha)) &#123;</span><br><span class="line">            *configp = SkBitmap::kIndex8_Config;    // 注意这里</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure><p>当dstConfig为565_config并且图片包含alpha通道时，或者dstConfig不属于kARGB_8888_Config、kARGB_4444_Config 、kRGB_565_Config之一，则<code>canUpscalePaletteToConfig</code>如何才能令其返回<code>false</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static bool canUpscalePaletteToConfig(SkBitmap::Config dstConfig, bool srcHasAlpha) &#123;</span><br><span class="line">    switch (dstConfig) &#123;</span><br><span class="line">        case SkBitmap::kARGB_8888_Config:</span><br><span class="line">        case SkBitmap::kARGB_4444_Config:</span><br><span class="line">            return true;</span><br><span class="line">        case SkBitmap::kRGB_565_Config:</span><br><span class="line">            // only return true if the src is opaque (since 565 is opaque)</span><br><span class="line">            return !srcHasAlpha;</span><br><span class="line">        default:</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看getPrefConfig的实现，getPrefConfig返回由java层设置的fDefaultPref，当config为kNo_Config时，返回GetDeviceConfig(),其实也是kNo_Config。那么config什么时候为SkBitmap::kNo_Config呢？当Java层设置的inPreferredConfig为null时，fDefaultPref会被赋值为kNo_Config。详情可查看<code>getNativeBitmapConfig </code>方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SkBitmap::Config SkImageDecoder::getPrefConfig(SrcDepth srcDepth, bool srcHasAlpha) const &#123;</span><br><span class="line">    SkBitmap::Config config = SkBitmap::kNo_Config;</span><br><span class="line"></span><br><span class="line">    if (fUsePrefTable) &#123;    // 普通图片解码不会进入这个分支</span><br><span class="line">        switch (srcDepth) &#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        config = fDefaultPref;  // 注意这里</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (SkBitmap::kNo_Config == config) &#123;</span><br><span class="line">        config = SkImageDecoder::GetDeviceConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    return config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>综上所述，只要PNG文件本身是索引颜色格式，且在调用BitmapFactory.decodeXXX方法族时，将传入的BitmapFactory.Options.inPreferredConfig置为null即可解码得到索引颜色格式的Bitmap对象，如果这张PNG是带有alpha通道的，inPreferredConfig设置为RGB_565也可以。此时该Bitmap的Config为null。</strong></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.jianshu.com/p/ecacf2f60cb2">https://www.jianshu.com/p/ecacf2f60cb2</a><br><a href="https://www.jianshu.com/p/cc17d18c3447">https://www.jianshu.com/p/cc17d18c3447</a><br><a href="http://www.coreldrawchina.com/X7jiaocheng/cdr-tiaosebanyanse-moshi.html">http://www.coreldrawchina.com/X7jiaocheng/cdr-tiaosebanyanse-moshi.html</a><br><a href="https://www.jianshu.com/p/f56292504ad3">https://www.jianshu.com/p/f56292504ad3</a><br><a href="https://blog.csdn.net/ccpat/article/details/46834089">https://blog.csdn.net/ccpat/article/details/46834089</a><br><a href="https://android.googlesource.com/platform/frameworks/base/+/marshmallow-dev/tools/aapt2/Png.cpp">https://android.googlesource.com/platform/frameworks/base/+/marshmallow-dev/tools/aapt2/Png.cpp</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;某周六线上运营报障，在部分用户的Android手机上个别地图图标未能正常显示，只有部分手机有问题(7.0及以下版本)有问题，诡异的是只有个别图标(1个)显示有问题，大部分图标显示并没有问题,开发介入验证后发现更诡异的是，只在release版本才有这个问题，开发debug版本上并没有问题。&lt;br&gt;低版本显示有问题还好理解，这应该是一个版本兼容相关的问题。release和debug上个别图标有差别就有点匪夷所思了，写篇博客记录下。&lt;/p&gt;</summary>
    
    
    
    <category term="学习总结" scheme="https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Bitmap" scheme="https://ivonhoe.github.io/tags/Bitmap/"/>
    
    <category term="BitmapFactory" scheme="https://ivonhoe.github.io/tags/BitmapFactory/"/>
    
  </entry>
  
  <entry>
    <title>Flutter aspectd入门指引</title>
    <link href="https://ivonhoe.github.io/2019/11/08/hello-flutter-aspectd/"/>
    <id>https://ivonhoe.github.io/2019/11/08/hello-flutter-aspectd/</id>
    <published>2019-11-08T15:16:38.000Z</published>
    <updated>2022-05-25T16:57:04.150Z</updated>
    
    <content type="html"><![CDATA[<p>什么是aspectd？aspectd是闲鱼针对dart的AOP开源框架。<a href="https://github.com/alibaba-flutter/aspectd.git">https://github.com/alibaba-flutter/aspectd.git</a><br>阅读本文你将得到什么？</p><ol><li>掌握aspectd的环境搭建，并如何在本地成功运行aspectd的demo</li><li>掌握有关aop的基础概念</li><li>了解aspectd的基础用法和原理</li></ol><span id="more"></span><h3 id="0x01-准备"><a href="#0x01-准备" class="headerlink" title="0x01 准备"></a>0x01 准备</h3><h4 id="1-1-开发环境"><a href="#1-1-开发环境" class="headerlink" title="1.1 开发环境"></a>1.1 开发环境</h4><p>aspectd的环境搭建需要flutter源码、aspectd源码和dart源码，并需要在系统中设置相应的全局环境变量。</p><h4 id="1-1-1-flutter环境"><a href="#1-1-1-flutter环境" class="headerlink" title="1.1.1 flutter环境"></a>1.1.1 flutter环境</h4><p>下载flutter源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/flutter/flutter.git</span><br></pre></td></tr></table></figure><h4 id="1-1-2-aspectd下载"><a href="#1-1-2-aspectd下载" class="headerlink" title="1.1.2 aspectd下载"></a>1.1.2 aspectd下载</h4><p>下载aspectd源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/alibaba-flutter/aspectd.git</span><br></pre></td></tr></table></figure><h4 id="1-1-3-环境变量"><a href="#1-1-3-环境变量" class="headerlink" title="1.1.3 环境变量"></a>1.1.3 环境变量</h4><p>配置flutter镜像、本地flutter源码地址、flutter bin目录、dart bin目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br><span class="line">export PATH_TO_FLUTTER_GIT_DIRECTORY=/Users/Ivonhoe/Flutter/flutter</span><br><span class="line">export PATH=$PATH_TO_FLUTTER_GIT_DIRECTORY/bin:$PATH</span><br><span class="line">export PATH=$PATH_TO_FLUTTER_GIT_DIRECTORY/bin/cache/dart-sdk/bin:$PATH</span><br></pre></td></tr></table></figure><h4 id="1-2-安装aspectd"><a href="#1-2-安装aspectd" class="headerlink" title="1.2 安装aspectd"></a>1.2 安装aspectd</h4><p>aspectd需要<br>1.切换到flutter的git目录:<br><code>cd $&#123;path-for-git-flutter&#125;</code><br>2.将aspectd源码中的git patch文件合并到flutter源码工程中，合并git patch:<br><code>git apply --3way ~/Github/aspectd/0001-aspectd.patch</code><br>3.删除原有的的flutter编译工具：<br><code>rm bin/cache/flutter_tools.stamp</code><br>4.重新构建新的flutter编译工具：<br><code>flutter doctor -v</code></p><h4 id="1-3-运行"><a href="#1-3-运行" class="headerlink" title="1.3 运行"></a>1.3 运行</h4><p>到aspectd源码目录的example目录下执行：<br><code>flutter run --debug --verbose</code><br><strong>如果你能一次运行成功并aspectd生效，请直接跳转到第二章！</strong></p><h4 id="1-4-aspectd编译不过或demo没有效果"><a href="#1-4-aspectd编译不过或demo没有效果" class="headerlink" title="1.4 aspectd编译不过或demo没有效果"></a>1.4 aspectd编译不过或demo没有效果</h4><p>编译不过或运行demo没有打印出想要的日志是aspectd使用时最常见的问题。aspectd的基本原理实际上是使用了dart对虚拟语法树操作的api，通过对flutter dill文件进行虚拟语法树遍历，完成对dill文件的转换，进而实现对dart的切面操作。所以在aspectd的编译上需要依赖dart源码中的<code>kernal</code>和<code>front_end</code>，可通过查看aspectd源码根目录中的<code>pubspec.yaml</code>查看依赖库和对应的ref。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dependency_overrides:</span><br><span class="line">  kernel:</span><br><span class="line">    git:</span><br><span class="line">      url: https://github.com/dart-lang/sdk.git</span><br><span class="line">      ref: 5e39817ec7ab7f56f381c244d105c7e40913a3e0</span><br><span class="line">      path: pkg/kernel</span><br><span class="line">  front_end:</span><br><span class="line">    git:</span><br><span class="line">      url: https://github.com/dart-lang/sdk.git</span><br><span class="line">      ref: 5e39817ec7ab7f56f381c244d105c7e40913a3e0</span><br><span class="line">      path: pkg/front_end</span><br></pre></td></tr></table></figure><p>在1.2步骤中，使用git patch命令修改flutter源码引入了<code>aspectd.dart</code>文件，该文件做的核心操作就包括下载aspectd的依赖库、编译aspectd.dart.snapshot和根据注解内容使用aspect.dart.snapshot执行具体的dill transform操作。所以，aspectd是否生效的两个关键点是aspectd依赖库是否下载成功和aspectd.snapshot文件是否编译成功。<br>因为aspect使