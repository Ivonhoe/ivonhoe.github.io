<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>病已的博客</title>
  <icon>https://www.gravatar.com/avatar/67e58323dd67029db2c4cf9876795431</icon>
  <subtitle>枕上，马上，厕上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ivonhoe.github.io/"/>
  <updated>2020-03-08T16:53:36.861Z</updated>
  <id>https://ivonhoe.github.io/</id>
  
  <author>
    <name>病已</name>
    <email>yangfan3687@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一个诡异的臭虫</title>
    <link href="https://ivonhoe.github.io/2020/03/09/bitmap-preconfig-bug/"/>
    <id>https://ivonhoe.github.io/2020/03/09/bitmap-preconfig-bug/</id>
    <published>2020-03-08T16:27:32.000Z</published>
    <updated>2020-03-08T16:53:36.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>某周六线上运营报障，在部分用户的Android手机上个别地图图标未能正常显示，只有部分手机有问题(7.0及以下版本)有问题，诡异的是只有个别图标(1个)显示有问题，大部分图标显示并没有问题,开发介入验证后发现更诡异的是，只在release版本才有这个问题，开发debug版本上并没有问题。<br>低版本显示有问题还好理解，这应该是一个版本兼容相关的问题。release和debug上个别图标有差别就有点匪夷所思了，写篇博客记录下。</p><h3 id="0x01-问题说明"><a href="#0x01-问题说明" class="headerlink" title="0x01 问题说明"></a>0x01 问题说明</h3><p>问题日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: Attempt to read from field &apos;int android.graphics.Bitmap$Config.nativeInt&apos; on a null object reference</span><br><span class="line">10-19 14:27:36.501 20394-20394/? W/System.err:     at android.graphics.Bitmap.copy(Bitmap.java:557)</span><br><span class="line">10-19 14:27:36.501 20394-20394/? W/System.err:     at com.amap.api.maps.model.BitmapDescriptor.&lt;init&gt;(BitmapDescriptor.java:28)</span><br><span class="line">10-19 14:27:36.501 20394-20394/? W/System.err:     at com.amap.api.maps.model.BitmapDescriptorFactory.fromBitmap(BitmapDescriptorFactory.java:258)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>问题代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val opts = BitmapFactory.Options()</span><br><span class="line">opts.inPreferredConfig = Bitmap.Config.RGB_565</span><br><span class="line">opts.inTargetDensity = displayMetrics.densityDpi</span><br><span class="line">opts.inScaled = true</span><br><span class="line">opts.inDensity = DisplayMetrics.DENSITY_XXHIGH//typedValue.density</span><br><span class="line">val var3 = BitmapFactory.decodeStream(var2, null, opts)</span><br></pre></td></tr></table></figure></p><p>根据日志可以看出是Bitmap的config为null引起的空指针问题，在使用BitmapFactory.decodeStream时，正常解析到了Bitmap对象，但是该图片的Config获取为null，进而引发一个空指针异常，导致了后续图片加载的失败。该段代码也很简单，重新写了个demo应用单独运行这段代码，并特别使用了出现线上故障的资源图片，测试的结果依然是debug版本的demo Bitmap.getConfig获取正常，为ARGB.8888。release版本 Bitmap.getConfig获取为null。尝试修改inPreferredConfig为ARGB_8888或删除这个参数。demo运行正常，Bitmap和Bitmap.Config都能正常获取。<br>这是一个和inPreferredConfig参数有关的问题？考虑到该段代码加载的图片资源可能是透明的png，首先需要承认的是使用565模式解析有alpha通道的图片资源是并不科学的，虽然565配置对非透明图片的加载可以省一般的内存空间。但文档不是这么说的呀？<code>inPreferredConfig</code>参数指定的配置并不是一个非强制的选项，而是建议选项，Android在实际解码时会参考此参数的配置，但如果此配置不满足，Android会重新选取一个合适的配置来对图片进行解码。</p><p><img src="/res/bitmap_preconfig_bug/923F7833-056A-40DE-849B-205EC24F0F73.png" alt></p><p>所以基于文档的说明，使用RGB_565的配置decode有alpha通道的图片并不会有什么问题，在<strong>正常情况</strong>下Android系统实际还是会选择ARGB_8888的配置进行加载。现在很明显这不是正常情况。不正常的点在哪里？看起来肯定和这张图片有关，换个图片就能解决这个问题了，不然换个图片？不用<code>inPreferredConfig</code>参数也行，但是为什么？问题到底出在哪里？<br>一头扎进BitmapFactory.cpp中，然而并没有什么明显的线索，头大了~~</p><h3 id="0x03-线索分析"><a href="#0x03-线索分析" class="headerlink" title="0x03 线索分析"></a>0x03 线索分析</h3><p>看了大半天BitmapFactory的源码，对加载流程大致有了了解，但是对解决问题并没有什么思路，和大师交流这个问题时，他的一句话点醒了我。</p><p><img src="/res/bitmap_preconfig_bug/CF7A8756-E61A-4A45-88F7-8356DC3BA452.png" alt></p><p>最最诡异的其实是debug和release差异的问题啊。难道release打包时，资源打包对这个图片动了手脚？所有，手动将release版本的app解压出来，找到有问题的png。果然发现了不一样的地方，使用AS的图片查看器查看png图片，在右上角可以看到，原本在源码中32-bit color的图片在release包中变成了8-bit color。</p><p><img src="/res/bitmap_preconfig_bug/3F44D7B5-08AB-4580-BF59-AC7E6E1B9901.png" alt></p><p>原本2k的图片在从release包里解压出来后只有700B，aapt对资源做了压缩，难道是压缩引起的问题？在编译文件中配置<code>cruncherEnabled false</code>关闭对png的压缩操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaptOptins&#123;</span><br><span class="line">   cruncherEnabled false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题消失了，实锤！和资源打包时对png的压缩有关~</p><p>什么是alpha通道？</p><h4 id="0x04-调色板模式"><a href="#0x04-调色板模式" class="headerlink" title="0x04 调色板模式"></a>0x04 调色板模式</h4><p>将图像转换为调色板颜色模式时，会给每一个像素分配一个固定的颜色值，这些颜色值储存在简洁的颜色表中，或包含多达256种色的调色板中。因此，调色板颜色模式的图像包含的数据比24位颜色模式的图像小，对于颜色范围有限的图像，通过这个色彩转换模式效果更佳，用户可以设定转换颜色的调色板，从而得到指定颜色的阶数的位图。</p><p>调色板颜色模式也被称为是索引模式，调色板颜色模式只有在图像颜色小于等于256色的时候才有，16位高彩和24位32位真彩是没有调色板色的。它只支持单通道图像(8位/像素)，因此，我们通过限制调色板、索引颜色减小文件大小，同时保持视觉上的品质不变——如用于多媒体动画的应用或网页。只有16位以下的才用调色板，真彩色不用调色板。</p><h3 id="0x05-重新理一下问题"><a href="#0x05-重新理一下问题" class="headerlink" title="0x05 重新理一下问题"></a>0x05 重新理一下问题</h3><h4 id="5-1-问题原因"><a href="#5-1-问题原因" class="headerlink" title="5.1 问题原因"></a>5.1 问题原因</h4><ol><li>android aapt针对色值数量小于256个的资源图片，在 <code>aaptOptins cruncherEnabled</code>为<code>true</code>时进行了png压缩操作。将png图片的32位全彩色模式图片转换成了8bit位索引模式</li><li>android较低版本系统在使用PreConfig=565模式下解析8bit索引模式图片时能够正常返回解析后的Bitmap，但Bitmap Config为空。导致后续的加载错误。</li><li>基于以上两点原因，才出现了在debug模式下打包正常，在release下正常，有的图标正常，个别图标显示不出来的诡异操作。出问题的图片都是被转换成索引模式的图片，理论上可能并不止一个，只是暂时只发现了一个。</li></ol><h4 id="5-2-解决方案"><a href="#5-2-解决方案" class="headerlink" title="5.2 解决方案"></a>5.2 解决方案</h4><p>选择使用ARGB8888或者不设置<code>inPreferredConfig</code>参数进行bitmap decode。其实默认<code>inPreferredConfig</code>值就是<code>ARGB_8888</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Bitmap.Config inPreferredConfig = Bitmap.Config.ARGB_8888;</span><br></pre></td></tr></table></figure><h4 id="5-3-在使用inPreferredConfig的时候要注意什么？"><a href="#5-3-在使用inPreferredConfig的时候要注意什么？" class="headerlink" title="5.3 在使用inPreferredConfig的时候要注意什么？"></a>5.3 在使用<code>inPreferredConfig</code>的时候要注意什么？</h4><p>参数inpreferredconfig表示图片解码时使用的颜色模式，也就是图片中每个像素颜色的表示方式。参数inpreferredconfig的可选值有四个，分别为ALPHA_8，RGB_565，ARGB_4444，ARGB_8888。它们的含义列举如下。</p><ul><li>ALPHA_8：图片中每个像素用一个字节（8位）存储，该字节存储的是图片8位的透明度值</li><li>RGB_565：图片中每个像素用两个字节（16位）存储，两个字节中高5位表示红色通道，中间6位表示绿色通道，低5位表示蓝色通道</li><li>ARGB_4444：图片中每个像素用两个字节（16位）存储，Alpha，R，G，B四个通道每个通道用4位表示</li><li>ARGB_8888：图片中每个像素用四个字节（32位）存储，Alpha，R，G，B四个通道每个通道用8位表示</li></ul><p>根据Android官方文档的说明，如果inPreferredConfig不为null，解码器会尝试使用此参数指定的颜色模式来对图片进行解码，如果inPreferredConfig为null或者在解码时无法满足此参数指定的颜色模式，解码器会自动根据原始图片的特征以及当前设备的屏幕位深，选取合适的颜色模式来解码，例如，如果图片中包含透明度，那么对该图片解码时使用的配置就需要支持透明度，默认会使用ARGB_8888来解码。<br>inPreferredConfig指定的配置并非是一个强制选项，而是建议的选项，Android在解码时会参考该配置，如果该配置不满足，Android会重新选取一个合适的配置来对图片进行解码。</p><p>详细的验证过程可参考<a href="https://blog.csdn.net/ccpat/article/details/46834089" target="_blank" rel="noopener">https://blog.csdn.net/ccpat/article/details/46834089</a></p><h3 id="0x06-为什么Bitmap-getConfig-返回null？"><a href="#0x06-为什么Bitmap-getConfig-返回null？" class="headerlink" title="0x06 为什么Bitmap.getConfig()返回null？"></a>0x06 为什么Bitmap.getConfig()返回null？</h3><p>从 getConfig 方法的文档可以看到这个描述： If the bitmap’s internal config is in one of the public formats, return that config, otherwise return null.<br>如果位图的内部 config 是公开格式的其中之一就返回这个 config，否则返回 null。<br>这里的内部格式，就是指 SkBitmap::Config 枚举值了，这里的公开格式指的是Java层Bitmap.Config的枚举值。如果这个值并未在 Java 层 Bitmap.Config 中公开，就返回 null，像索引颜色对应的 kIndex8_Config 就会导致 getConfig() 会返回 null。</p><p>可查看源码<code>external/skia/include/core/SkBitmap.h</code>，Skia的颜色配置，其中kIndex8_Config表示每像素8bits，使用 SkColorTable 来描述颜色，这个 SkColorTable 顾名思义就是颜色表了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Config &#123;</span><br><span class="line">    kNo_Config,         </span><br><span class="line">    kA1_Config,         </span><br><span class="line">    kA8_Config,         </span><br><span class="line">    // !&lt; 8 -bits per pixel, using SkColorTable to specify the colors</span><br><span class="line">    kIndex8_Config,</span><br><span class="line">    kRGB_565_Config,    </span><br><span class="line">    kARGB_4444_Config,  </span><br><span class="line">    kARGB_8888_Config,  </span><br><span class="line">    kRLE_Index8_Config,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>external/skia/src/images/SkImageDecoder_libpng.cpp</code>的getBitmapConfig方法，如果当前图片是调色板模式，会执行<code>canUpscalePaletteToConfig</code>方法，该方法返回 false 则 configp 被设置为 kIndex8_Config。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool SkPNGImageDecoder::getBitmapConfig(png_structp png_ptr, png_infop info_ptr, SkBitmap::Config* configp, bool* hasAlphap, SkPMColor* theTranspColorp) &#123;</span><br><span class="line">    png_uint_32 origWidth, origHeight;</span><br><span class="line">    int bitDepth, colorType;</span><br><span class="line">    png_get_IHDR(png_ptr, info_ptr, &amp;origWidth, &amp;origHeight, &amp;bitDepth, &amp;colorType, int_p_NULL, int_p_NULL, int_p_NULL);</span><br><span class="line">    // ...</span><br><span class="line">    if (colorType == PNG_COLOR_TYPE_PALETTE) &#123;</span><br><span class="line">        bool paletteHasAlpha = hasTransparencyInPalette(png_ptr, info_ptr);</span><br><span class="line">        *configp = this-&gt;getPrefConfig(kIndex_SrcDepth, paletteHasAlpha);</span><br><span class="line">        // now see if we can upscale to their requested config</span><br><span class="line">        if (!canUpscalePaletteToConfig(*configp, paletteHasAlpha)) &#123;</span><br><span class="line">            *configp = SkBitmap::kIndex8_Config;    // 注意这里</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure><p>当dstConfig为565_config并且图片包含alpha通道时，或者dstConfig不属于kARGB_8888_Config、kARGB_4444_Config 、kRGB_565_Config之一，则<code>canUpscalePaletteToConfig</code>如何才能令其返回<code>false</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static bool canUpscalePaletteToConfig(SkBitmap::Config dstConfig, bool srcHasAlpha) &#123;</span><br><span class="line">    switch (dstConfig) &#123;</span><br><span class="line">        case SkBitmap::kARGB_8888_Config:</span><br><span class="line">        case SkBitmap::kARGB_4444_Config:</span><br><span class="line">            return true;</span><br><span class="line">        case SkBitmap::kRGB_565_Config:</span><br><span class="line">            // only return true if the src is opaque (since 565 is opaque)</span><br><span class="line">            return !srcHasAlpha;</span><br><span class="line">        default:</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看getPrefConfig的实现，getPrefConfig返回由java层设置的fDefaultPref，当config为kNo_Config时，返回GetDeviceConfig(),其实也是kNo_Config。那么config什么时候为SkBitmap::kNo_Config呢？当Java层设置的inPreferredConfig为null时，fDefaultPref会被赋值为kNo_Config。详情可查看<code>getNativeBitmapConfig</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SkBitmap::Config SkImageDecoder::getPrefConfig(SrcDepth srcDepth, bool srcHasAlpha) const &#123;</span><br><span class="line">    SkBitmap::Config config = SkBitmap::kNo_Config;</span><br><span class="line"></span><br><span class="line">    if (fUsePrefTable) &#123;    // 普通图片解码不会进入这个分支</span><br><span class="line">        switch (srcDepth) &#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        config = fDefaultPref;  // 注意这里</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (SkBitmap::kNo_Config == config) &#123;</span><br><span class="line">        config = SkImageDecoder::GetDeviceConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    return config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>综上所述，只要PNG文件本身是索引颜色格式，且在调用BitmapFactory.decodeXXX方法族时，将传入的BitmapFactory.Options.inPreferredConfig置为null即可解码得到索引颜色格式的Bitmap对象，如果这张PNG是带有alpha通道的，inPreferredConfig设置为RGB_565也可以。此时该Bitmap的Config为null。</strong></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.jianshu.com/p/ecacf2f60cb2" target="_blank" rel="noopener">https://www.jianshu.com/p/ecacf2f60cb2</a><br><a href="https://www.jianshu.com/p/cc17d18c3447" target="_blank" rel="noopener">https://www.jianshu.com/p/cc17d18c3447</a><br><a href="http://www.coreldrawchina.com/X7jiaocheng/cdr-tiaosebanyanse-moshi.html" target="_blank" rel="noopener">http://www.coreldrawchina.com/X7jiaocheng/cdr-tiaosebanyanse-moshi.html</a><br><a href="https://www.jianshu.com/p/f56292504ad3" target="_blank" rel="noopener">https://www.jianshu.com/p/f56292504ad3</a><br><a href="https://blog.csdn.net/ccpat/article/details/46834089" target="_blank" rel="noopener">https://blog.csdn.net/ccpat/article/details/46834089</a><br><a href="https://android.googlesource.com/platform/frameworks/base/+/marshmallow-dev/tools/aapt2/Png.cpp" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/marshmallow-dev/tools/aapt2/Png.cpp</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;某周六线上运营报障，在部分用户的Android手机上个别地图图标未能正常显示，只有部分手机有问题(7.0及以下版本)有问题，诡异的是只有个别图标(1个)显示有问题，大部分图标显示并没有问题,开发介入验证后发现更诡异的是，只在release版本才有这个问题，开发debug版本上并没有问题。&lt;br&gt;低版本显示有问题还好理解，这应该是一个版本兼容相关的问题。release和debug上个别图标有差别就有点匪夷所思了，写篇博客记录下。&lt;/p&gt;
&lt;h3 id=&quot;0x01-问题说明&quot;&gt;&lt;a href=&quot;#0x01-问题说明&quot; class=&quot;headerlink&quot; title=&quot;0x01 问题说明&quot;&gt;&lt;/a&gt;0x01 问题说明&lt;/h3&gt;&lt;p&gt;问题日志：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.lang.NullPointerException: Attempt to read from field &amp;apos;int android.graphics.Bitmap$Config.nativeInt&amp;apos; on a null object reference&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10-19 14:27:36.501 20394-20394/? W/System.err:     at android.graphics.Bitmap.copy(Bitmap.java:557)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10-19 14:27:36.501 20394-20394/? W/System.err:     at com.amap.api.maps.model.BitmapDescriptor.&amp;lt;init&amp;gt;(BitmapDescriptor.java:28)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10-19 14:27:36.501 20394-20394/? W/System.err:     at com.amap.api.maps.model.BitmapDescriptorFactory.fromBitmap(BitmapDescriptorFactory.java:258)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Bug总结" scheme="https://ivonhoe.github.io/categories/Bug%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Bitmap" scheme="https://ivonhoe.github.io/tags/Bitmap/"/>
    
      <category term="BitmapFactory" scheme="https://ivonhoe.github.io/tags/BitmapFactory/"/>
    
  </entry>
  
  <entry>
    <title>Flutter aspectd入门指引</title>
    <link href="https://ivonhoe.github.io/2019/11/08/hello-flutter-aspectd/"/>
    <id>https://ivonhoe.github.io/2019/11/08/hello-flutter-aspectd/</id>
    <published>2019-11-08T15:16:38.000Z</published>
    <updated>2020-02-08T15:25:12.793Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>什么是aspectd？aspectd是闲鱼针对dart的AOP开源框架。<a href="https://github.com/alibaba-flutter/aspectd.git" target="_blank" rel="noopener">https://github.com/alibaba-flutter/aspectd.git</a><br>阅读本文你将得到什么？</p><ol><li>掌握aspectd的环境搭建，并如何在本地成功运行aspectd的demo</li><li>掌握有关aop的基础概念</li><li>了解aspectd的基础用法和原理</li></ol><a id="more"></a><h3 id="0x01-准备"><a href="#0x01-准备" class="headerlink" title="0x01 准备"></a>0x01 准备</h3><h4 id="1-1-开发环境"><a href="#1-1-开发环境" class="headerlink" title="1.1 开发环境"></a>1.1 开发环境</h4><p>aspectd的环境搭建需要flutter源码、aspectd源码和dart源码，并需要在系统中设置相应的全局环境变量。</p><h4 id="1-1-1-flutter环境"><a href="#1-1-1-flutter环境" class="headerlink" title="1.1.1 flutter环境"></a>1.1.1 flutter环境</h4><p>下载flutter源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/flutter/flutter.git</span><br></pre></td></tr></table></figure><h4 id="1-1-2-aspectd下载"><a href="#1-1-2-aspectd下载" class="headerlink" title="1.1.2 aspectd下载"></a>1.1.2 aspectd下载</h4><p>下载aspectd源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/alibaba-flutter/aspectd.git</span><br></pre></td></tr></table></figure><h4 id="1-1-3-环境变量"><a href="#1-1-3-环境变量" class="headerlink" title="1.1.3 环境变量"></a>1.1.3 环境变量</h4><p>配置flutter镜像、本地flutter源码地址、flutter bin目录、dart bin目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br><span class="line">export PATH_TO_FLUTTER_GIT_DIRECTORY=/Users/Ivonhoe/Flutter/flutter</span><br><span class="line">export PATH=$PATH_TO_FLUTTER_GIT_DIRECTORY/bin:$PATH</span><br><span class="line">export PATH=$PATH_TO_FLUTTER_GIT_DIRECTORY/bin/cache/dart-sdk/bin:$PATH</span><br></pre></td></tr></table></figure><h4 id="1-2-安装aspectd"><a href="#1-2-安装aspectd" class="headerlink" title="1.2 安装aspectd"></a>1.2 安装aspectd</h4><p>aspectd需要<br>1.切换到flutter的git目录:<br><code>cd ${path-for-git-flutter}</code><br>2.将aspectd源码中的git patch文件合并到flutter源码工程中，合并git patch:<br><code>git apply --3way ~/Github/aspectd/0001-aspectd.patch</code><br>3.删除原有的的flutter编译工具：<br><code>rm bin/cache/flutter_tools.stamp</code><br>4.重新构建新的flutter编译工具：<br><code>flutter doctor -v</code></p><h4 id="1-3-运行"><a href="#1-3-运行" class="headerlink" title="1.3 运行"></a>1.3 运行</h4><p>到aspectd源码目录的example目录下执行：<br><code>flutter run --debug --verbose</code><br><strong>如果你能一次运行成功并aspectd生效，请直接跳转到第二章！</strong></p><h4 id="1-4-aspectd编译不过或demo没有效果"><a href="#1-4-aspectd编译不过或demo没有效果" class="headerlink" title="1.4 aspectd编译不过或demo没有效果"></a>1.4 aspectd编译不过或demo没有效果</h4><p>编译不过或运行demo没有打印出想要的日志是aspectd使用时最常见的问题。aspectd的基本原理实际上是使用了dart对虚拟语法树操作的api，通过对flutter dill文件进行虚拟语法树遍历，完成对dill文件的转换，进而实现对dart的切面操作。所以在aspectd的编译上需要依赖dart源码中的<code>kernal</code>和<code>front_end</code>，可通过查看aspectd源码根目录中的<code>pubspec.yaml</code>查看依赖库和对应的ref。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dependency_overrides:</span><br><span class="line">  kernel:</span><br><span class="line">    git:</span><br><span class="line">      url: https://github.com/dart-lang/sdk.git</span><br><span class="line">      ref: 5e39817ec7ab7f56f381c244d105c7e40913a3e0</span><br><span class="line">      path: pkg/kernel</span><br><span class="line">  front_end:</span><br><span class="line">    git:</span><br><span class="line">      url: https://github.com/dart-lang/sdk.git</span><br><span class="line">      ref: 5e39817ec7ab7f56f381c244d105c7e40913a3e0</span><br><span class="line">      path: pkg/front_end</span><br></pre></td></tr></table></figure></p><p>在1.2步骤中，使用git patch命令修改flutter源码引入了<code>aspectd.dart</code>文件，该文件做的核心操作就包括下载aspectd的依赖库、编译aspectd.dart.snapshot和根据注解内容使用aspect.dart.snapshot执行具体的dill transform操作。所以，aspectd是否生效的两个关键点是aspectd依赖库是否下载成功和aspectd.snapshot文件是否编译成功。<br>因为aspect使用依赖github源码指定ref的方式依赖kenerl和front_end库，这个过程需要下载github上dart-lang的所有源码(约900M左右)，在国内的网络环境下很难做到一次成功，这里分享一个绕过因网络不稳定问题导致aspectd不生效的方法。</p><ol><li>手动下载dart源码，<code>git clone https://github.com/dart-lang/sdk.git</code></li><li>将dart源码切换到aspectd项目中<code>pubspec.yaml</code>指定的ref上，如上例中，可执行 <code>git checkout 5e39817ec7ab7f56f381c244d105c7e40913a3e0</code></li><li>将aspect对github源码的依赖改成对本地源码的依赖<br><img src="/res/aspectd/aspectd_1.jpeg" alt></li><li>手动编译aspect.dart.snapshot(在aspectd根目录中)<br><code>dart --snapshot=snapshot/aspectd.dart.snapshot tool/starter.dart</code></li><li>修改flutter源码中的aspectd.dart，强制指定aspect.dart.snapshot的目录。<br><img src="/res/aspectd/aspectd_2.jpeg" alt></li><li>删除flutter_tools.stamp重新编译运行<code>flutter run --debug -v</code>即可生效</li></ol><h4 id="1-5-常见问题解决"><a href="#1-5-常见问题解决" class="headerlink" title="1.5 常见问题解决"></a>1.5 常见问题解决</h4><ul><li><p>等待另一个flutter命令释放锁<br><code>Waiting for another flutter command to release the startup lock...</code><br>解决方法，将bin/cache下的lockfile删除后重新执行命令<br><code>rm ${path-for-git-flutter}/bin/cache/lockfile</code></p></li><li><p>如何使用命令行编译工程<br>debug版本：<code>flutter run --debug --verbose</code><br>release版本：<code>flutter run --release --verbose</code></p></li><li><p>pub命令是什么？<br><code>flutter pub get</code><br>pub是dart提供的包管理工具，在flutter源码中的<code>flutter/bin/cache/dart-sdk/bin/pub</code>目录下有pub可执行文件，想要单独执行pub命令可讲该目录加入到系统的环境变量中<br>相当于android gradle的gradle sync<br>相当于ios pod中的pod install<br>相当于js npm中的npm install</p></li></ul><h3 id="0x02-aspectd的注解"><a href="#0x02-aspectd的注解" class="headerlink" title="0x02 aspectd的注解"></a>0x02 aspectd的注解</h3><h4 id="2-1-pragma-‘vm-entry-point’"><a href="#2-1-pragma-‘vm-entry-point’" class="headerlink" title="2.1 @pragma(‘vm:entry-point’)"></a>2.1 @pragma(‘vm:entry-point’)</h4><p>在AOT变一下，如果不能被应用主入口(main)最终可能调用到，那么将被视为无用代码而被丢弃掉。AOP代码因为其注入逻辑的无侵入性，所以不会被main调用，因为使用此注解告诉编译器不要丢弃这段逻辑。</p><h4 id="2-2-Aspect"><a href="#2-2-Aspect" class="headerlink" title="2.2 @Aspect"></a>2.2 @Aspect</h4><p>Aspect注解可以使得像asepctd源码example中<code>aop_impl.dart</code>这样的AOP实现类被方便的识别和提取，也可以起到方便开关的作用，如果想禁用掉这段AOP逻辑，移除@Aspect注解即可</p><h4 id="2-3-Call、-Execute、-Inject"><a href="#2-3-Call、-Execute、-Inject" class="headerlink" title="2.3 @Call、@Execute、@Inject"></a>2.3 @Call、@Execute、@Inject</h4><p>在介绍这几个注解之前需要理解关于AOP的几个概念，aspectd官方介绍文档对aspectd的说明引入了很对对aop设计的说明，比如什么是Advice？什么是Before\Around\After?如果对这些概念没有预先的概念，读aspectd的文档是一头雾水的，至少我是这样！</p><h5 id="2-3-1-什么是Joint-Point（连接点）"><a href="#2-3-1-什么是Joint-Point（连接点）" class="headerlink" title="2.3.1 什么是Joint Point（连接点）"></a>2.3.1 什么是Joint Point（连接点）</h5><p>能够插入切面的一个点。这个点可以是类的某个方法调用前、调用后、方法抛出异常后等。切面代码可以利用这些点插入到应用的正常流程之中，并添加行为</p><h5 id="2-3-2-什么是Pointcut（切点）"><a href="#2-3-2-什么是Pointcut（切点）" class="headerlink" title="2.3.2 什么是Pointcut（切点）"></a>2.3.2 什么是Pointcut（切点）</h5><p>指定一个通知将被引发的一系列连接点的集合。切点是连接点规则的描述。切点和连接点不是一对一的关系，一个切点匹配多个连接点</p><h5 id="2-3-3-什么是Target-Object（目标对象）"><a href="#2-3-3-什么是Target-Object（目标对象）" class="headerlink" title="2.3.3 什么是Target Object（目标对象）"></a>2.3.3 什么是Target Object（目标对象）</h5><p>包含连接点的对象</p><h5 id="2-3-3-什么是Advice（通知）"><a href="#2-3-3-什么是Advice（通知）" class="headerlink" title="2.3.3 什么是Advice（通知）"></a>2.3.3 什么是Advice（通知）</h5><p>在特定的连接点，AOP框架执行的动作。通知有常见的几种类型：</p><ul><li>前置通知Before：在目标方法被调用之前调用通知功能</li><li>后置通知After：目标方法完成之后调用通知，无论该方法是否发生异常</li><li>后置返回通知After-returning：在目标方法成功执行之后调用通知</li><li>后置异常通知After-throwing：在目标方法抛出异常后调用通知</li><li>环绕通知Around：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</li></ul><h5 id="2-3-4-Call、-Execute、-Inject"><a href="#2-3-4-Call、-Execute、-Inject" class="headerlink" title="2.3.4 @Call、@Execute、@Inject"></a>2.3.4 @Call、@Execute、@Inject</h5><p>aspectd只有一种统一的通知类型，就是Around。具体分为两种注解，分别是@Call和@Execute，这两种注解表达的PointCut都是通过包装原有方法实现的。差别是，@Call的PointCut是调用的地方，并不会修改原始方法的内部。@Execute会修改原有方法的内部。举个例子，分别使用@Call和@Execute对<code>test</code>方法执行切面操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">  print(&quot;print hello world!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">  test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Call表达注解的实际代码会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">  print(&quot;print hello world!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void invokeCall()&#123;</span><br><span class="line">  // to do somethings</span><br><span class="line">  test();</span><br><span class="line">  // to do somethings</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">  aop:invokeCall()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Execute表达注解的实际代码会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void invokeExecutor()&#123;</span><br><span class="line">  // to do somethings</span><br><span class="line">  print(&quot;print hello world!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line">  invokeExecutor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">  test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而@Inject相对于Call/Executor而言，多了一个lineNum的参数，用于指定插入逻辑的具体行号。用于在具体方法中间插入处理逻辑。</p><h3 id="0x03-参考文档"><a href="#0x03-参考文档" class="headerlink" title="0x03 参考文档"></a>0x03 参考文档</h3><p><a href="https://github.com/alibaba-flutter/aspectd/issues/26" target="_blank" rel="noopener">https://github.com/alibaba-flutter/aspectd/issues/26</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;什么是aspectd？aspectd是闲鱼针对dart的AOP开源框架。&lt;a href=&quot;https://github.com/alibaba-flutter/aspectd.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/alibaba-flutter/aspectd.git&lt;/a&gt;&lt;br&gt;阅读本文你将得到什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;掌握aspectd的环境搭建，并如何在本地成功运行aspectd的demo&lt;/li&gt;
&lt;li&gt;掌握有关aop的基础概念&lt;/li&gt;
&lt;li&gt;了解aspectd的基础用法和原理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Flutter" scheme="https://ivonhoe.github.io/categories/Flutter/"/>
    
    
      <category term="flutter" scheme="https://ivonhoe.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android内存分析的一般方法</title>
    <link href="https://ivonhoe.github.io/2019/07/08/how-to-analyze-android-heap-1/"/>
    <id>https://ivonhoe.github.io/2019/07/08/how-to-analyze-android-heap-1/</id>
    <published>2019-07-08T15:04:56.000Z</published>
    <updated>2020-02-08T15:14:13.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>对内存问题的分析中一个必不可少的环节应该就是对hprof的分析了，常见的MAT和Leakcanry都是针对hprof文件的分析工具。这篇文章就记录下做内存分析的一般工具和分析步骤。</p><a id="more"></a><h3 id="0x02-使用dumpsys分析内存"><a href="#0x02-使用dumpsys分析内存" class="headerlink" title="0x02 使用dumpsys分析内存"></a>0x02 使用dumpsys分析内存</h3><p><code>adb shell dumpsys meminfo $applicationId [-d]</code></p><p><img src="/res/hprof/analyze_hprof_1.png" alt></p><p><strong>私有内存 Private (Clean and Dirty)</strong><br>这是仅属于你的进程的内存，这是你的进程被销毁时系统可以回收的RAM。通常情况下最重要的部分是Private Dirty RAM。</p><p><strong>按比例分配占用内存 PSS</strong><br>这表示您的应用的 RAM 使用情况，考虑了在各进程之间共享 RAM 页的情况。您的进程独有的任何 RAM 页会直接影响其 PSS 值，而与其他进程共享的 RAM 页仅影响与共享量成比例的 PSS 值。例如，两个进程之间共享的 RAM 页会将其一半的大小贡献给每个进程的 PSS。</p><p>通常情况下，仅需关注 Pss Total 和 Private Dirty 列。一些情况下，Private Clean 和 Heap Alloc 列提供的数据也需要关注。</p><p><strong>Dalvik Heap</strong></p><blockquote><p>PSS Total: 包括所有 Zygote 按比例分配的内存。<br>Private Dirty:  数值是仅分配到您应用的堆的实际 RAM，是由自己的分配和任何 Zygote 分配页组成，这些分配页自从 Zygote 派生应用进程以来已被修改(COW)。</p></blockquote><p><strong>.so mmap 和 .dex mmap</strong></p><blockquote><p>Pss Total: 包括应用之间共享的平台代码<br>Private Clean: 是应用自己的代码</p></blockquote><p><strong>.oat mmap</strong></p><blockquote><p>这是代码映像占用的 RAM 量，根据多个应用通常使用的预加载类计算。此映像在所有应用之间共享，不受特定应用影响</p></blockquote><p><strong>EGL mtrack 和 GL mtrack</strong></p><blockquote><p>EGL mtrack: gralloc分配的内存，主要是窗口系统，SurfaceView/TextureView和其他的由gralloc分配的GraphicBuffer总和<br>GL mtrack: 驱动上报的GL内存使用情况。 主要是GL texture大小，GL command buffer，固定的全局驱动程序RAM开销等的总和</p></blockquote><p>这里有一个小技巧，应用开发者调用startTrimMemory会帮助app或者系统更多的释放内存，减少内存压力，但是调用的位置和时机要慎重，因为清除了缓存，在下一次绘制（vsync的下一个信号到来）的时候绘制效率不会很高。详细原理可参考：<a href="https://cloud.tencent.com/developer/article/1070616" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1070616</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除GPU绘图缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanGraphicsCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object instance = ReflectUtils.getStaticMethod(<span class="string">"android.view.WindowManagerGlobal"</span>,</span><br><span class="line">            <span class="string">"getInstance"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class threadClazz = Class.forName(<span class="string">"android.view.WindowManagerGlobal"</span>);</span><br><span class="line">        Method m1 = threadClazz.getDeclaredMethod(<span class="string">"trimMemory"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        m1.invoke(instance, TRIM_MEMORY_COMPLETE);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TOATAL</strong></p><blockquote><p>进程占用的按比例分配占用内存 (PSS) 总量。等于上方所有 PSS 字段的总和。表示您的进程占用的内存量占整体内存的比重，可以直接与其他进程和可用总 RAM 比较。<br>Private Dirty 和 Private Clean 是进程中的总分配，未与其他进程共享。它们（尤其是 Private Dirty）等于你的进程被破坏后将释放回系统中的 RAM 量。Dirty RAM 是因为已被修改而必须保持在 RAM 中的 RAM 页（因为没有交换）；Clean RAM 是已从某个持久性文件（例如正在执行的代码）映射的 RAM 页，如果一段时间不用，可以移出分页。</p></blockquote><p><strong>ViewRootImpl</strong><br>根视图数量，每一个根视图关联一个window，由此可确定涉及对话框或其他window的内存泄露。</p><p><strong>AppContexts 和 Activities</strong><br>Context和Activity对象数量，用于快速确定Activity的泄露情况。</p><h3 id="0x03-使用堆转储工具"><a href="#0x03-使用堆转储工具" class="headerlink" title="0x03 使用堆转储工具"></a>0x03 使用堆转储工具</h3><p>将android app的内存信息转换成hprof格式的磁盘文件，这个过程就叫堆转储。堆转储的目标当然是为了获取当前Java虚拟机的内存信息以供排查内存问题。在android平台上常见的三种堆转储方法。</p><ol><li>使用sdk自带的DDMS工具完成堆转储</li><li>使用Android Studio提供的Android Profiler工具完成堆转储</li><li>使用Android sdk提供的api堆转储，以下代码为api实例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String state = android.os.Environment.getExternalStorageState();</span><br><span class="line">    <span class="comment">// 判断SdCard是否存在并且是可用的</span></span><br><span class="line">    <span class="keyword">if</span> (android.os.Environment.MEDIA_MOUNTED.equals(state)) &#123;</span><br><span class="line">        String dumpDir = Hprof.getDumpDir(context);</span><br><span class="line">        android.os.Debug.dumpHprofData(dumpDir);</span><br><span class="line">        Logger.d(String.format(<span class="string">"create dumpfile %s done!"</span>, dumpDir));</span><br><span class="line">        <span class="keyword">return</span> dumpDir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x04-使用hprof文件分析工具"><a href="#0x04-使用hprof文件分析工具" class="headerlink" title="0x04 使用hprof文件分析工具"></a>0x04 使用hprof文件分析工具</h3><p>Memory Analyzer Tool（简称MAT） 使用方法可参考： <a href="http://www.androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT-Pro/" target="_blank" rel="noopener">Android内存优化之二：MAT使用进阶</a>。<br>这里补充的是，MAT支持使用OQL（对象查询语言）查询堆文件信息，你可以像类似使用SQL查询数据库一样查询堆文件上的内存对象的信息，举个例子，我想知道当前内存中有多少个Activity？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> instanceof android.app.Activity</span><br></pre></td></tr></table></figure><p><a href="/res/jvm-2/mat-1.png"></a></p><p>查询大小大于100kb大小的Bitmap对象，图略<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> instanceof android.graphics.Bitmap s <span class="keyword">where</span> s.@retainedHeapSize &gt;<span class="number">100000</span></span><br></pre></td></tr></table></figure></p><p>关于OQL详情参考：<a href="http://help.eclipse.org/kepler/index.jsp，搜索OQL" target="_blank" rel="noopener">http://help.eclipse.org/kepler/index.jsp，搜索OQL</a></p><h3 id="0x05-使用Leakcanary监控泄露"><a href="#0x05-使用Leakcanary监控泄露" class="headerlink" title="0x05 使用Leakcanary监控泄露"></a>0x05 使用Leakcanary监控泄露</h3><p>LeakCanary是内存泄露检测工具，<a href="https://www.liaohuqiu.net/cn/posts/leak-canary-read-me/" target="_blank" rel="noopener">LeakCanary 中文使用说明</a>和LeakCanary的开源地址：<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">https://github.com/square/leakcanary</a></p><p><strong>如何监控内存泄露的发生？</strong><br>利用弱引用。当JVM进行垃圾回收时，无论内存是否充足，如果该对象只有弱引用存在，那么该对象会被垃圾回收器回收。所以Leakcanary在进行内存泄露的监控时，利用弱引用的上述特性，在对象生命周期结束后主动gc并检查该对象的弱引用是否被回收，如果弱引用没有被正常回收，说明在对象生命周期结束以后，该对象还被其他对象持有他的非弱引用。该对象还有到达GC ROOTS的可达路径。如果在对象生命周期结束后弱引用不存在了，说明该对象已经被JVM的垃圾回收器正常回收了，该对象的内存空间也被正常回收。所以Leakcanary设计成是对有明确生命周期的对象的自动监控，比如Activity对象，也可以是你想要跟踪的有明确生命周期的对象。</p><p><strong>如何判断弱引用被回收？</strong><br>利用ReferenceQueue。当垃圾回收器准备回收一个被引用包装的对象时，该引用会被加入到关联的ReferenceQueue。程序可以通过判断引用队列中是否已经加入引用,来了解被引用的对象是否被GC回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Retryable.<span class="function">Result <span class="title">ensureGone</span><span class="params">(<span class="keyword">final</span> KeyedWeakReference reference, <span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> gcStartNanoTime = System.nanoTime();</span><br><span class="line">    <span class="comment">//计算watch方法到gc垃圾回收的时长</span></span><br><span class="line">    <span class="keyword">long</span> watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);</span><br><span class="line">    <span class="comment">//尝试移除已经到达引用队列的弱引用</span></span><br><span class="line">    removeWeaklyReachableReferences();</span><br><span class="line">    <span class="comment">//判断是否在debug</span></span><br><span class="line">    <span class="keyword">if</span> (debuggerControl.isDebuggerAttached()) &#123;</span><br><span class="line">      <span class="comment">// The debugger can create false leaks. (debug可以创造错误的内存泄露)</span></span><br><span class="line">      <span class="keyword">return</span> RETRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (gone(reference)) &#123;<span class="comment">//若当前对象已经可达了，即不会造成你内存泄露</span></span><br><span class="line">      <span class="keyword">return</span> DONE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//手动gc，确保引用对象是否真的被回收了。因为在dump内存信息之前提示内存泄露的时候，希望系统经过充分gc垃圾回收，而不存在任何的误判，对leakcanary容错性的考虑</span></span><br><span class="line">    gcTrigger.runGc();</span><br><span class="line">    <span class="comment">//清除已经到达引用队列的弱引用</span></span><br><span class="line">    removeWeaklyReachableReferences();</span><br><span class="line">    <span class="keyword">if</span> (!gone(reference)) &#123;<span class="comment">//此时对象还没到达对列，代表已经内存泄露了</span></span><br><span class="line">      <span class="keyword">long</span> startDumpHeap = System.nanoTime();</span><br><span class="line">      <span class="keyword">long</span> gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</span><br><span class="line">      <span class="comment">//dump出内存泄露的heap文件,这里可能触发GC</span></span><br><span class="line">      File heapDumpFile = heapDumper.dumpHeap();</span><br><span class="line">      <span class="keyword">if</span> (heapDumpFile == RETRY_LATER) &#123;</span><br><span class="line">        <span class="comment">// Could not dump the heap.(不能dump heap堆文件)</span></span><br><span class="line">        <span class="keyword">return</span> RETRY;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//dump heap文件的时间计算</span></span><br><span class="line">      <span class="keyword">long</span> heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</span><br><span class="line">      <span class="comment">//真正分析内存泄露以及路径</span></span><br><span class="line">      HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</span><br><span class="line">          .referenceName(reference.name)</span><br><span class="line">          .watchDurationMs(watchDurationMs)</span><br><span class="line">          .gcDurationMs(gcDurationMs)</span><br><span class="line">          .heapDumpDurationMs(heapDumpDurationMs)</span><br><span class="line">          .build();</span><br><span class="line">      heapdumpListener.analyze(heapDump);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DONE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>如何分析对象的被引用情况？</strong><br>遍历对象树。</p><h3 id="0x06-使用三方库手动分析hprof文件"><a href="#0x06-使用三方库手动分析hprof文件" class="headerlink" title="0x06 使用三方库手动分析hprof文件"></a>0x06 使用三方库手动分析hprof文件</h3><p>可使用square提供的堆文件分析库(<code>com.squareup.haha:haha:2.0.4</code>)对hprof文件进行解析得到对象树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Snapshot getSnapShot(String hprofPath) &#123;</span><br><span class="line">    File heapDumpFile = new File(hprofPath);</span><br><span class="line">    HprofBuffer hprofBuffer = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        hprofBuffer = new MemoryMappedFileBuffer(heapDumpFile);</span><br><span class="line">        HprofParser parser = new HprofParser(hprofBuffer);</span><br><span class="line">        return parser.parse();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-对象搜索"><a href="#6-1-对象搜索" class="headerlink" title="6.1 对象搜索"></a>6.1 对象搜索</h4><p>可根据解析获得的Snapshot对象完成对特定类名对象的查找操作。进而批量分析出当前内存中执行类型对象的数量和对象引用情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ClassObj&gt; classObjList = snapshot.findAllDescendantClasses(filterKey());</span><br><span class="line">List&lt;Instance&gt; allInstance = new ArrayList&lt;&gt;();</span><br><span class="line">for (ClassObj classObj : classObjList) &#123;</span><br><span class="line">    ClassObj instanceClass = snapshot.findClass(classObj.getClassName());</span><br><span class="line">    for (Instance instance : instanceClass.getInstancesList()) &#123;</span><br><span class="line">        allInstance.add(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6-2-对象树遍历"><a href="#6-2-对象树遍历" class="headerlink" title="6.2 对象树遍历"></a>6.2 对象树遍历</h4><p>可通过解析到的snapshot对象获取Root节点，自定义对象数爬虫，从Root节点遍历整个对象树，查找出异常对象的分布。如希望查找出当前对象树中，找到最大的组件类型有哪些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mDistanceVisitor = new RetainedSizeVisitor();</span><br><span class="line">snapshot.computeDominators();</span><br><span class="line">// 找到最大的组件类型</span><br><span class="line">mDistanceVisitor.doVisit(snapshot.getGCRoots());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author Ivonhoe on 2018/9/26.</span><br><span class="line"> */</span><br><span class="line">public class RetainedSizeVisitor extends NonRecursiveVisitor &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * App space中retained size最大的对象</span><br><span class="line">     */</span><br><span class="line">    private FixedSizePriorityQueue mMaxRetainedQueue;</span><br><span class="line"></span><br><span class="line">    private List&lt;HeapInstanceEntry&gt; maxInstance;</span><br><span class="line"></span><br><span class="line">    public RetainedSizeVisitor() &#123;</span><br><span class="line">        mMaxRetainedQueue = new FixedSizePriorityQueue(30);</span><br><span class="line">        maxInstance = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visitRootObj(RootObj root) &#123;</span><br><span class="line">        super.visitRootObj(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void defaultAction(Instance instance) &#123;</span><br><span class="line">        super.defaultAction(instance);</span><br><span class="line"></span><br><span class="line">        findTopNRetainedSizeInstanceInAppSpace(instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 找到retained大小最大的n个对象</span><br><span class="line">     */</span><br><span class="line">    private void findTopNRetainedSizeInstanceInAppSpace(Instance child) &#123;</span><br><span class="line">        if (child != null &amp;&amp; !(child instanceof ClassObj) &amp;&amp; child.getHeap().getId() == &apos;A&apos;) &#123;</span><br><span class="line">            mMaxRetainedQueue.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doVisit(Iterable&lt;? extends Instance&gt; startNodes) &#123;</span><br><span class="line">        super.doVisit(startNodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class FixedSizePriorityQueue &#123;</span><br><span class="line">        private PriorityQueue&lt;Instance&gt; queue;</span><br><span class="line">        private int maxSize; //堆的最大容量</span><br><span class="line"></span><br><span class="line">        public FixedSizePriorityQueue(int maxSize) &#123;</span><br><span class="line">            if (maxSize &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">            this.maxSize = maxSize;</span><br><span class="line">            this.queue = new PriorityQueue(maxSize, new Comparator&lt;Instance&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public int compare(Instance o1, Instance o2) &#123;</span><br><span class="line">                    return ((Long) o1.getTotalRetainedSize()).compareTo(o2.getTotalRetainedSize());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void add(Instance e) &#123;</span><br><span class="line">            if (queue.size() &lt; maxSize) &#123; //未达到最大容量，直接添加</span><br><span class="line">                queue.add(e);</span><br><span class="line">            &#125; else &#123; //队列已满</span><br><span class="line">                Instance peek = queue.peek();</span><br><span class="line">                if (peek != null &amp;&amp; (e.getTotalRetainedSize() &gt; peek.getTotalRetainedSize())) &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.add(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://developer.android.com/studio/command-line/dumpsys#meminfo" target="_blank" rel="noopener">https://developer.android.com/studio/command-line/dumpsys#meminfo</a><br><a href="https://cloud.tencent.com/developer/article/1070616" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1070616</a><br><a href="https://cloud.tencent.com/developer/article/1070616" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1070616</a><br><a href="http://gityuan.com/2016/01/02/memory-analysis-command/" target="_blank" rel="noopener">http://gityuan.com/2016/01/02/memory-analysis-command/</a><br><a href="https://blog.csdn.net/msf568834002/article/details/78881341" target="_blank" rel="noopener">https://blog.csdn.net/msf568834002/article/details/78881341</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;对内存问题的分析中一个必不可少的环节应该就是对hprof的分析了，常见的MAT和Leakcanry都是针对hprof文件的分析工具。这篇文章就记录下做内存分析的一般工具和分析步骤。&lt;/p&gt;
    
    </summary>
    
      <category term="Android性能优化" scheme="https://ivonhoe.github.io/categories/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android虚拟机的几个问题探究</title>
    <link href="https://ivonhoe.github.io/2019/06/27/android-vm-1/"/>
    <id>https://ivonhoe.github.io/2019/06/27/android-vm-1/</id>
    <published>2019-06-27T14:17:52.000Z</published>
    <updated>2019-06-27T14:28:32.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>这里说的Android虚拟机指运行在Android平台上的虚拟机，即日常遇到的Dalvik和ART虚拟机。这篇文章记录了自己对Android虚拟机几个问题的理解。只是个人学习和理解过程的记录，如有不当之处万望指正，邮箱<a href="mailto:yangfan3687@163.com" target="_blank" rel="noopener">yangfan3687@163.com</a>。也希望在面对下面这些所谓JVM常见问题时能给你带来不一样的思考。</p><ul><li>问题1：如何理解JVM内存模型？</li><li>问题2：什么是GC ROOTS？</li><li>问题3：Android虚拟机有没有分代回收？</li></ul><a id="more"></a><h3 id="0x02-堆转储HPROF协议"><a href="#0x02-堆转储HPROF协议" class="headerlink" title="0x02 堆转储HPROF协议"></a>0x02 堆转储HPROF协议</h3><p>在看JVM内存模型时，不妨先了解一下堆转储文件的协议。通过HPROF的问题格式可以大致了解JVM在内存中的划分情况。</p><h4 id="2-1-HPROF文件格式"><a href="#2-1-HPROF文件格式" class="headerlink" title="2.1 HPROF文件格式"></a>2.1 HPROF文件格式</h4><p>总的来说，HPROF文件分为两个大的部分，分别是Hprof Header和Hprof Body。其中Header部分又包括以下几个部分：</p><ul><li>fixed header：包含文件描述以’/0’结尾，id字段的长度信息等</li><li>string table：包含所有用到的字符串，包括类目、方法名、常量名等。</li><li>class table：包含所有的类信息</li><li>stack frame：包含所有线程的栈帧信息</li><li>stack trace：包含所有线程的虚拟机栈情况</li></ul><p>Body部分就是完整的jvm堆信息，将堆上的对象引用状况表述到文件中。其中在表述类对象是静态方法和静态成员变量时稍复杂，详细格式请查看 3.2 ~ 3.4。以下是HPROF文件格式的详细说明：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">“JAVA PROFILE 1.0.3/0”(Magic Code)</td><td style="text-align:center">4byte mIdSize (储存id的字节长度)</td><td style="text-align:center">8byte (Time Stamp)</td></tr><tr><td style="text-align:left">0x01(string table)</td><td style="text-align:center">4 byte</td><td style="text-align:center">4 byte(字符串length)</td><td style="text-align:center">mIdSize byte</td><td style="text-align:center">strlen(length) byte</td></tr><tr><td style="text-align:left">……</td><td style="text-align:center">……</td><td style="text-align:center">……</td><td style="text-align:center">……</td><td style="text-align:center">……</td></tr><tr><td style="text-align:left">0x02（class table)</td><td style="text-align:center">4 byte</td><td style="text-align:center">4 byte (length)</td><td style="text-align:center">4byte（class serial number）</td><td style="text-align:center">mIdSize byte</td><td style="text-align:center">4 byte（Stack trace serial number）</td><td style="text-align:center">4 byte（class name string id）</td></tr><tr><td style="text-align:left">……</td><td style="text-align:center">……</td><td style="text-align:center">……</td><td style="text-align:center">……</td><td style="text-align:center">……</td></tr><tr><td style="text-align:left">0x04（stack frame)</td><td style="text-align:center">4 byte</td><td style="text-align:center">4 byte (length)</td><td style="text-align:center">mIdSize byte</td><td style="text-align:center">mIdSize byte (methodName string id)</td><td style="text-align:center">mIdSize byte (methodSignature string id)</td><td style="text-align:center">mIdSize byte (sourceFile string id )</td><td>mIdSize byte (serial)</td><td>mIdSize byte (lineNumber )</td></tr><tr><td style="text-align:left">……</td><td style="text-align:center">……</td><td style="text-align:center">……</td><td style="text-align:center">……</td><td style="text-align:center">……</td></tr><tr><td style="text-align:left">0x05（stack trace)</td><td style="text-align:center">4 byte</td><td style="text-align:center">4 byte (length)</td><td style="text-align:center">4 byte serialNumber</td><td style="text-align:center">4 byte threadSerialNumber</td><td style="text-align:center">4 byte numFrames</td><td style="text-align:center">numFrames * mIdSize byte stack frame id</td></tr><tr><td style="text-align:left">……</td><td style="text-align:center">……</td><td style="text-align:center">……</td><td style="text-align:center">……</td><td style="text-align:center">……</td></tr><tr><td style="text-align:left">0x0C（HEAP DUMP)</td><td style="text-align:center">4 byte</td><td style="text-align:center">mIdSize byte (length)</td></tr><tr><td style="text-align:left">0xFF（ROOT_UNKNOWN)</td><td style="text-align:center">mIdSize byte string id</td></tr><tr><td style="text-align:left">0x01（ROOT_JNI_GLOBAL)</td><td style="text-align:center">mIdSize byte string id</td><td style="text-align:center">mIdSize byte jni global id</td></tr><tr><td style="text-align:left">0x02（ROOT_JNI_LOCAL)</td><td style="text-align:center">mIdSize byte string id</td><td style="text-align:center">4 byte thread serial number</td><td style="text-align:center">4 byte stack frame number</td></tr><tr><td style="text-align:left">0x03（ROOT_JAVA_FRAME)</td><td style="text-align:center">mIdSize byte string id</td><td style="text-align:center">4 byte thread serial number</td><td style="text-align:center">4 byte stack frame number</td></tr><tr><td style="text-align:left">0x04（ROOT_NATIVE_STACK)</td><td style="text-align:center">mIdSize byte string id</td><td style="text-align:center">4 thread serial number</td></tr><tr><td style="text-align:left">0x05（ROOT_STICKY_CLASS)</td><td style="text-align:center">mIdSize byte string id</td></tr><tr><td style="text-align:left">0x06（ROOT_THREAD_BLOCK)</td><td style="text-align:center">mIdSize byte string id</td><td style="text-align:center">4 thread serial number</td></tr><tr><td style="text-align:left">0x07（ROOT_MONITOR_USED)</td><td style="text-align:center">mIdSize byte string id</td></tr><tr><td style="text-align:left">0x08（ROOT_THREAD_OBJECT)</td><td style="text-align:center">mIdSize byte string id</td><td style="text-align:center">4 byte thread serial number</td><td style="text-align:center">4 byte stackSerialNumber</td></tr><tr><td style="text-align:left">0x20（ROOT_CLASS_DUMP)</td><td style="text-align:center">mIdSize byte string id</td></tr><tr><td style="text-align:left">0x21（ROOT_INSTANCE_DUMP)</td><td style="text-align:center">mIdSize byte string id</td><td style="text-align:center">mIdSize byte stackId</td><td style="text-align:center">mIdSize byte class id</td><td style="text-align:center">4 byte remaining</td></tr><tr><td style="text-align:left">0x22(ROOT_OBJECT_ARRAY_DUMP)</td><td style="text-align:center">mIdSize byte string id</td><td style="text-align:center">mIdSize byte stack id</td><td style="text-align:center">num elements</td><td style="text-align:center">mIdSize byte class id</td><td style="text-align:center">mIdSize * num elements(skip)</td></tr><tr><td style="text-align:left">0x23(ROOT_PRIMITIVE_ARRAY_DUMP)</td><td style="text-align:center">mIdSize byte string id</td><td style="text-align:center">mIdSize byte stack id</td><td style="text-align:center">4 byte num elements</td><td style="text-align:center">4 byte primitive type</td><td style="text-align:center">mIdSize * num elements(skip)</td></tr><tr><td style="text-align:left">0xC3(ROOT_PRIMITIVE_ARRAY_NODATA)</td><td style="text-align:center">mIdSize byte string id</td><td style="text-align:center">mIdSize byte stack id</td><td style="text-align:center">4 byte num elements</td><td style="text-align:center">4 byte primitive type</td><td style="text-align:center">4 * num elements(skip)</td></tr><tr><td style="text-align:left">0xfe(ROOT_HEAP_DUMP_INFO)</td><td style="text-align:center">mIdSize byte heap id</td><td style="text-align:center">mIdSize byte heap name id(string id)</td></tr><tr><td style="text-align:left">0x89(ROOT_INTERNED_STRING)</td><td style="text-align:center">mIdSize byte string id</td></tr><tr><td style="text-align:left">0x8a(ROOT_FINALIZING)</td><td style="text-align:center">mIdSize byte string id</td></tr><tr><td style="text-align:left">0x8b(ROOT_DEBUGGER)</td><td style="text-align:center">mIdSize byte string id</td></tr><tr><td style="text-align:left">0x8c(ROOT_REFERENCE_CLEANUP)</td><td style="text-align:center">mIdSize byte string id</td></tr><tr><td style="text-align:left">0x8d(ROOT_VM_INTERNAL)</td><td style="text-align:center">mIdSize byte string id</td></tr><tr><td style="text-align:left">0x8e(ROOT_JNI_MONITOR)</td><td style="text-align:center">mIdSize byte string id</td><td style="text-align:center">4 byte thread serial number</td><td style="text-align:center">4 byte stack frame number</td></tr><tr><td style="text-align:left">0x90(ROOT_UNREACHABLE)</td><td style="text-align:center">mIdSize byte    string id</td></tr><tr><td style="text-align:left">0x1C（HEAP DUMP SEGMENT)</td><td style="text-align:center">4 byte</td><td style="text-align:center">mIdSize byte (length)</td></tr></tbody></table><h4 id="2-2-ROOT-CLASS-DUMP的格式"><a href="#2-2-ROOT-CLASS-DUMP的格式" class="headerlink" title="2.2 ROOT_CLASS_DUMP的格式"></a>2.2 ROOT_CLASS_DUMP的格式</h4><table><thead><tr><th style="text-align:left"></th><th style="text-align:center"></th><th></th></tr></thead><tbody><tr><td style="text-align:left">0x20(ROOT_CLASS_DUMP)</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">id</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">stack serial number</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">super class id</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">class loader id</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">signeres id</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">protection domain id</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">reserved</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">reserved</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">instance size</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">const pool num entries</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">2 * num entries</td></tr><tr><td style="text-align:left">static fields num entries</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">static fields</td><td style="text-align:center">static fields num entries * (static fields)，下面会再单独列出来</td></tr><tr><td style="text-align:left">instance fields num entries</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">instance fields</td><td style="text-align:center">instance fields num entries * (instance fields)</td></tr></tbody></table><h4 id="2-3-0x20-ROOT-CLASS-DUMP-Static-Fields"><a href="#2-3-0x20-ROOT-CLASS-DUMP-Static-Fields" class="headerlink" title="2.3 0x20(ROOT_CLASS_DUMP).Static Fields"></a>2.3 0x20(ROOT_CLASS_DUMP).Static Fields</h4><table><thead><tr><th style="text-align:left"></th><th style="text-align:center"></th><th style="text-align:center"></th><th></th></tr></thead><tbody><tr><td style="text-align:left">4</td><td style="text-align:center">1</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">static fields id</td><td style="text-align:center">static fields type</td><td style="text-align:center">type size</td></tr></tbody></table><h4 id="2-4-0x20-ROOT-CLASS-DUMP-Instance-Fields"><a href="#2-4-0x20-ROOT-CLASS-DUMP-Instance-Fields" class="headerlink" title="2.4 0x20(ROOT_CLASS_DUMP).Instance Fields"></a>2.4 0x20(ROOT_CLASS_DUMP).Instance Fields</h4><table><thead><tr><th style="text-align:left"></th><th style="text-align:center"></th><th></th></tr></thead><tbody><tr><td style="text-align:left">4</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">instance id</td><td style="text-align:center">instance type</td></tr></tbody></table><h4 id="2-5-HEAP-DUMP和HEAP-DUMP-SEGMENT的区别"><a href="#2-5-HEAP-DUMP和HEAP-DUMP-SEGMENT的区别" class="headerlink" title="2.5 HEAP DUMP和HEAP DUMP SEGMENT的区别"></a>2.5 HEAP DUMP和HEAP DUMP SEGMENT的区别</h4><p>如果你仔细研究了上面的内容的话，可能你就会有这样一个问题，HEAP DUMP和HEAP DUMP SEGMENT有什么区别？为什么要有两个标记？<br>其实堆转储的hprof文件格式中，原本是使用4字节32位存储堆对象的 “HEAP DUMP” (0x0C)的区块长度，但同时也就限制了HEAP DUMP的大小必须在4GB以内。在出现这个问题的情况下，在HPROF文件中新增了”HEAP DUMP SEGMENT” (0x1C)的格式，用来将超过4GB的JVM堆对象信息分别存储到文件的多个区块中。</p><p><a href="https://www.ibm.com/developerworks/community/blogs/kevgrig/entry/be_careful_with_hprof_heapdumps_bigger_than_4gb?lang=en_us" target="_blank" rel="noopener">Be Careful with HPROF Heapdumps Bigger than 4GB </a> @2013-04-16</p><h3 id="0x03-理解JVM内存模型"><a href="#0x03-理解JVM内存模型" class="headerlink" title="0x03 理解JVM内存模型"></a>0x03 理解JVM内存模型</h3><p><img src="/res/android-vm-1/jvm-memory-model.png" alt="jvm-memory-model.png"></p><ol><li><p><strong>程序计数器</strong><br>在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域。</p></li><li><p><strong>Java虚拟机栈</strong><br>线程私有，每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。</p></li><li><p><strong>本地方法栈</strong><br>线程私有，本地方法栈的功能和特点类似于虚拟机栈，不同的是，本地方法栈服务的对象是JVM执行的native方法，而虚拟机栈服务的是JVM执行的java方法。我们常见的HotSpot虚拟机选择合并了虚拟机栈和本地方法栈。</p></li><li><p><strong>Java堆</strong><br>所有线程共享的内存区域，所有对象实例及数组都要在堆上分配内存。</p></li><li><p><strong>方法区</strong><br>所有线程共享的内存区域，为了区分堆，又被称为非堆。用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。</p></li></ol><p>在谈到JVM内存结构时，从HPROF文件的header和body部分就有体现，从数据上划分结构就可以分为方法区（包括运行时常量池，也就是header中string table的部分）、java堆（body部分）、虚拟机栈、本地方法栈和程序计数器。其中方法区和java堆部分是所有线程共享的数据区，其他则为线程独有的数据区。<strong>为什么会有这样的结构划分和设计？</strong><br>先看设计内存的目的，是因为随着CPU运转速度越来越快，磁盘远远跟不上CPU的读写速度，才设计了内存。但是随着CPU的发展，内存的读写速度也远远跟不上CPU的读写速度，为了解决这一纠纷，CPU厂商在每颗CPU上加入了高速缓存来缓解这种症状。基于高速缓存的存储交互很好的解决了处理器与内存之间的矛盾，也引入了新的问题：缓存一致性问题。在多处理器系统中，每个处理器有自己的高速缓存，而他们又共享同一块内存。回到JVM的内存模型中， Java中通过多线程机制使得多个任务同时执行处理，所有的线程共享JVM内存区域main memory，而每个线程又单独的有自己的工作内存，当线程与内存区域进行交互时，数据从主存拷贝到工作内存，进而交由线程处理。这样也就说的通了，为啥在JVM中有的区域是线程共享的，有的区域是线程独享的。</p><h3 id="0x04-什么是GC和GC-ROOTS？"><a href="#0x04-什么是GC和GC-ROOTS？" class="headerlink" title="0x04 什么是GC和GC_ROOTS？"></a>0x04 什么是GC和GC_ROOTS？</h3><h4 id="4-1-什么是GC"><a href="#4-1-什么是GC" class="headerlink" title="4.1 什么是GC"></a>4.1 什么是GC</h4><p>垃圾回收(Garbage Collection，简称GC)，是垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。这种机制也不单单只有Java虚拟机才有，ObjectC和C#都有自己相应的垃圾回收机制，垃圾回收机制是帮助程序员自动管理对象内存空间的机制。</p><h4 id="4-2-什么是GC-ROOTS"><a href="#4-2-什么是GC-ROOTS" class="headerlink" title="4.2 什么是GC ROOTS"></a>4.2 什么是GC ROOTS</h4><p>常见的垃圾回收方式，引用计数算法和根搜索算法。<br><strong>引用计数</strong>就像是每个对象有个账本，当一个对象被另一个对象引用时该对象的引用计数器+1，当引用失效时引用计数器-1，任何引用计数为0的对象可以被当作垃圾收集。引用计数有一个先天的缺陷，那就是多个对象相互持有引用形成一个引用环是，那么环中的所有对象引用计数都不为0，这时这些对象都不能被垃圾回收器回收。<br><strong>根节点搜索</strong>指的是从根节点集合出发找到所有引用链可达对象，当一个对象到根节点集合（GC ROOTS）没有任何引用链存在时就证明此对象是不可用的。从对比JVM规范的垃圾回收根节点(来自：<a href="http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&amp;cp=37_2_3" target="_blank" rel="noopener">Garbage Collection Roots</a>)、HPROF文件协议中的GC ROOTS tag类型和square haha库源码中对GC ROOTS的类型定义，参照下表。</p><table><thead><tr><th style="text-align:left">JVM规范名称</th><th style="text-align:center">HPROF中的TAG</th><th style="text-align:center">haha库中的RootType枚举类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:left">System Class</td><td style="text-align:center">0x05</td><td style="text-align:center">RootType.SYSTEM_CLASS</td><td style="text-align:center">被bootstrap/system class加载器加载的类，例如所有rt.jar中包名为 java.util.*的类</td></tr><tr><td style="text-align:left">JNI Local</td><td style="text-align:center">0x02</td><td style="text-align:center">RootType.NATIVE_LOCAL</td><td style="text-align:center">native代码中的本地变量，例如user defined JNI code or JVM internal code</td></tr><tr><td style="text-align:left">JNI Global</td><td style="text-align:center">0x01</td><td style="text-align:center">RootType.NATIVE_STATIC</td><td style="text-align:center">native中的全局变量，例如user defined JNI code or JVM internal code</td></tr><tr><td style="text-align:left">Thread Block</td><td style="text-align:center">0x06</td><td style="text-align:center">RootType.THREAD_BLOCK</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Thread</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Busy Monitor</td><td style="text-align:center">0x07</td><td style="text-align:center">RootType.BUSY_MONITOR</td><td style="text-align:center">所有调用 wait()、 notify()方法的， 或者同步的。For example, by calling synchronized(Object) or by entering a synchronized method. Static method means class, non-static method means object.</td></tr><tr><td style="text-align:left">Java Local</td><td style="text-align:center">0x03</td><td style="text-align:center">RootType.JAVA_LOCAL</td><td style="text-align:center">本地变量，例如线程栈帧中的参数和方法</td></tr><tr><td style="text-align:left">Native Stack</td><td style="text-align:center">0x04</td><td style="text-align:center">RootType.NATIVE_STACK</td><td style="text-align:center">In or out parameters in native code, such as user defined JNI code or JVM internal code. This is often the case as many methods have native parts and the objects handled as method parameters become GC roots. For example, parameters used for file/network I/O methods or reflection</td></tr><tr><td style="text-align:left">Finalizable</td><td style="text-align:center">0x8a</td><td style="text-align:center">RootType.FINALIZING</td><td style="text-align:center">在finalizer等待队列里的对象</td></tr><tr><td style="text-align:left">Unfinalized</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Unreachable</td><td style="text-align:center">0x90</td><td style="text-align:center">RootType.UNREACHABLE</td><td style="text-align:center">从其他根节点都无法到达的对象</td></tr><tr><td style="text-align:left">Java Stack Frame</td><td style="text-align:center">0x03</td><td style="text-align:center">RootType.JAVA_LOCAL</td><td style="text-align:center">A Java stack frame, holding local variables. Only generated when the dump is parsed with the preference set to treat Java stack frames as objects.</td></tr><tr><td style="text-align:left">Unknown</td><td style="text-align:center">0xff</td><td style="text-align:center">RootType.UNKNOWN</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">0x89</td><td style="text-align:center">RootType.INTERNED_STRING</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">0x8b</td><td style="text-align:center">RootType.DEBUGGER</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">0x8c</td><td style="text-align:center">RootType.REFERENCE_CLEANUP</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">0x8d</td><td style="text-align:center">RootType.VM_INTERNAL</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">0x8e</td><td style="text-align:center">RootType.NATIVE_MONITOR</td></tr></tbody></table><p>对照上面这个表总结起来，所谓JVM GC Roots是进行垃圾回收时根节点的集合。大致包含以下几个方面：</p><ul><li>所有Java线程当前活跃的栈帧所指向GC堆里的对象的引用，换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。</li><li>VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。</li><li>所有当前被加载的Java类</li><li>JNI handles，包括global handles和local handles</li><li>Java类的引用类型静态变量</li><li>Java类的运行时常量池里的引用类型常量（String或Class类型）</li><li>String常量池（StringTable）里的引用</li></ul><p>按照根搜索GC的思想，从根节点出发的找到的对象就被认定为存活的，其他的对象都是“无用的”，但是GC ROOTS的集合不应该是一成不变的，特别是面对分代GC时。为啥这样说呢？分代GC是一种部分收集（partial collection）的做法。在执行部分收集时，从GC堆的非收集部分指向收集部分的引用，也必须作为GC roots的一部分。具体到分两代的分代式GC来说，如果第0代叫做young gen，第1代叫做old gen，那么如果有minor GC / young GC只收集young gen里的垃圾，则young gen属于“收集部分”，而old gen属于“非收集部分”，那么从old gen指向young gen的引用就必须作为minor GC / young GC的GC ROOTS的一部分。所以针对一次GC来说，GC ROOTS的类型类型范围未必只有jvm规范定义中所列举的那几种情况。</p><h3 id="0x05-Android虚拟机有分代GC吗？"><a href="#0x05-Android虚拟机有分代GC吗？" class="headerlink" title="0x05 Android虚拟机有分代GC吗？"></a>0x05 Android虚拟机有分代GC吗？</h3><p>Android Q开始google才为ART虚拟机添加分代收集机制。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.cnblogs.com/kingszelda/p/7226080.html" target="_blank" rel="noopener">JVM内存模型与GC算法</a><br><a href="https://my.oschina.net/u/217380/blog/1507542" target="_blank" rel="noopener">Android Hprof 协议</a><br><a href="https://www.zhihu.com/question/53613423/answer/135743258" target="_blank" rel="noopener">java的gc为什么要分代？RednaxelaFX的回答</a><br><a href="https://cloud.tencent.com/developer/article/1405124" target="_blank" rel="noopener">Android Q Beta 正式发布 | 精于形，安于内</a><br><a href="https://www.cnblogs.com/dingyingsi/p/3760447.html" target="_blank" rel="noopener">https://www.cnblogs.com/dingyingsi/p/3760447.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;这里说的Android虚拟机指运行在Android平台上的虚拟机，即日常遇到的Dalvik和ART虚拟机。这篇文章记录了自己对Android虚拟机几个问题的理解。只是个人学习和理解过程的记录，如有不当之处万望指正，邮箱&lt;a href=&quot;mailto:yangfan3687@163.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;yangfan3687@163.com&lt;/a&gt;。也希望在面对下面这些所谓JVM常见问题时能给你带来不一样的思考。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题1：如何理解JVM内存模型？&lt;/li&gt;
&lt;li&gt;问题2：什么是GC ROOTS？&lt;/li&gt;
&lt;li&gt;问题3：Android虚拟机有没有分代回收？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习总结" scheme="https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Android系统上绘制圆角和阴影的几种姿势</title>
    <link href="https://ivonhoe.github.io/2019/01/29/android-corner-shadow/"/>
    <id>https://ivonhoe.github.io/2019/01/29/android-corner-shadow/</id>
    <published>2019-01-29T03:41:57.000Z</published>
    <updated>2019-06-27T14:20:48.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>在实际的开发工程中，对视图增加圆角和阴影效果的绘制是比较常见的需求，Android系统提供了一系列的方法以帮助开发者实现基础的视图圆角和阴影效果，但在面对实际的视觉需求时，想要完美达到视觉设计师的设计要求就难免需要了解一些基础的绘图原理和绘图方法才能达到特殊的设计需求，这里就简单对比和总结了常见的圆角和阴影的绘图方法。</p><a id="more"></a><h3 id="0x02-圆角"><a href="#0x02-圆角" class="headerlink" title="0x02 圆角"></a>0x02 圆角</h3><h4 id="2-1-View的圆角背景实现圆角效果"><a href="#2-1-View的圆角背景实现圆角效果" class="headerlink" title="2.1 View的圆角背景实现圆角效果"></a>2.1 View的圆角背景实现圆角效果</h4><p>使用原生提供的ShapeDrawable实现背景。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#ff0000"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:topLeftRadius</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:topRightRadius</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:bottomRightRadius</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:bottomLeftRadius</span>=<span class="string">"10dp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="/res/shadow/android_corner_shadow_0.png" alt="Alt text"></p><h4 id="2-2-使用圆角贴图实现圆角效果"><a href="#2-2-使用圆角贴图实现圆角效果" class="headerlink" title="2.2 使用圆角贴图实现圆角效果"></a>2.2 使用圆角贴图实现圆角效果</h4><p>在介绍“贴图”之前先说明在Android绘图相关的两个必备知识，分布是Paint Style和Path。</p><h5 id="2-2-1-Paint-Style"><a href="#2-2-1-Paint-Style" class="headerlink" title="2.2.1 Paint Style"></a>2.2.1 Paint Style</h5><p>在用画笔（Paint）的时候有三种Style，选择不同的画笔样式时就可达到不同的画笔效果，分别是 </p><ul><li>Paint.Style.STROKE 只绘制图形轮廓(描边) </li><li>Paint.Style.FILL 只绘制图形内容 </li><li>Paint.Style.FILL_AND_STROKE 既绘制轮廓也绘制内容<br><img src="/res/shadow/android_corner_shadow_1.png" alt="Alt text"></li></ul><h5 id="2-2-2-Path"><a href="#2-2-2-Path" class="headerlink" title="2.2.2 Path"></a>2.2.2 Path</h5><p>当我们在想要绘制一些形状时，Canvas提供了一些基础形状的绘制方法，如圆形、矩形、椭圆等。你只需要选择相应的绘制方法并设置你想要的绘制参数就能绘制出你想要的简单图形效果。但对于那些复杂一点的图形则没法去绘制，如一个心形、正多边形、五角星等，使用Path不仅能够绘制简单图形，也可以绘制这些比较复杂的图形。Path封装了由直线和曲线(二次，三次贝塞尔曲线等)构成的几何路径。你能用Canvas中的drawPath来把这条路径画出来(同样支持Paint的不同绘制模式)，也可以用于剪裁画布和根据路径绘制文字。</p><h5 id="2-2-3-如何制作圆角贴图"><a href="#2-2-3-如何制作圆角贴图" class="headerlink" title="2.2.3 如何制作圆角贴图"></a>2.2.3 如何制作圆角贴图</h5><p><strong>以左上角贴图实现为例，使用Path约束绘图范围</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RectF fakeCornerRectF = sRectF;</span><br><span class="line">fakeCornerRectF.set(0, 0, mCornerRoundRadius * 2, mCornerRoundRadius * 2);</span><br><span class="line">// 绘制左上圆角背景</span><br><span class="line">if (mTopLeftCorner) &#123;</span><br><span class="line">    fakeCornerRectF.offsetTo(left - mCornerOffset, top - mCornerOffset);</span><br><span class="line">    mCompatibilityModePath.rewind();</span><br><span class="line">    mCompatibilityModePath.moveTo(left - mCornerOffset, top - mCornerOffset);</span><br><span class="line">    mCompatibilityModePath.lineTo(left + mCornerRoundRadius, top - mCornerOffset);</span><br><span class="line">    mCompatibilityModePath.arcTo(fakeCornerRectF, START_TOP, -QUARTER_CIRCLE);</span><br><span class="line">    mCompatibilityModePath.close();</span><br><span class="line">    canvas.drawPath(mCompatibilityModePath, mBackgroundPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/res/shadow/android_corner_shadow_2.png" alt="Alt text"></p><p><strong>使用Paint.Style.FILL画笔绘制，将贴图效果绘制在ImageView容器的（0，0）坐标上。即可达到想要的圆角效果</strong></p><h4 id="2-3-对Bitmap的裁剪实现圆角效果"><a href="#2-3-对Bitmap的裁剪实现圆角效果" class="headerlink" title="2.3 对Bitmap的裁剪实现圆角效果"></a>2.3 对Bitmap的裁剪实现圆角效果</h4><p>例如使用android support包里的RoundedBitmapDrawable，创建一个被裁剪圆角的BitmapDrawable。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RoundedBitmapDrawable drawable = RoundedBitmapDrawableFactory.create(mContext.getResources(), bitmap);</span><br><span class="line">drawable.setCornerRadius(<span class="number">40</span>);</span><br></pre></td></tr></table></figure></p><h4 id="2-4-对Canvas画板做裁剪实现圆角效果"><a href="#2-4-对Canvas画板做裁剪实现圆角效果" class="headerlink" title="2.4 对Canvas画板做裁剪实现圆角效果"></a>2.4 对Canvas画板做裁剪实现圆角效果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = getPaddingLeft();</span><br><span class="line">    <span class="keyword">int</span> top = getPaddingTop();</span><br><span class="line">    <span class="keyword">int</span> right = canvas.getWidth() - getPaddingRight();</span><br><span class="line">    <span class="keyword">int</span> bottom = getHeight() - getPaddingBottom();</span><br><span class="line"></span><br><span class="line">    mCanvasRect.set(left, top, right, bottom);</span><br><span class="line">    mCanvasPath.reset();</span><br><span class="line">    mCanvasPath.addRoundRect(mCanvasRect, mRx, mRy, Path.Direction.CW);</span><br><span class="line">    canvas.clipPath(mCanvasPath);</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x03-阴影"><a href="#0x03-阴影" class="headerlink" title="0x03 阴影"></a>0x03 阴影</h3><h4 id="3-1-elevation属性和translationZ属性"><a href="#3-1-elevation属性和translationZ属性" class="headerlink" title="3.1 elevation属性和translationZ属性"></a>3.1 elevation属性和translationZ属性</h4><p>UI 控件的elevation属性可以设置其高度，呈现在界面中的直观效果就是阴影效果，在 xml 布局文件中，通过 android:elevation 属性设置，在 java 代码中通过 View 类提供的setElevation()方法设置。但是这个属性存在版本兼容问题，是 Android 5.0 引进的 API。所以，当 minSdkVersion 值小于21时，系统会在 xml 的对应使用地方给出一个 lint 提示：</p><p><code>Attribute elevation is only used in API level 21 and higher</code></p><p>当然你也可以选择忽略这个提示，或者使用tools:targetApi属性消除这个提示，这样做的话，在低于5.0版本的系统中将不会出现阴影效果。然而，有一个更好的办法做到兼容，那就是借助ViewCompat这个万能的兼容类,使View 的 elevation 属性兼容至低版本中：</p><p><code>ViewCompat.setElevation(View view, float elevation)</code></p><p>注意：尤其要注意，视图的阴影一定是由有轮廓的视图投射出来的。简单来说，就是需要设置控件的背景，即 android:background 属性。我们可以选择图片作为背景，也可以使用 <shape> 标签定义一个 drawable 形状。</shape></p><h4 id="3-2-使用-9图实现阴影效果"><a href="#3-2-使用-9图实现阴影效果" class="headerlink" title="3.2 使用.9图实现阴影效果"></a>3.2 使用.9图实现阴影效果</h4><p>说到阴影效果最简单最省力的方法莫过于设置一个.9的背景图啦！这里推荐一个站点，可以在线制作.9阴影图。<a href="http://inloop.github.io/shadow4android/" target="_blank" rel="noopener">http://inloop.github.io/shadow4android/</a></p><h4 id="3-3-使用模糊画笔绘制阴影效果"><a href="#3-3-使用模糊画笔绘制阴影效果" class="headerlink" title="3.3 使用模糊画笔绘制阴影效果"></a>3.3 使用模糊画笔绘制阴影效果</h4><p><img src="/res/shadow/android_corner_shadow_3.png" alt="Alt text"></p><p>先看想要做到的阴影效果，想要在红色的轮播banner下方显示一条红色的阴影效果。用已知的阴影方案比如设置视图的Z轴高度或者设置.9阴影背景都无法实现这种效果。</p><p>可以将实现上图的局部阴影效果的绘制步骤分解成两层：</p><ol><li>自定义一个ShadowLayout容器，在onDraw方法中重写绘制步骤</li><li>如何绘制阴影效果？使用带有BlurMaskFilter效果的画笔在合适的地方绘制一个椭圆阴影。可以理解成先用一个模糊画笔先画眉，再在合适的位置上绘制想要的图片。画眉效果如下图：</li></ol><p><img src="/res/shadow/android_corner_shadow_4.png" alt="Alt text"></p><p>这里有个前提，需要关闭当前View的硬件加速功能。<code>setLayerType(LAYER_TYPE_SOFTWARE, null)</code>。具体的实现代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    drawShadow(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawShadow</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shadowView != <span class="keyword">null</span> &amp;&amp; shadowOn) &#123;</span><br><span class="line">        canvas.drawOval(getDrawOvalRect(), getShadowPaint());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getShadowColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!runPalette) &#123;</span><br><span class="line">        <span class="keyword">return</span> shadowColor;</span><br><span class="line">    &#125;</span><br><span class="line">    runPalette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (shadowView <span class="keyword">instanceof</span> ImageView) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((ImageView) shadowView).getDrawable() <span class="keyword">instanceof</span> ColorDrawable) &#123;</span><br><span class="line">            shadowColor = getDarkerColor(((ColorDrawable) ((ImageView) shadowView).getDrawable()).getColor());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((ImageView) shadowView).getDrawable() <span class="keyword">instanceof</span> BitmapDrawable) &#123;</span><br><span class="line">            Bitmap bitmap = ((BitmapDrawable) ((ImageView) shadowView).getDrawable()).getBitmap();</span><br><span class="line">            Palette.Swatch mSwatch = Palette.from(bitmap).generate().getDominantSwatch();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != mSwatch) &#123;</span><br><span class="line">                <span class="keyword">int</span> rgb = mSwatch.getRgb();</span><br><span class="line">                shadowColor = <span class="number">0x4C000000</span> | (Color.red(rgb) &lt;&lt; <span class="number">16</span>) | (Color.green(rgb) &lt;&lt; <span class="number">8</span>) | Color.blue(rgb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shadowColor = Color.TRANSPARENT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadowColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Paint <span class="title">getShadowPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shadowView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rgb = getShadowColor();</span><br><span class="line">        shadowPaint.setColor(rgb);</span><br><span class="line">        shadowPaint.setMaskFilter(<span class="keyword">new</span> BlurMaskFilter(paddingBottom, BlurMaskFilter.Blur.NORMAL));</span><br><span class="line"><span class="comment">//            shadowPaint.setShadowLayer(radius, 0, shadowDimen, rgb);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadowPaint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="0x04-参考文档"><a href="#0x04-参考文档" class="headerlink" title="0x04 参考文档"></a>0x04 参考文档</h3><p><a href="https://yifeng.studio/2017/02/26/android-elevation-and-shadow/" target="_blank" rel="noopener">https://yifeng.studio/2017/02/26/android-elevation-and-shadow/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;在实际的开发工程中，对视图增加圆角和阴影效果的绘制是比较常见的需求，Android系统提供了一系列的方法以帮助开发者实现基础的视图圆角和阴影效果，但在面对实际的视觉需求时，想要完美达到视觉设计师的设计要求就难免需要了解一些基础的绘图原理和绘图方法才能达到特殊的设计需求，这里就简单对比和总结了常见的圆角和阴影的绘图方法。&lt;/p&gt;
    
    </summary>
    
      <category term="学习总结" scheme="https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Android性能优化之ANR分析记录(一)</title>
    <link href="https://ivonhoe.github.io/2018/10/14/android-anr-1/"/>
    <id>https://ivonhoe.github.io/2018/10/14/android-anr-1/</id>
    <published>2018-10-14T13:09:15.000Z</published>
    <updated>2018-10-16T09:59:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>Application Not Responding（简称:ANR）指应用中一些特定的事件（如用户触摸事件、广播等）在应用的主线程没有在规定的时间内处理完，系统自动做出终止应用运行的响应。问题出现的原因主要是两个方面：</p><blockquote><ol><li>应用进程自身引起的，例如：主线程阻塞、挂起、死循环</li><li>应用进程的其他线程的CPU占用率高，使得主线程无法抢占到CPU时间片</li></ol></blockquote><p>常见的三种ANR类型：</p><ol><li>KeyDispatchTimeout(谷歌默认5s，MTK平台上是8s): 主要类型按键或触摸事件在特定时间内无响应</li><li>BroadcastTimeout(10s): 主要是BroadcastRecevier在规定时间无法处理完成。前台广播超时时间是10s,后台广播超时是60s,这类超时没有提示框弹出。代码见AMS的<code>BROADCAST_FG_TIMEOUT</code>和<code>BROADCAST_BG_TIMEOUT</code>。</li><li>ServiceTimeout(20s): Service在规定时间内无法处理完成操作，即会报出服务超时，这类ANR同样没有提示框出现。超时时间，前台Service是20s，后台Service是200s。代码见ActivityServices的<code>SERVICE_TIMEOUT</code>和<code>SERVICE_BACKGROUND_TIMEOUT</code>。</li></ol><a id="more"></a><h3 id="0x02-KeyDispatchingTimedOut"><a href="#0x02-KeyDispatchingTimedOut" class="headerlink" title="0x02 KeyDispatchingTimedOut"></a>0x02 KeyDispatchingTimedOut</h3><h4 id="2-1-错误实例"><a href="#2-1-错误实例" class="headerlink" title="2.1 错误实例"></a>2.1 错误实例</h4><p>先看下面的错误实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步操作数组</span></span><br><span class="line">    saveListToDb();</span><br><span class="line"></span><br><span class="line">    traverseList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverseList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Handler handler = <span class="keyword">new</span> Handler();</span><br><span class="line">    handler.post(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mList) &#123;</span><br><span class="line">        <span class="comment">// todo something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveListToDb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mList) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// todo save list</span></span><br><span class="line">                    Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-adb日志和traces分析"><a href="#2-2-adb日志和traces分析" class="headerlink" title="2.2 adb日志和traces分析"></a>2.2 adb日志和traces分析</h4><p>在子线程保存数据到文件或数据库(这里用sleep操作模拟耗时io操作)，如果同时可能涉及到在主线程操作同一个锁对象的情况在，这时你是否会习惯的使用synchronized关键词保证list的同步呢？当在主线程和异步线程产生了对相同对象的竞争关系，那这时就很容易出现主线程的阻塞，而阻塞的时间长短就取决于主线程啥时候获取到竞争对象。而此时反馈在系统层面当用户操作不会得到响应，最终应用以ANR的形式退出。运行上面的错误代码你会获取类似下面的ANR日志信息<br><code>Input dispatching timed out (Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.)</code><br>查看虚拟机trace文件输出目录<code>adb shell getprop dalvik.vm.stack-trace-file</code>，再查看手机目录下<code>/data/anr/traces.txt</code>的文件内容，会发现main线程在等待释放锁<0x0af98db2>,而这个锁正在被thread 10所持有</0x0af98db2></p><p><img src="/res/anr-1/anr-1.png" alt="Alt text"></p><p>再查看tid=10的线程的线程状态，该线程正在sleeping，这也印证了上面实例的代码，主线程在等待一个sleep线程释放锁而导致了ANR。当然在实际项目中的日志和原因未必会这么明显，但形如实例的错误代码确实是很常见的场景。</p><p><img src="/res/anr-1/anr-2.png" alt="Alt text"></p><h4 id="2-3-traces-txt关键信息注"><a href="#2-3-traces-txt关键信息注" class="headerlink" title="2.3 traces.txt关键信息注"></a>2.3 traces.txt关键信息注</h4><ol><li>pid为进程id，sysTid=pid，这里主线程的线程号=进程号，prio=5为线程优先级</li><li>当一个线程占有一个锁的时候，会打印-locked<0xxxxxxx></0xxxxxxx></li><li>当该线程正在等待别的线程释放该锁，会打印waiting to lock <0xxxxxx></0xxxxxx></li><li>如果代码中有wait()调用的话，首先是locked，然后会打印waiting on <0xxxxxx></0xxxxxx></li></ol><h4 id="2-4-ANR-Input-event-dispatching-timed-out-Reason"><a href="#2-4-ANR-Input-event-dispatching-timed-out-Reason" class="headerlink" title="2.4  ANR Input event dispatching timed out Reason"></a>2.4  ANR Input event dispatching timed out Reason</h4><p>参考<a href="http://gityuan.com/2017/01/01/input-anr/的input-anr异常原因的总结，input" target="_blank" rel="noopener">http://gityuan.com/2017/01/01/input-anr/的input-anr异常原因的总结，input</a> anr主要分为以下几类。</p><ol><li>无窗口, 有应用：Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.</li><li>窗口暂停: Waiting because the [targetType] window is paused.</li><li>窗口未连接: Waiting because the [targetType] window’s input channel is not registered with the input dispatcher. The window may be in the process of being removed.</li><li>窗口连接已死亡：Waiting because the [targetType] window’s input connection is [Connection.Status]. The window may be in the process of being removed.</li><li>窗口连接已满：Waiting because the [targetType] window’s input channel is full. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度].</li><li>按键事件，输出队列或事件等待队列不为空：Waiting to send key event because the [targetType] window has not finished processing all of the input events that were previously delivered to it. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度].</li><li>非按键事件，事件等待队列不为空且头事件分发超时500ms：Waiting to send non-key event because the [targetType] window has not finished processing certain input events that were delivered to it over 500ms ago. Wait queue length: [waitQueue长度]. Wait queue head age: [等待时长].</li></ol><ul><li>targetType: 取值为”focused”或者”touched”</li><li>Connection.Status: 取值为”NORMAL”，”BROKEN”，”ZOMBIE”</li></ul><p>所以如2.1中实例代码，当ANR发生在Activity的onCreate流程中时，你讲看到<code>无窗口, 有应用</code>的日志信息，当ANR发生在对某个View的OnClickListener中时，你将从日志中获取<code>事件等待队列不为空且头事件分发超时500ms</code>的信息，这样通过不同的日志信息就可大致定位ANR出现的用户场景，进而方便定位出问题代码。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://yuanfentiank789.github.io/2017/09/05/ANR%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://yuanfentiank789.github.io/2017/09/05/ANR%E5%88%86%E6%9E%90/</a><br><a href="http://gityuan.com/2017/01/01/input-anr/" target="_blank" rel="noopener">http://gityuan.com/2017/01/01/input-anr/</a><br><a href="https://maoao530.github.io/2017/02/21/anr-analyse/" target="_blank" rel="noopener">https://maoao530.github.io/2017/02/21/anr-analyse/</a><br><a href="http://rayleeya.iteye.com/blog/1955657" target="_blank" rel="noopener">http://rayleeya.iteye.com/blog/1955657</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;Application Not Responding（简称:ANR）指应用中一些特定的事件（如用户触摸事件、广播等）在应用的主线程没有在规定的时间内处理完，系统自动做出终止应用运行的响应。问题出现的原因主要是两个方面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;应用进程自身引起的，例如：主线程阻塞、挂起、死循环&lt;/li&gt;
&lt;li&gt;应用进程的其他线程的CPU占用率高，使得主线程无法抢占到CPU时间片&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;常见的三种ANR类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;KeyDispatchTimeout(谷歌默认5s，MTK平台上是8s): 主要类型按键或触摸事件在特定时间内无响应&lt;/li&gt;
&lt;li&gt;BroadcastTimeout(10s): 主要是BroadcastRecevier在规定时间无法处理完成。前台广播超时时间是10s,后台广播超时是60s,这类超时没有提示框弹出。代码见AMS的&lt;code&gt;BROADCAST_FG_TIMEOUT&lt;/code&gt;和&lt;code&gt;BROADCAST_BG_TIMEOUT&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;ServiceTimeout(20s): Service在规定时间内无法处理完成操作，即会报出服务超时，这类ANR同样没有提示框出现。超时时间，前台Service是20s，后台Service是200s。代码见ActivityServices的&lt;code&gt;SERVICE_TIMEOUT&lt;/code&gt;和&lt;code&gt;SERVICE_BACKGROUND_TIMEOUT&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android性能优化" scheme="https://ivonhoe.github.io/categories/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="anr" scheme="https://ivonhoe.github.io/tags/anr/"/>
    
  </entry>
  
  <entry>
    <title>移动端无痕埋点实践详解(二)</title>
    <link href="https://ivonhoe.github.io/2018/09/11/how-to-track-users-2/"/>
    <id>https://ivonhoe.github.io/2018/09/11/how-to-track-users-2/</id>
    <published>2018-09-11T13:07:24.000Z</published>
    <updated>2019-08-26T02:22:36.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>在<a href="https://ivonhoe.github.io/2018/07/03/how-to-track-users/">移动端无痕埋点实践详解（一）</a>这篇文章大致总结了移动端无痕埋点的基本原理。主要介绍了什么是无痕埋点，无痕埋点的基础数据流程以及在Android系统上总体思路。这篇文章着重总结下无痕埋点方案的实施过程中在Android和iOS系统上几个细节的解决方案。</p><a id="more"></a><h3 id="0x02-xpath"><a href="#0x02-xpath" class="headerlink" title="0x02 xpath"></a>0x02 xpath</h3><h4 id="2-1-什么是xpath"><a href="#2-1-什么是xpath" class="headerlink" title="2.1 什么是xpath"></a>2.1 什么是xpath</h4><p>xpath是移动端定义可操作区域的数字标识，是用来标识可操作的控件的。既然想要通过一串字符标识在移动端app中的可操作控件，那么xpath的生成规则需要满足以下几个原则：</p><ul><li>唯一性: 在当前app中不存在不同控件对应相同Xpath</li><li>稳定性: 不同版本app中，在没有页面结构变更的情况下，不同版本中相同页面中相同控件的Xpath要保持不变 </li></ul><h4 id="2-1-Android中如何生成xpath"><a href="#2-1-Android中如何生成xpath" class="headerlink" title="2.1 Android中如何生成xpath"></a>2.1 Android中如何生成xpath</h4><p>在满足上述xpath原则的基础上，可通过以下几个参数作为组成XPath的生成参数：</p><ul><li><strong>页面</strong>：标记当前控件所在的页面url，Webview页面为其html的url，native页面url可定义该页面的virtual url</li><li><strong>页面中位置</strong>：如何描述一个控件在该页面的位置，在Android系统中很容易想到DecorView和页面子view的关系。使用View到DecorView的位置关系来描述视图控件在该页面中的相对位置。</li></ul><p><img src="/res/trace_user2/trace1.png" alt="Alt text"></p><ul><li><strong>控件标记</strong>：这里的控件标记指的是相对于相同父容器的兄弟视图来说，如何更好的区别彼此。这里很容易能够想到view id。但是这里并不推荐使用view id作为标记。因为id是在版本迭代过程中很容易因为资源数量的变化而发生变化。并不能满足标记稳定性的原则，目前在Android上我选择resource name作为视图控件的标记。在ios上</li></ul><p>综上所述就可以得到以下的XPath生成方式。</p><p>$ xpath = Md5(url+root path + resource name)$</p><h4 id="2-2-iOS系统中如何生成xpath"><a href="#2-2-iOS系统中如何生成xpath" class="headerlink" title="2.2 iOS系统中如何生成xpath"></a>2.2 iOS系统中如何生成xpath</h4><p>参考 <a href="https://www.jianshu.com/p/69ce01e15042" target="_blank" rel="noopener">https://www.jianshu.com/p/69ce01e15042</a></p><h4 id="2-3-如何识别xpath"><a href="#2-3-如何识别xpath" class="headerlink" title="2.3 如何识别xpath"></a>2.3 如何识别xpath</h4><p>在用户产生用户点击数据的过程中，埋点系统上报控件xpath给埋点后台，但是在实际的数据分析过程中需要知道每个xpath对应的控件和区块名称具体是什么。在每个电商系统中针对埋点都会有一套自己的位置模型规范，简称SPM（super position model）。所以针对最终的数据分析和统计需要一个xpath到spm的映射关系，将实际产生的xpath埋点数据转换成业务中的SPM。实现方式也很简单，只需要在开发版本中提供一个编辑模式，将移动端本地生成的xpath通过一个编辑工具转换成SPM数据就可以了，简单的效果图如下所示：</p><p><img src="/res/trace_user2/trace2.jpeg" alt="Alt text"></p><h3 id="0x03-Android如何记录页面跳转"><a href="#0x03-Android如何记录页面跳转" class="headerlink" title="0x03 Android如何记录页面跳转"></a>0x03 Android如何记录页面跳转</h3><p>在考虑记录页面跳转的方案时，可能最先想到的是在通过统一路由跳转的方式跟踪所有页面跳转，但是实际的项目中首先你得有个统一的路由不是？在面对已有的项目代码从工作量和效果上来说这种方式都不是最佳方案。即便是已有统一的路由方案也很难保证没有错埋漏埋的情况存在。别忘记 <strong>ActivityLifecycleCallbacks</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class RuntimeActivityCallbacks implements Application.ActivityLifecycleCallbacks &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, Long&gt; mPageResumeTime = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 页面对应的referrerId，一个activity可能有多个子页面，一个activity的referrerId为当前显示的子页面的referrerId</span><br><span class="line">     */</span><br><span class="line">    private Map&lt;Integer, String&gt; mPageReferrerMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityResumed(Activity activity) &#123;</span><br><span class="line">        // 针对页面的跟踪</span><br><span class="line">        if (activity instanceof IPageTracker) &#123;</span><br><span class="line">            IPageTracker pageTracker = (IPageTracker) activity;</span><br><span class="line">            String url = pageTracker.getReferrerId();</span><br><span class="line"></span><br><span class="line">            mPageResumeTime.put(url, System.currentTimeMillis());</span><br><span class="line">            mPageReferrerMap.put(activity.hashCode(), url);</span><br><span class="line">            AppTraceTool.traceOpenPage(url, ModuleManager.getTopPageUrl());</span><br><span class="line">            </span><br><span class="line">            // 保存当前页面为top</span><br><span class="line">            ModuleManager.setTopPageUrl(url);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ModuleManager.setTopPageUrl(&quot;unknown&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityStopped(Activity activity) </span><br><span class="line">        // 针对页面的跟踪</span><br><span class="line">        if (activity instanceof IPageTracker) &#123;</span><br><span class="line">            IPageTracker pageTracker = (IPageTracker) activity;</span><br><span class="line">            String url = pageTracker.getReferrerId();</span><br><span class="line">            mPageResumeTime.remove(url);</span><br><span class="line">            mPageReferrerMap.remove(activity.hashCode());</span><br><span class="line">            AppTraceTool.traceLeavePage(url, second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x04-如何使用无痕埋点方案记录业务数据"><a href="#0x04-如何使用无痕埋点方案记录业务数据" class="headerlink" title="0x04 如何使用无痕埋点方案记录业务数据"></a>0x04 如何使用无痕埋点方案记录业务数据</h3><h3 id="转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="转载请标明出处病已blog https://ivonhoe.github.io/"></a>转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;在&lt;a href=&quot;https://ivonhoe.github.io/2018/07/03/how-to-track-users/&quot;&gt;移动端无痕埋点实践详解（一）&lt;/a&gt;这篇文章大致总结了移动端无痕埋点的基本原理。主要介绍了什么是无痕埋点，无痕埋点的基础数据流程以及在Android系统上总体思路。这篇文章着重总结下无痕埋点方案的实施过程中在Android和iOS系统上几个细节的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="学习总结" scheme="https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="无痕埋点" scheme="https://ivonhoe.github.io/tags/%E6%97%A0%E7%97%95%E5%9F%8B%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化之从入门到放弃</title>
    <link href="https://ivonhoe.github.io/2018/07/18/abandon-the-plugin-framework/"/>
    <id>https://ivonhoe.github.io/2018/07/18/abandon-the-plugin-framework/</id>
    <published>2018-07-18T12:45:30.000Z</published>
    <updated>2018-09-18T09:53:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>Android插件化框架一直以来就是安卓平台上的一个重要技术方向，从携程的DynamicAPK到360RePlugin再到阿里巴巴的Atlas，甚至美团和滴滴的安卓团队都有自己的一套安卓插件化解决方案。面对业界如此热门的技术方向，在对比业界开源的插件化方案后，团队内部于去年10月份开始(2017.10)在项目中选择开源的Small插件化框架进行了尝试。鞋是否合适需要穿上脚才能知道。这篇文章总结了我在使用Small插件化框架后，自己对插件化的理解和思考。</p><h3 id="关于Small插件化的其他文档"><a href="#关于Small插件化的其他文档" class="headerlink" title="关于Small插件化的其他文档"></a>关于Small插件化的其他文档</h3><p><a href="https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"><strong>《Android插件化之Small框架实践总结》</strong></a><br><a href="https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"><strong>《Android插件化之Small框架原理》</strong></a><br><a href="https://ivonhoe.github.io/2018/03/14/small-bug-555-fix/"><strong>《Android插件化之资源加载机制》</strong></a></p><a id="more"></a><h3 id="0x02-重新审视插件化框架的利弊"><a href="#0x02-重新审视插件化框架的利弊" class="headerlink" title="0x02 重新审视插件化框架的利弊"></a>0x02 重新审视插件化框架的利弊</h3><h4 id="2-1-插件化方案想要解决的核心问题"><a href="#2-1-插件化方案想要解决的核心问题" class="headerlink" title="2.1 插件化方案想要解决的核心问题"></a>2.1 插件化方案想要解决的核心问题</h4><blockquote><p>安卓的动态化发布</p></blockquote><p>动态化就像是天赋，有些人天生就有的能力却是需要你花非常大精力也未必能获取到的。前端的开发应该从来不需要动态化的方案吧！插件化方案的一个最大作用应该就是绕开应用市场的审核周期，尽可能的像后端Java或者前端JS一样，随时发布随时生效。</p><blockquote><p>真正意义上的模块解耦</p></blockquote><p>插件化的方式让模块与模块之间在开发方式上真正的隔离，达到了解耦的目标。而这在<strong>之前</strong>android原生的开发方式上是很难达到的。</p><blockquote><p>dex 65535问题</p></blockquote><p>插件化的方案也可以看做一个dex分包和资源分包的方案。</p><h4 id="2-2-Small插件化方案带来的新问题"><a href="#2-2-Small插件化方案带来的新问题" class="headerlink" title="2.2 Small插件化方案带来的新问题"></a>2.2 Small插件化方案带来的新问题</h4><p>在<a href="https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/">《Android插件化之Small框架实践总结》</a> 中对比了Small插件化框架的优缺点，选择Small最重要的原因还是轻量化，当然很多问题也是轻量化带来的。</p><blockquote><p>兼容性问题</p></blockquote><p>兼容性问题大致分布在以下几个方面：</p><ol><li>与google最新系统和编译工具的兼容。18年第三季度最新版本Android P系统的新手机会陆续上市，插件化架构对新系统的兼容性问题会变的急切。并且插件化框架针对安卓系统的黑科技也越来越不被新版本系统接受。Android Studio 3.1最新新编译工具的兼容问题。</li><li>业界移动安全方案的兼容。常见的三方dex加壳方案无法在插件化框架上顺利运用。</li><li>第三方框架的兼容，常见涉及AOP的第三方框架，如AAC和Small框架不兼容。甚至React Native方案都需要花很多时间和精力去适配。</li></ol><blockquote><p>插件化框架带来的稳定性问题</p></blockquote><ol><li>资源查找失败的bug，虽然已经接近了在个别国产手机上的资源查找失败问题，详情见<a href="https://ivonhoe.github.io/2018/03/14/small-bug-555-fix/">《Android插件化之资源加载》</a>。但是在Android 7.1以上的系统上依然出现偶现的资源查找失败问题。并且崩溃率（错误数/启动次数）在0.3%左右。这个比例其实不算低了。这个bug暂时只能通过将插件资源转移到宿主分身中绕过。但是如果把所有插件资源都放到宿主中以规避这个问题，那插件化就没有任何意义了。</li></ol><h4 id="2-3-重新思考插件化框架给安卓app的收益"><a href="#2-3-重新思考插件化框架给安卓app的收益" class="headerlink" title="2.3 重新思考插件化框架给安卓app的收益"></a>2.3 重新思考插件化框架给安卓app的收益</h4><p>在团队技术选型上优先考虑的应该是和现有业务适配吧。如果你所面对的业务不存在快速迭代频繁发布的需求，插件化框架的威力可能就要减小一半了。同时在选择个人开发者维护的开源项目时，依然是要考虑到其架构的稳定性和bug的修复时效。因为一旦在一个商业化的项目中使用开源框架，稳定性和兼容性一定会放在首要位置的。在这一点上，可能从大公司孵化出的开源项目会更有优势。</p><p>在回看插件化框架对android应用中模块解耦的贡献，对比android应用的原生的开发方式。能够从插件化框架吸收的模块解耦方法上可以看到大致这几个方面。</p><blockquote><p>模块间的解耦要依赖工具而不是约定开发规范</p></blockquote><p>以2个业务app模块为例，应该有一个工具存在避免这两个模块产生耦合关系，如果一旦存在耦合关系就可能编译报错。而不是靠开发者约定的开发规范。因为规范是可以不遵守的。这是同层级间的耦合管理。</p><blockquote><p>避免依赖传递 </p></blockquote><p>这是不同层级的模块间耦合问题。implementation关键词就可以解决这个问题。</p><blockquote><p>路由</p></blockquote><p>相比较插件化框架你可能更需要一个页面路由工具，业界有很多业界路由框架，比如阿里的ARouter，路由用来解决模块解耦带来的页面跳转问题，所以自己动手实现一个简单的路由工具也不是很难。</p><h4 id="2-3-implementation、api和compile的差异"><a href="#2-3-implementation、api和compile的差异" class="headerlink" title="2.3 implementation、api和compile的差异"></a>2.3 implementation、api和compile的差异</h4><p>可以查看google文档上对Android Studio 3.0后新引入的依赖配置的差异说明。<br><a href="https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration" target="_blank" rel="noopener">https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration</a></p><p><img src="/res/no-small/google-implementation.png" alt></p><p>简单来说google将compile配置拆成了两个关键词，分别是api和implementation。api和implementation的差异不单单是编译效率的差异，我觉得更重要的是，implementation避免了依赖的传递。以下图对比api和implementation的差异可以发现，当使用implementation配置依赖时，app模块将不会直接依赖<code>D</code>模块。在使用老的依赖配置<code>compile</code>时，实际上并没有做到模块的分层，最底下的模块依然可以被最上层的模块依赖，实际的依赖规则在开发者的规范里，而不存在项目模块的管理中。</p><p><img src="/res/no-small/implementation-api.png" alt></p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>以上就是我对插件化框架的看法，如果你的业务存在开始迭代频繁发布的情况存在，那么你可能就很需要一个插件化框架来带来开发方式上的改变，核心在于提高了研发效率。但是在使用插件化项目之前你需要对插件化框架的边界和扩展边界的成本有一个清晰的认识。实际上上面所说的所有插件化框架带来的问题都是可以解决的。问题的关键在于在你的团队这样的付出和产出是否值得呢？相信每个人都可能会有不同的看法。</p><p><strong>当然开源的插件化框架依然是重点学习的方向，理解不同插件化方案的实现原理是深入理解安卓系统很好的切入点。接下来我还会花更多的时间深入的学习360和阿里巴巴的插件化方案。</strong></p><p>最近在读《邓小平改变中国》这本书，让我对从文革结束到改革开放前那段对大多数中国人讳莫如深的历史有了大致的了解。<strong>“实践是检验真理的唯一标准”</strong>，这句很多80后90后耳熟能详的口号背后，原来发生了这么多的波折，冲破了如此多的障碍。<strong>理论与实践的统一是马克思主义的一个最基本的原则</strong>。<strong>实事求是是毛泽东思想的精髓</strong>。听起来虚头巴脑，但确实应该是解决问题和对待未知事物的核心方法论。对！这是一篇技术总结。</p><h3 id="0x05-转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#0x05-转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="0x05 转载请标明出处病已blog https://ivonhoe.github.io/"></a>0x05 转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;Android插件化框架一直以来就是安卓平台上的一个重要技术方向，从携程的DynamicAPK到360RePlugin再到阿里巴巴的Atlas，甚至美团和滴滴的安卓团队都有自己的一套安卓插件化解决方案。面对业界如此热门的技术方向，在对比业界开源的插件化方案后，团队内部于去年10月份开始(2017.10)在项目中选择开源的Small插件化框架进行了尝试。鞋是否合适需要穿上脚才能知道。这篇文章总结了我在使用Small插件化框架后，自己对插件化的理解和思考。&lt;/p&gt;
&lt;h3 id=&quot;关于Small插件化的其他文档&quot;&gt;&lt;a href=&quot;#关于Small插件化的其他文档&quot; class=&quot;headerlink&quot; title=&quot;关于Small插件化的其他文档&quot;&gt;&lt;/a&gt;关于Small插件化的其他文档&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/&quot;&gt;&lt;strong&gt;《Android插件化之Small框架实践总结》&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/&quot;&gt;&lt;strong&gt;《Android插件化之Small框架原理》&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://ivonhoe.github.io/2018/03/14/small-bug-555-fix/&quot;&gt;&lt;strong&gt;《Android插件化之资源加载机制》&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android插件化" scheme="https://ivonhoe.github.io/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android插件化" scheme="https://ivonhoe.github.io/tags/Android%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android客户端HTTP网络框架设计与实践</title>
    <link href="https://ivonhoe.github.io/2018/07/08/network-architecture-design/"/>
    <id>https://ivonhoe.github.io/2018/07/08/network-architecture-design/</id>
    <published>2018-07-08T13:30:33.000Z</published>
    <updated>2018-09-11T13:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>不管是android、ios还是浏览器端的开发，在正常的产品迭代过程中HTTP网络请求都是高频使用的功能。以android端为例，在使用常见的http网络框架时，如<code>HttpUrlConnection</code>,<code>HttpClient</code>或者<code>okHttp</code>，开发者都必须在此自身业务场景的基础上进行api的二次封装。一个功能强大且易用的网络框架不仅仅能够提高开发效率，起到事半功倍的效果，还能起到规范业务开发结果的作用。<br>希望通过这篇文章，总结下自己在设计和实现一个网络框架时的思考过程，也帮助团队同学了解现有网络框架的能力和不足。<br><a id="more"></a></p><h3 id="0x02-使用者的视角"><a href="#0x02-使用者的视角" class="headerlink" title="0x02 使用者的视角"></a>0x02 使用者的视角</h3><h4 id="2-1-使用volley"><a href="#2-1-使用volley" class="headerlink" title="2.1 使用volley"></a>2.1 使用volley</h4><p>发送Http get请求的示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Instantiate the RequestQueue.</span><br><span class="line">RequestQueue queue = Volley.newRequestQueue(this);</span><br><span class="line">String url =&quot;http://www.google.com&quot;;</span><br><span class="line"></span><br><span class="line">// Request a string response from the provided URL.</span><br><span class="line">StringRequest stringRequest = new StringRequest(Request.Method.GET, url,</span><br><span class="line">            new Response.Listener&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onResponse(String response) &#123;</span><br><span class="line">        // Display the first 500 characters of the response string.</span><br><span class="line">        mTextView.setText(&quot;Response is: &quot;+ response.substring(0,500));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, new Response.ErrorListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onErrorResponse(VolleyError error) &#123;</span><br><span class="line">        mTextView.setText(&quot;That didn&apos;t work!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Add the request to the RequestQueue.</span><br><span class="line">queue.add(stringRequest);</span><br></pre></td></tr></table></figure><p>查看以上Volley使用的官方示例，可以将其划分为以下几个使用步骤：</p><ol><li>构建一个请求队列</li><li>构造一个请求Request对象和接收请求结果的<code>Response.Listener</code></li><li>将请求Request添加到请求队列中</li></ol><p>通过volley的使用方法你就可以大致猜测volley在完成一个网络请求的大致过程。开发者使用请求相关信息和接收返回结果的<code>Callback</code>封装成一个<code>Request</code>,并将其放在请求队列中，在请求队列的背后一定有负责真正网络请求任务的线程从队列中消费网络请求的<code>Request</code>，在获取网络请求结果后通过线程间消息机制将网络请求的结果在主线程返回给接受消息的<code>Response.Listener</code>。当然真正的过程肯定会更复杂。但是不管怎样，volley的设计思路是一个经典的生产者消费者模式。<br>从一个Volley api使用者的视角回头再看一下volley，你是否有这些疑问？</p><ul><li>在一个开发者的使用过程，他需要知道请求队列的存在吗？除非他想要改变请求的优先级规则或者有其他想要改变请求在请求队列中顺序的需求。</li><li>构造<code>Request</code>的方式不友好。以Get请求为例，需要自己手动将请求参数拼接到请求url中。如果是POST请求情况还会更复杂。</li><li>接受请求结果的方式不友好，指定<code>Response.Listener</code>对象接收请求让代码不够美观不说，更建立了请求者和请求框架之间的强耦合关系。以上面的示例代码为例，如果这段代码写在Activity中，构造的<code>Response.Listener</code>的匿名内部类存在当前Activity的隐式引用，很容易引起不必要的内存泄露。如果这段代码不在Activity中，那还要多一层数据的轮转机制。简直是开发者的噩梦。</li><li>针对失败的回调处理并不科学。在实际的业务开发中，你可能需要针对某几类返回数据做异常处理，虽然他们整个Http请求的网络过程是正常的，但是针对这些返回的结果把它看成异常流。如果希望Volley在这一点达到你的要求你还需要多一层封装。</li></ul><h4 id="2-2-使用okhttp"><a href="#2-2-使用okhttp" class="headerlink" title="2.2 使用okhttp"></a>2.2 使用okhttp</h4><p>发送Http post请求的示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//创建网络处理的对象</span><br><span class="line">OkHttpClient client = new OkHttpClient.Builder()</span><br><span class="line">        .readTimeout(5, TimeUnit.SECONDS)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">//post请求来获得数据</span><br><span class="line">//创建一个RequestBody，存放重要数据的键值对</span><br><span class="line">RequestBody body = new FormBody.Builder()</span><br><span class="line">        .add(&quot;showapi_appid&quot;, &quot;13074&quot;)</span><br><span class="line">        .add(&quot;showapi_sign&quot;, &quot;ea5b4bf2e140498bb772d1bf2a51a7a0&quot;).build();</span><br><span class="line">//创建一个请求对象，传入URL地址和相关数据的键值对的对象</span><br><span class="line">Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;http://route.showapi.com/341-3&quot;)</span><br><span class="line">        .post(body).build();</span><br><span class="line"></span><br><span class="line">//创建一个能处理请求数据的操作类</span><br><span class="line">Call call = client.newCall(request);</span><br><span class="line"></span><br><span class="line">//使用异步任务的模式请求数据</span><br><span class="line">call.enqueue(new Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">        Log.e(“TAG”,&quot;错误信息：&quot; + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line">       Log.e(“TAG”,response.body().string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>相比较volley，okhttp在请求api的设计上更合理些。okhttp使用RequestBuilder和BodyBuilder构造网络请求，并且隐藏了网络框架的内部实现，让请求的过程更简单优雅。但在接收请求结果上依然选择<code>Callback</code>监听的方式。</p><h3 id="0x03-设计者如何面对"><a href="#0x03-设计者如何面对" class="headerlink" title="0x03 设计者如何面对"></a>0x03 设计者如何面对</h3><h4 id="3-1-请求需求与请求协议"><a href="#3-1-请求需求与请求协议" class="headerlink" title="3.1 请求需求与请求协议"></a>3.1 请求需求与请求协议</h4><p>目前android平台上主流的网络请求都是基于OkHttp框架的，okhttp框架针对http协议进行了封装和优化，支持http/2协议，共享连接池的设计有利于提高请求效率，拦截器的设计支持监视、重写、和重试等特殊业务场景的需求。极大地降低了开发者的使用成本，同时兼备稳定性和可扩展性。所以我们在分析volley和okhttp在实际业务中的不足和优势，选择使用okhttp进行网络请求和连接，在其基础上进行业务封装，力求设计出尽可能的符合自身业务需求和场景的网络框架。具体使用设计需求如下：</p><ol><li>尽可能优雅的方式构造一个网络请求，不管他是get、post还是其他请求方法，也不管请求参数格式是form还是json。在构造Request方式上力求简单统一。</li><li>尽可能简单的方式获取请求结果，最好不要再用Callback的方式接收回调数据。</li><li>支持多种不同的请求结果类型，不管是<code>String</code>还是<code>JSON</code>，不管是Java对象还是文件，都能简单的获取。</li><li>对失败的异常处理要更符合自身业务场景，并不是网络连接错误才会触发请求失败的接口</li></ol><p>结合以上几点对网络框架的期望，所以诞生了以下实例的API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getMethodTest() &#123;</span><br><span class="line">    TestLog.d(&quot;get url:&quot; + getUrl(PATH_GET));</span><br><span class="line"></span><br><span class="line">    BasicRequest request = RequestBuilder.obtain().get()</span><br><span class="line">            .setUrl(getUrl(PATH_GET))</span><br><span class="line">            .addParam(&quot;shopIds&quot;, 123445)</span><br><span class="line">            .into(this, &quot;getMethod&quot;, 1, 1L, (short) 1, false, 1D, 1f)</span><br><span class="line">            .buildJsonRequest(ShopInfo.class);</span><br><span class="line"></span><br><span class="line">    request.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Keep</span><br><span class="line">@NetworkCallback(name = &quot;getMethod;getMethod2&quot;, type = ResponseType.SUCCESS)</span><br><span class="line">private void onGetMethodSuccess(ShopInfo info, int h, long h1, short h2, boolean h3, double h4</span><br><span class="line">        , float h5) &#123;</span><br><span class="line">    TestLog.d(&quot;++++++++get method success:&quot; + info.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Keep</span><br><span class="line">@NetworkCallback(name = &quot;getMethod&quot;, type = ResponseType.FAILED)</span><br><span class="line">private void onGetMethodFailed(CommonError error, int h, long h1, short h2, boolean h3,</span><br><span class="line">                               double h4, float h5) &#123;</span><br><span class="line">    TestLog.d(&quot;++++++++get method failed:&quot; + error.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API说明：</p><ul><li><code>RequestBuilder.obtain</code>从对象池中返回复用的Request对象</li><li><code>.get()</code> <code>.postJson()</code> <code>.postFormEncode()</code> <code>postStream(Binary binary)</code>等方法封装了常见的get与post请求并指定了不同的body格式</li><li>使用<code>addParam(key, value)</code>方法添加请求参数，这里并不因为请求方法的不同而存在api上的差异</li><li><strong>使用注解标记接收网络请求结果回调的方法</strong>。如上例中，<code>onGetMethodSuccess()</code>和 <code>onGetMethodFailed()</code>方便被<code>NetworkCallback</code>注解标记，并且通过<code>BasicRequest.into(this, &quot;getMethod&quot;, 1, 1L, (short) 1, false, 1D, 1f)</code>绑定了请求与回调方法之间的关系。其中into的方法参数一次为：包含改回调方法的对象，注解的名称，以及Callback方法需要的其他额外参数。</li><li><code>buildJsonRequest</code>将返回结果自动转换成<code>ShopInfo</code>对象。</li></ul><h4 id="3-2-缓存"><a href="#3-2-缓存" class="headerlink" title="3.2 缓存"></a>3.2 缓存</h4><p>Http缓存策略是一个相对复杂的问题，大致分为以下三个方面：</p><h5 id="3-2-1-缓存存储策略"><a href="#3-2-1-缓存存储策略" class="headerlink" title="3.2.1 缓存存储策略"></a>3.2.1 缓存存储策略</h5><p><strong>决定Http的相应内容是否可缓存在客户端</strong>。Http响应头中的<code>Cache-Control</code>字段，分为<code>Public</code>、<code>Private</code>、<code>no-cache</code>、<code>max-age</code> 、<code>no-store</code>5种类型。其中前4个都会缓存文件数据（关于 no-cache 应理解为“不建议使用本地缓存”，其仍然会缓存数据到本地），后者 no-store 则不会在客户端缓存任何响应数据。</p><h5 id="3-2-2-缓存过期策略"><a href="#3-2-2-缓存过期策略" class="headerlink" title="3.2.2 缓存过期策略"></a>3.2.2 缓存过期策略</h5><p><strong>决定客户端是否可直接从本地缓存数据中加载数据并展示，否则就发请求到服务端获取</strong>。Http响应头中的<code>Expires</code>字段指明了缓存数据有效的绝对时间，告诉客户端到了这个时间点后该本地缓存就该作废了。这里的作废是指客户端不能直接再从本地读取缓存，需要再发一次请求到服务端去确认。确认下这个缓存还有没有用。这个过程就要说到下面的缓存对比策略。</p><h5 id="3-2-3-缓存对比策略"><a href="#3-2-3-缓存对比策略" class="headerlink" title="3.2.3 缓存对比策略"></a>3.2.3 缓存对比策略</h5><p><strong>决定客户端本地的缓存数据是否仍然有效。</strong>客户端检测到数据过期或浏览器刷新后，往往会重新发起一个 http 请求到服务器，服务器此时并不急于返回数据，而是看请求头有没有带标识（ If-Modified-Since、If-None-Match）过来，如果判断标识仍然有效，则返回304告诉客户端取本地缓存数据来用即可（这里要注意的是你必须要在首次响应时输出相应的头信息（Last-Modified、ETags）到客户端）。</p><p>根据上述的三种缓存策略，这里贴出客户端对http缓存控制的关键代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 先检查是否有未过期缓存</span><br><span class="line"> */</span><br><span class="line">CacheControl cacheControl = cacheKey.getCacheControl();</span><br><span class="line">if (cacheControl != null &amp;&amp; cacheControl.shouldCache()) &#123;</span><br><span class="line">    cacheEntry = mCacheManager.get(cacheKey);</span><br><span class="line">    // TestLog.d(&quot;缓存=====cache entry:&quot; + cacheEntry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果存在缓存数据，检查是否过期</span><br><span class="line"> */</span><br><span class="line">if (cacheEntry != null) &#123;</span><br><span class="line">    boolean isExpired = cacheEntry.isExpired();</span><br><span class="line">    if (!isExpired) &#123;</span><br><span class="line">        // 没有过期，delivery缓存信息</span><br><span class="line">        Headers headers = CacheExecutor.getResponseHeaders(cacheEntry);</span><br><span class="line">        byte[] body = CacheExecutor.getResponseBody(cacheEntry);</span><br><span class="line"></span><br><span class="line">        Object result = performParseResponse(requestEvent, headers, body);</span><br><span class="line">        response = BasicResponse.success(result);</span><br><span class="line">        return;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 过期，检查是否有Etag和Last-Modified信息</span><br><span class="line">        if (!TextUtils.isEmpty(cacheEntry.etag)) &#123;</span><br><span class="line">            requestHeaders.set(&quot;If-None-Match&quot;, cacheEntry.etag);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (cacheEntry.lastModified &gt; 0) &#123;</span><br><span class="line">            requestHeaders.set(&quot;If-Modified-Since&quot;,</span><br><span class="line">                    DateUtils.formatMillisToGMT(cacheEntry.lastModified));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何确定缓存时间的关键流程：</p><p><img src="/res/network/cache-ttl.png" alt></p><h4 id="3-3-JSON转换与错误处理"><a href="#3-3-JSON转换与错误处理" class="headerlink" title="3.3 JSON转换与错误处理"></a>3.3 JSON转换与错误处理</h4><p>首先需要定义一个CommonResponse，所有的JSON格式的Response都继承它。按照服务端低响应状态的约定，当status为<code>false</code>时表示请求结果失败，这里说的失败指的是无法返回客户端预期的正确业务结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class CommonResponse implements Serializable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 状态码</span><br><span class="line">     */</span><br><span class="line">    private boolean status;</span><br><span class="line">    /**</span><br><span class="line">     * 描述</span><br><span class="line">     */</span><br><span class="line">    private String message;</span><br><span class="line">    /**</span><br><span class="line">     * 响应码</span><br><span class="line">     */</span><br><span class="line">    private String responseCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当网络出现异常导致的连接失败时，或者当服务端返回的数据无法正常序列化为指定的类的实例时，或者CommonResponse的status变量为false时，网络框架都会抛出一个可被自动捕获的<code>Throwable</code>，并将返回值和错误类型回调到标记为<code>@NetworkCallback(type = ResponseType.FAILED)</code>的对应方法中。</p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>因为篇幅的原因，暂时只针对上述的几个方面较的阐述了一个网络框架的设计思路，还包括但不仅限于下面的这些讨论方向，有机会再详聊！如：</p><blockquote><p>线程的切换<br>对响应数据完整性的校验<br>Zip文件的请求与自动解压缩，bspatch算法的增量文件请求并根据增量文件自动生成全量文件等<br>网络模块与缓存模块的解耦设计<br>网络性能的监控<br>httpDNS方案的应用<br>cookie的管理(可参考github开源项目<code>nohttp</code>项目的设计)</p></blockquote><p>在实际的业务开发过程中，针对上述问题的设计和封装已经能够覆盖大部分复杂的业务场景。相信一定能让一个开发人员写出赏心悦目自嗨的代码了。</p><h3 id="0x05-参考文档"><a href="#0x05-参考文档" class="headerlink" title="0x05 参考文档"></a>0x05 参考文档</h3><p><a href="https://tech.youzan.com/android_http/" target="_blank" rel="noopener">https://tech.youzan.com/android_http/</a></p><p><a href="https://mp.weixin.qq.com/s/qOMO0LIdA47j3RjhbCWUEQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qOMO0LIdA47j3RjhbCWUEQ</a></p><p><a href="https://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenqf/p/6386163.html</a></p><p><a href="http://blog.csdn.net/yaofeiNO1/article/details/54428021" target="_blank" rel="noopener">http://blog.csdn.net/yaofeiNO1/article/details/54428021</a></p><p><a href="http://blog.csdn.net/qmickecs/article/details/73696954" target="_blank" rel="noopener">http://blog.csdn.net/qmickecs/article/details/73696954</a></p><p><a href="http://blog.csdn.net/qmickecs/article/details/73822619" target="_blank" rel="noopener">http://blog.csdn.net/qmickecs/article/details/73822619</a></p><h3 id="转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="转载请标明出处病已blog https://ivonhoe.github.io/"></a>转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;不管是android、ios还是浏览器端的开发，在正常的产品迭代过程中HTTP网络请求都是高频使用的功能。以android端为例，在使用常见的http网络框架时，如&lt;code&gt;HttpUrlConnection&lt;/code&gt;,&lt;code&gt;HttpClient&lt;/code&gt;或者&lt;code&gt;okHttp&lt;/code&gt;，开发者都必须在此自身业务场景的基础上进行api的二次封装。一个功能强大且易用的网络框架不仅仅能够提高开发效率，起到事半功倍的效果，还能起到规范业务开发结果的作用。&lt;br&gt;希望通过这篇文章，总结下自己在设计和实现一个网络框架时的思考过程，也帮助团队同学了解现有网络框架的能力和不足。&lt;br&gt;
    
    </summary>
    
      <category term="框架设计" scheme="https://ivonhoe.github.io/categories/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="网络" scheme="https://ivonhoe.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>移动端无痕埋点实践详解(一)</title>
    <link href="https://ivonhoe.github.io/2018/07/03/how-to-track-users/"/>
    <id>https://ivonhoe.github.io/2018/07/03/how-to-track-users/</id>
    <published>2018-07-03T09:53:56.000Z</published>
    <updated>2018-09-11T13:28:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>用户数据埋点的一般解决思路是使用代码手动埋点。国内主要的第三方数据分析服务商，如百度统计、友盟、TalkingData等都提供这一方案。但是使用代码手动埋点的方式，投入资源大，往往很难能够有实际产出。其中一个很重要的原因其实是在分析实际业务数据之前，很难知道我真正想看什么样的数据。用代码手动的埋点方案经常会导致一个尴尬的解决，想要看的数据没有埋，埋了的数据不准。<br>用户数据埋点是少见的涉及到一个产品研发团队所有角色的项目。从运营的数据需求，到产品经理的抽象和规范，到移动端前端的手动采集数据，再到服务端和大数据的存储和转换，最终把结果反馈给运营和产品经理。埋点的实际产出涉及到几乎所有部门，如果按照链式的工作流来解决埋点问题，当任何一个环节出现问题，都会对整个项目结果的产出产生影响。这篇文章记录了无痕埋点方案的思路与其核心问题的解决方案。</p><a id="more"></a><p><img src="/res/trace_user/trace1.png" alt></p><h3 id="0x01-什么是无痕埋点？"><a href="#0x01-什么是无痕埋点？" class="headerlink" title="0x01 什么是无痕埋点？"></a>0x01 什么是无痕埋点？</h3><p>所谓的”无痕埋点”，其实就是通过技术手段，无差别的记录用户在产品中的行为，当有一天突然想对某一个控件做点击分析时，不再需要开发手动添加数据采集信息。因为从部署埋点方案的时候，就一直在收集所有的用户的数据了。用户的数据并不是分析需求产生的那一刻才有的。无痕埋点在无差别的记录用户所有行为，而实际的埋点结果产出取决于BI工程师对无痕埋点数据的清洗。</p><p>从技术角度总结以往埋点项目结果产出困难的原因，这些也是无痕埋点方案想要解决的核心问题。</p><ul><li>通过代码手动埋点比较原始，出错概率较高。</li><li>埋点链路较长，出现错埋漏埋需要重新发布</li><li>埋点数据准确性无法校验</li></ul><p>所以，在项目上使用无痕埋点来解决项目链路过长的问题的方法是将埋点数据的产生过程分成两个并行的部分。将数据的采集过程前置，不再依赖运营和产品经理的需求产出。现有全量用户数据，再由运营和产品分析数据产出结果。</p><p><img src="/res/trace_user/trace2.png" alt></p><h3 id="0x02-移动端无痕埋点如何实现？"><a href="#0x02-移动端无痕埋点如何实现？" class="headerlink" title="0x02 移动端无痕埋点如何实现？"></a>0x02 移动端无痕埋点如何实现？</h3><p>移动端埋点的方案以在Android系统上实现为例，关键在于解决2个问题：</p><blockquote><ul><li>如何统一标识控件</li><li>统一拦截用户操作行为。这里说的用户操作主要还是用户的单击事件。</li></ul></blockquote><h4 id="2-1-如何标识控件"><a href="#2-1-如何标识控件" class="headerlink" title="2.1 如何标识控件"></a>2.1 如何标识控件</h4><p>为了自动生成事件标识，我们需要获取每个控件自身的ID、类名以及位于所属父组件的Index等特征信息，并逐级向上遍历找到根节点。约定控件标识的生成规则为 <code>/root/ClassName:id/ClassName:id</code>，以某一个业务界面的<code>扫一扫</code>按钮为例，寻找它到root节点的控件路径，它的控件标识字符串应该是 <code>/root/RelativeLayout:-1/FrameLayout:1997209645/RelativeLayout:-1/RelativeLayout:1997209836/LinearLayout:1997209965/TextView:1997209967</code>，并通过md5算法将这个标识字符串生成为<code>XPATH</code>就是我们想要的控件标识。当后台上报数据中包含<code>1e3cdc9499fac8088220756a46c85599</code>的点击时。我们就认为是<code>扫一扫</code>控件被点击了。</p><p><img src="/res/trace_user/trace3.png" alt></p><h4 id="2-2-如何统一拦截单击事件"><a href="#2-2-如何统一拦截单击事件" class="headerlink" title="2.2 如何统一拦截单击事件"></a>2.2 如何统一拦截单击事件</h4><p>还是以Android端上的实现为例，如何统一拦截用户的单击事件呢？先看如何实现一个单击操作的响应，在Android上一般的做法是针对View设置一个单击的监听。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Interface definition for a callback to be invoked when a view is clicked.</span><br><span class="line"> */</span><br><span class="line">public interface OnClickListener &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Called when a view has been clicked.</span><br><span class="line">     *</span><br><span class="line">     * @param v The view that was clicked.</span><br><span class="line">     */</span><br><span class="line">    void onClick(View v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么有没有办法统一把所有的单击事件都替换掉呢？在运行时！业务开发的工程师还是按照原生Android系统的api实现对单击事件的响应，埋点SDK在运行时统一替换所有的<code>View.OnClickListener</code>，将其替换成原有<code>View.OnClickListener</code>的包装。当执行<code>AutoTraceListenerWrapper</code>的时候实际执行的还是原有<code>Listener</code>的单击事件，同时又能统一拦截所有的单击事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class AutoTraceListenerWrapper implements View.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    private View.OnClickListener mClickListener;</span><br><span class="line"></span><br><span class="line">    public AutoTraceListenerWrapper(View.OnClickListener listener) &#123;</span><br><span class="line">        mClickListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        onViewClick(view);</span><br><span class="line"></span><br><span class="line">        if (mClickListener != null) &#123;</span><br><span class="line">            mClickListener.onClick(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何统一替换所有的View的单击监听呢？只需要遍历安卓视图结构的View Tree，使用反射机制替换掉所有的原生<code>OnClickListener</code>就可以了。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>埋点问题是不能通过一个方案适配所有业务场景的，不同的场景下需要选择不同的埋点方案。无痕埋点方案针对的是用户的简单用户行为事件，比如如何规范采集用户的点击事件。例如针对页面跳转的事件统计还是需要你单独埋点。埋点数据能不能最终完美的呈现依赖的不单单是技术方案，还有更多的是数据规范的问题。例如在面对运行时才能获知的业务信息时，如何使用埋点技术将需要的业务信息做统一的上报，是另一个重要的关键点。例如在做数据清洗时如何建立规范的数据中间表？无痕埋点只是获取完整埋点数据的第一步。</p><p><a href="https://ivonhoe.github.io/2018/09/11/how-to-track-users-2/">移动端无痕埋点实践详解(二)</a></p><h3 id="0x04-参考文档"><a href="#0x04-参考文档" class="headerlink" title="0x04 参考文档"></a>0x04 参考文档</h3><p><a href="https://tech.meituan.com/mt-mobile-analytics-practice.html" target="_blank" rel="noopener">美团点评前端无痕埋点实践</a></p><p><a href="https://blog.csdn.net/vshuang/article/details/60361314" target="_blank" rel="noopener">数据采集与埋点简介之 代码埋点、可视化埋点与无痕埋点</a></p><h3 id="0x05-转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#0x05-转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="0x05 转载请标明出处病已blog https://ivonhoe.github.io/"></a>0x05 转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3><h3 id="转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="转载请标明出处病已blog https://ivonhoe.github.io/"></a>转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;用户数据埋点的一般解决思路是使用代码手动埋点。国内主要的第三方数据分析服务商，如百度统计、友盟、TalkingData等都提供这一方案。但是使用代码手动埋点的方式，投入资源大，往往很难能够有实际产出。其中一个很重要的原因其实是在分析实际业务数据之前，很难知道我真正想看什么样的数据。用代码手动的埋点方案经常会导致一个尴尬的解决，想要看的数据没有埋，埋了的数据不准。&lt;br&gt;用户数据埋点是少见的涉及到一个产品研发团队所有角色的项目。从运营的数据需求，到产品经理的抽象和规范，到移动端前端的手动采集数据，再到服务端和大数据的存储和转换，最终把结果反馈给运营和产品经理。埋点的实际产出涉及到几乎所有部门，如果按照链式的工作流来解决埋点问题，当任何一个环节出现问题，都会对整个项目结果的产出产生影响。这篇文章记录了无痕埋点方案的思路与其核心问题的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="学习总结" scheme="https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="无痕埋点" scheme="https://ivonhoe.github.io/tags/%E6%97%A0%E7%97%95%E5%9F%8B%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK编译错误解决</title>
    <link href="https://ivonhoe.github.io/2018/06/05/ndk17-build-error/"/>
    <id>https://ivonhoe.github.io/2018/06/05/ndk17-build-error/</id>
    <published>2018-06-05T13:10:54.000Z</published>
    <updated>2018-10-16T10:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-问题描述"><a href="#0x01-问题描述" class="headerlink" title="0x01 问题描述"></a>0x01 问题描述</h4><p><strong>现象：</strong> 将ndk版本升级到    <code>17.0.4754217</code>编译报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &apos;:app+stub:transformNativeLibsWithStripDebugSymbolForRelease&apos;.</span><br><span class="line">&gt; A problem occurred starting process &apos;command &apos;/Users/Ivonhoe/Library/Android/sdk/ndk-bundle/toolchains/mips64el-linux-android-4.9/prebuilt/darwin-x86_64/bin/mips64el-linux-android-strip&apos;&apos;</span><br><span class="line"></span><br><span class="line">* Try:</span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.io.IOException: Cannot run program &quot;/Users/Ivonhoe/Library/Android/sdk/ndk-bundle/toolchains/mips64el-linux-android-4.9/prebuilt/darwin-x86_64/bin/mips64el-linux-android-strip&quot; (in directory &quot;/Users/Ivonhoe/Workspace/keyaccount-repo/app+stub&quot;): error=2, No such file or directory</span><br><span class="line">        at net.rubygrapefruit.platform.internal.DefaultProcessLauncher.start(DefaultProcessLauncher.java:25)</span><br><span class="line">        ... 4 more</span><br><span class="line">Caused by: java.io.IOException: error=2, No such file or directory</span><br><span class="line">        ... 5 more</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>原因：</strong></p><p>升级android ndk版本到17时未同时升级gradle编译工具到3.0.0以上，低版本的编译工具会执行mips64的脚本。而mips64的脚本在ndk17上已经被删除了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This mipsel-linux-android-4.9 directory exists to make the NDK compatible with the Android</span><br><span class="line">SDK&apos;s Gradle plugin, version 3.0.1 and earlier, which expects the NDK</span><br><span class="line">to have a MIPS toolchain directory.</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong><br>一种解决办法是同时升级gradle编译工具的版本。但是因为项目的原因，无法使用最新版本的gradle编译工具，只能使用2.3.0版本的编译工具，所以使用一个绕过问题的方法，<br>在<code>/Users/Ivonhoe/Library/Android/sdk/ndk-bundle/toolchains/mips64el-linux-android-4.9/prebuilt/darwin-x86_64/bin/</code>目录创建一个<code>mips64el-linux-android-strip</code>的空文件。记得使用<code>chmod</code>命令修改空文件的执行权限。</p><h4 id="0x03-参考文档："><a href="#0x03-参考文档：" class="headerlink" title="0x03 参考文档："></a>0x03 参考文档：</h4><p><a href="https://github.com/android-ndk/ndk/issues/700" target="_blank" rel="noopener">React Native apps fail to build since NDK update to r17 (due to missing mipsel-linux-android-4.9 toolchain files)</a></p><h3 id="转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="转载请标明出处病已blog https://ivonhoe.github.io/"></a>转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;0x01-问题描述&quot;&gt;&lt;a href=&quot;#0x01-问题描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 问题描述&quot;&gt;&lt;/a&gt;0x01 问题描述&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;现象：&lt;/strong&gt; 将ndk版本升级到    &lt;code&gt;17.0.4754217&lt;/code&gt;编译报错&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* What went wrong:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Execution failed for task &amp;apos;:app+stub:transformNativeLibsWithStripDebugSymbolForRelease&amp;apos;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; A problem occurred starting process &amp;apos;command &amp;apos;/Users/Ivonhoe/Library/Android/sdk/ndk-bundle/toolchains/mips64el-linux-android-4.9/prebuilt/darwin-x86_64/bin/mips64el-linux-android-strip&amp;apos;&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Try:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Caused by: java.io.IOException: Cannot run program &amp;quot;/Users/Ivonhoe/Library/Android/sdk/ndk-bundle/toolchains/mips64el-linux-android-4.9/prebuilt/darwin-x86_64/bin/mips64el-linux-android-strip&amp;quot; (in directory &amp;quot;/Users/Ivonhoe/Workspace/keyaccount-repo/app+stub&amp;quot;): error=2, No such file or directory&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at net.rubygrapefruit.platform.internal.DefaultProcessLauncher.start(DefaultProcessLauncher.java:25)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ... 4 more&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Caused by: java.io.IOException: error=2, No such file or directory&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ... 5 more&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Bug总结" scheme="https://ivonhoe.github.io/categories/Bug%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>深入浅出JVM垃圾回收算法</title>
    <link href="https://ivonhoe.github.io/2018/06/03/jvm-gc-1/"/>
    <id>https://ivonhoe.github.io/2018/06/03/jvm-gc-1/</id>
    <published>2018-06-03T14:43:32.000Z</published>
    <updated>2018-09-11T13:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h4><p>在学习JVM如何进行垃圾回收方法时，发现所谓的JVM垃圾回收思想和现实生活的场景有很多相似的地方。所以用餐厅回收餐桌的方式类比JVM垃圾回收算法，应该能帮助JVM学习的理解和记忆。</p><h4 id="0x01-经典垃圾回收算法"><a href="#0x01-经典垃圾回收算法" class="headerlink" title="0x01 经典垃圾回收算法"></a>0x01 经典垃圾回收算法</h4><blockquote><p>标记-清除（Mark-Sweep）</p></blockquote><p>研发园开了家新餐厅，餐厅老板在考虑如何回收餐盘时先使用了最简单的方式，那就是服务员在顾客用餐的过程中，不定时的观察餐厅，针对用完餐的顾客记录他们的位置（当然一般的服务员的脑海中自行处理），统一回收他们的餐具和餐盘。这种回收方式会有一个明显的问题，那就是回收后的餐厅座位，很有可能是不连续的。如果后续有同行的顾客想坐在一起，那很可能找不到连续的座位。</p><a id="more"></a><p><img src="/res/gc/mark.jpg" alt></p><blockquote><p>复制算法（Copying）</p></blockquote><p>为了解决餐厅座位碎片化的问题，餐厅的老板提出了一个大胆的想法，这是一个很会思考的老板。把餐厅的用餐区域分成两部分A厅和B厅，当对A厅中的餐桌做回收时，将A厅中还未用完餐的顾客，‘请’到B厅去用餐，并且让这些顾客在B厅中拼桌用餐（为了餐位连续）。这样所有A厅中的位置都空余出来了，并且B厅中的用餐区域和未用餐区域都是连续的！简直是强迫症晚期。看似完美的解决了回收后餐位碎片化的问题。但是依然带来了其他的一些问题。</p><p>缺点：</p><ul><li>餐厅的运营区域是一个整体，现在只能同时对外开放A厅，运营空间变小了。</li><li>当有很多顾客需要从A厅转移到B厅时，效率太低。</li><li>用餐体验很差</li></ul><p>优点：</p><ul><li>不容易产生碎片</li></ul><p><img src="/res/gc/copy.jpg" alt></p><blockquote><p>标记-整理算法（Mark-Compact）</p></blockquote><p>当实行复制算法解决餐位回收的问题后，餐厅的老板针对新问题又有了新想法，只要移动顾客就可以解决碎片化问题，为啥我要将餐厅分成两个部分呢？毕竟那样不能最大效率的利用餐厅的用餐区域。创造性的提出了标记-整理算法，结合前面两中方法的优缺点，当餐厅准备回收餐位时，移动所有未用晚餐的顾客，并且让从餐厅的第一桌开始拼桌。保证后面的餐桌都是回收的并且座位都是连续的。这样既提高了餐厅餐桌的利用率又保证了当有大量组团顾客进店用餐时，餐厅能够提供大量的连续餐桌。</p><p><img src="/res/gc/mark-compact.jpg" alt></p><h4 id="0x02-分代收集（Generational-Collection）"><a href="#0x02-分代收集（Generational-Collection）" class="headerlink" title="0x02 分代收集（Generational Collection）"></a>0x02 分代收集（Generational Collection）</h4><p>如果还是用开餐厅的方式来思考JVM的话，可以把分代回收看做餐厅针对不同顾客的等级推出的个性化服务。分代收集算法并没有新的思想，只是根据对象存活周期的不同将内存划分为几块，一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，大量的对象都是’朝生夕死‘，每次垃圾回收是，都可以发现大量对象死去，所以针对新生代的垃圾回收一般选择<strong>复制算法</strong>。只需要复制少量存活对象就可以完成收集。针对老年代的垃圾回收，对象的存活时间较长，就必须使用<strong>’标记-清除‘或者’标记-整理‘</strong>算法来进行回收。</p><p>在新生代中，绝大多数的对象都是’朝生夕死‘的，新生代并不需要按照1：1的比例划分内存空间，而是将内存分为一个较大的Eden空间和一个较小的Survivor空间，并将Survivor空间分成两个较小空间，分别是From Space和ToSpace。每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中。Hotspot虚拟机默认Eden和Survivor的大小比例是8：1，也就是每次新生代可用内存空间为整个新生代容量的90%。</p><p><img src="/res/gc/gc.jpg" alt></p><p>这里很显然会有一个问题，理论上每次新生代GC都会回收绝大多数的对象，但是无法保证GC存活后的对象大学都不超过整个新生代的10%。当Survivor空间的内存不够用是，就需要老年代做内存担保。同样用餐厅的理论来理解，你希望把A厅的顾客转移到B厅，但是B厅已经没有足够空间容纳所有顾客了，这时候可以选择将顾客安置在VIP包厢【老年代】。并且每次在新生代GC中存活的对象，其年龄就会+1，默认情况下年龄达到15的对象会被转移到老年代。这里也很好理解，餐厅的忠实吃货为啥不给办张VIP卡呢？</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href>《深入理解Java虚拟机》周志明 著</a></p><p><a href="https://www.cnblogs.com/cielosun/p/6674431.html" target="_blank" rel="noopener">Java基础：JVM垃圾回收算法</a></p><h3 id="转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="转载请标明出处病已blog https://ivonhoe.github.io/"></a>转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h4&gt;&lt;p&gt;在学习JVM如何进行垃圾回收方法时，发现所谓的JVM垃圾回收思想和现实生活的场景有很多相似的地方。所以用餐厅回收餐桌的方式类比JVM垃圾回收算法，应该能帮助JVM学习的理解和记忆。&lt;/p&gt;
&lt;h4 id=&quot;0x01-经典垃圾回收算法&quot;&gt;&lt;a href=&quot;#0x01-经典垃圾回收算法&quot; class=&quot;headerlink&quot; title=&quot;0x01 经典垃圾回收算法&quot;&gt;&lt;/a&gt;0x01 经典垃圾回收算法&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;标记-清除（Mark-Sweep）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;研发园开了家新餐厅，餐厅老板在考虑如何回收餐盘时先使用了最简单的方式，那就是服务员在顾客用餐的过程中，不定时的观察餐厅，针对用完餐的顾客记录他们的位置（当然一般的服务员的脑海中自行处理），统一回收他们的餐具和餐盘。这种回收方式会有一个明显的问题，那就是回收后的餐厅座位，很有可能是不连续的。如果后续有同行的顾客想坐在一起，那很可能找不到连续的座位。&lt;/p&gt;
    
    </summary>
    
      <category term="学习总结" scheme="https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JVM" scheme="https://ivonhoe.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>拒绝单例模式</title>
    <link href="https://ivonhoe.github.io/2018/05/27/singleton/"/>
    <id>https://ivonhoe.github.io/2018/05/27/singleton/</id>
    <published>2018-05-27T14:23:37.000Z</published>
    <updated>2018-09-11T13:29:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h3><p>相信很多同学在学习设计模式的过程中，最先了解的就是单例模式，至少我是这样。单例模式看似简单容易理解，实际上却有很多坑，正因为这样也成为了很多公司面试必考的面试题。实际使用单例模式时，难免会遇到滥用的情况，理解单例更要学会何时拒绝单例。</p><h3 id="0x01单例模式的基础知识"><a href="#0x01单例模式的基础知识" class="headerlink" title="0x01单例模式的基础知识"></a>0x01单例模式的基础知识</h3><h4 id="1-单例的几种写法"><a href="#1-单例的几种写法" class="headerlink" title="1. 单例的几种写法?"></a>1. 单例的几种写法?</h4><a id="more"></a><ul><li>懒汉式: 懒加载模式，需要的时候才创建实例。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。需要考虑线程安全问题。</li><li>饿汉式：单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</li><li>静态内部类：JVM本身机制保证了线程安全问题，由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</li></ul><h4 id="2-为什么要双重检验锁"><a href="#2-为什么要双重检验锁" class="headerlink" title="2. 为什么要双重检验锁?"></a>2. 为什么要双重检验锁?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Singleton getSingleton() &#123;</span><br><span class="line">    if (instance == null) &#123;                         //Single Checked</span><br><span class="line">        synchronized (Singleton.class) &#123;</span><br><span class="line">            if (instance == null) &#123;                 //Double Checked</span><br><span class="line">                instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。</li><li>不然，我们就开始同步线程。</li><li>第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。</li></ol><h4 id="3-重排序问题"><a href="#3-重排序问题" class="headerlink" title="3. 重排序问题"></a>3. 重排序问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = new Singleton()</span><br></pre></td></tr></table></figure><p>这并不是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p><ol><li>给 instance 分配内存</li><li>调用 Singleton 的构造函数来初始化成员变量</li><li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li></ol><p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。<br>对此，我们只需要把singleton声明成 volatile 就可以了。</p><h3 id="0x02-滥用单例带来哪些问题？"><a href="#0x02-滥用单例带来哪些问题？" class="headerlink" title="0x02 滥用单例带来哪些问题？"></a>0x02 滥用单例带来哪些问题？</h3><p>你的项目中可能会有一堆的Manager或者Controller，最简单获取方法是把他们设计成一个个单例，只需要通过一个getInstance的方法获取到他的唯一实例对象，在任何代码中的任何地方，甚至不需要上下文。是否思考过下面的这些问题？</p><blockquote><p>1.你的单例会有应用的生命周期吗？</p></blockquote><p>按照单例的定义，无法构建除该单例以外的实例，并且这个单例有一个静态引用，单例不会被虚拟机垃圾回收。单例对象一旦创建，对象的引用是保存在静态区，<strong>单例对象在堆上分配的内存空间只有在程序终止后才会释放</strong>，过多的单例必然增大内存的消耗，<strong>并且如果你的单例中的上下文引用了不当，可能会造成严重的内存泄露问题</strong>。单例的设计应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该用单例来管理。</p><blockquote><p>2.如何尽可能的减少依赖【耦合】？</p></blockquote><p>有依赖就有耦合，如果你的单例提供的是某一个特定功能的公共方法或状态。那调用方和被调用方就会因为单例的设计建立了强耦合关系。甚至更极端的情况中，包含了多个单例之间的相互依赖甚至循环依赖关系。那你永远不可能将各种角色模块化拆分出来。</p><blockquote><p>3.如果你想针对你的单例做扩展或升级怎么办?</p></blockquote><p>对单例的实现升级其实并不是单例模式要解决的问题，但是<strong>单例模式缺少抽象</strong>，在使用过程中必然会遇到这样的问题。在业务的发展过程中，一定会遇到需要对已有单例进行实现升级的情况，比如你需要对相同功能换一种方式实现？或者需要增加删除一个方法或接口？甚至可能变成一个完全不一样的功能。这时候的单例就会遇到一些问题，你不单单需要修改单例，你还需要修改依赖单例的上层业务代码。</p><h3 id="0x03如何尽可能少的使用单例模式？"><a href="#0x03如何尽可能少的使用单例模式？" class="headerlink" title="0x03如何尽可能少的使用单例模式？"></a>0x03如何尽可能少的使用单例模式？</h3><p>单例的好处是简单易用，单例模式在系统设置了全局的访问点，优化和共享资源的访问。但是滥用单例也带来的上述的三个方面的危害，无法统一管理对象的生命周期、增加耦合、针对实现编程而不是针对接口编程。如何享受单例模式带来的好处并且解决她带来的危害在于，如何通过一种解耦的方式全局获取一个单例对象，并且这个单例对象的生命周期是可管理的，并且这个单例对象是针对接口的抽象实现。</p><ul><li>针对接口实现：单例不再提供getInstance方法，并且根据不同的抽象接口实现</li><li>提供全局的访问点: 调用方可以通过全局的SingleManager获取实现接口的具体实例</li><li>可管理的对象生命周期: 所有的单例的唯一对象都由SingleManager管理</li><li>低耦合的：为了避免循环引用问题，<strong>SingletonManager在运行时根据配置文件通过反射的方式实例化每个接口的具体实现类</strong>，调用方只依赖SingletonManager，并且通过SingletonManager获取接口的实现实例</li></ul><p><img src="/res/singleton/singleton.png" alt></p><h3 id="0x04-参考文档"><a href="#0x04-参考文档" class="headerlink" title="0x04 参考文档"></a>0x04 参考文档</h3><p><a href="https://coolshell.cn/articles/265.html" target="_blank" rel="noopener">深入浅出单实例SINGLETON设计模式</a></p><h3 id="转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="转载请标明出处病已blog https://ivonhoe.github.io/"></a>转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00前言&quot;&gt;&lt;a href=&quot;#0x00前言&quot; class=&quot;headerlink&quot; title=&quot;0x00前言&quot;&gt;&lt;/a&gt;0x00前言&lt;/h3&gt;&lt;p&gt;相信很多同学在学习设计模式的过程中，最先了解的就是单例模式，至少我是这样。单例模式看似简单容易理解，实际上却有很多坑，正因为这样也成为了很多公司面试必考的面试题。实际使用单例模式时，难免会遇到滥用的情况，理解单例更要学会何时拒绝单例。&lt;/p&gt;
&lt;h3 id=&quot;0x01单例模式的基础知识&quot;&gt;&lt;a href=&quot;#0x01单例模式的基础知识&quot; class=&quot;headerlink&quot; title=&quot;0x01单例模式的基础知识&quot;&gt;&lt;/a&gt;0x01单例模式的基础知识&lt;/h3&gt;&lt;h4 id=&quot;1-单例的几种写法&quot;&gt;&lt;a href=&quot;#1-单例的几种写法&quot; class=&quot;headerlink&quot; title=&quot;1. 单例的几种写法?&quot;&gt;&lt;/a&gt;1. 单例的几种写法?&lt;/h4&gt;
    
    </summary>
    
      <category term="框架设计" scheme="https://ivonhoe.github.io/categories/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="设计模式" scheme="https://ivonhoe.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS</title>
    <link href="https://ivonhoe.github.io/2018/05/21/https/"/>
    <id>https://ivonhoe.github.io/2018/05/21/https/</id>
    <published>2018-05-21T13:55:38.000Z</published>
    <updated>2018-09-11T13:28:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>https为什么安全？因为相对http的明文传输，https引入了数据加密和身份认证。服务器和客户端的消息只有服务器和客户端能够读懂，保证了数据的保密性。同时在交换数据之前，验证了对方的合法身份，保证了通信双方的安全。这篇总结主要记录了在理解https安全性的过程中遇到的问题。</p><h3 id="0x01-什么是对称加密和非对称加密"><a href="#0x01-什么是对称加密和非对称加密" class="headerlink" title="0x01 什么是对称加密和非对称加密"></a>0x01 什么是对称加密和非对称加密</h3><p>在https的协议中如何实现数据加密和身份认证呢？简单来说是客户端先获取非对称加密的公钥，通过公钥和服务器协商生成对称加密的对称密钥，并使用对称密钥加密传输数据。</p><a id="more"></a><p><img src="/res/https/https-1.png" alt></p><h4 id="1-1-对称加密"><a href="#1-1-对称加密" class="headerlink" title="1.1 对称加密"></a>1.1 对称加密</h4><p><strong>什么是对称加密：</strong>加密和解密使用相同密钥的算法。它要求发送方和接收方在安全通信之前，商定一个对称密钥。对称算法的安全性完全依赖于密钥，密钥泄漏就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。</p><p><strong>特点：</strong>计算量小、加密速度快、加密效率高。交易双方都使用同样密钥，安全性得不到保证。每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信息双方所拥有的钥匙数量呈几何级数增长，密钥管理成为负担。</p><p><strong>代表算法：</strong> DES、AES</p><h4 id="1-2-非对称加密"><a href="#1-2-非对称加密" class="headerlink" title="1.2 非对称加密"></a>1.2 非对称加密</h4><p><strong>什么是非对称加密：</strong> 需要两个密钥来进行加密和解密。分别是公开密钥和私有密钥。如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 </p><p><strong>特点：</strong> CPU计算资源消耗非常大，效率较低。非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是2048位，意味着待加密内容不能超过256个字节。</p><p><strong>代表算法：</strong> RSA</p><h3 id="0x02-中间人劫持"><a href="#0x02-中间人劫持" class="headerlink" title="0x02 中间人劫持"></a>0x02 中间人劫持</h3><p>如果在通信过程中，客户端的请求被中间人劫持，那么中间人可以就可伪装成“冒牌客户端”和服务器通信，同时伪装成“冒牌服务器”与客户端通信。从而达到获取客户端服务端通信内容的目的！主要过程如下：</p><ol><li>中间人在服务器发送公钥之前劫持客户端请求，伪造客户端向服务端发起SSL握手</li><li>中间人获取服务端加密公钥，伪造出一个自己的公钥发送给客户端</li><li>客户端接受到伪造的公钥，使用伪造的公钥发送对称密钥</li><li>中间人劫持到对称密钥，并利用自己的私钥解密出对称密钥</li><li>利用步骤2中的正确服务器加密公钥，加密客户端对称密钥发送给服务</li><li>客户端和服务器使用被中间人破解的对称密钥传输数据，中间人可以获取所有传输信息</li></ol><p><img src="/res/https/https-2.jpeg" alt></p><h4 id="2-1-数字签名"><a href="#2-1-数字签名" class="headerlink" title="2.1 数字签名"></a>2.1 数字签名</h4><p>数字签名过程：</p><ol><li>服务端把一个报文经过HASH处理生成消息摘要信息Digest，使用私钥加密摘要信息生成签名信息。</li><li>将报文、签名发生给客户端</li><li>客户端使用相同的HASH算法对报文做相同的HASH处理，获取摘要Digest1</li><li>客户端使用公钥解密签名生成摘要Digest2，并且对比Digest1和Digest2是否一致</li><li>如果Digest1和Digest2一致说明报文没有被篡改过，这份报文和签名是对应的，具有不可抵赖性。</li></ol><h4 id="2-2-数字证书"><a href="#2-2-数字证书" class="headerlink" title="2.2 数字证书"></a>2.2 数字证书</h4><p>解决中间人劫持问题的关键在于，客户端如何能够分辨出接收到的公钥确实是服务端的呢？这时候就需要数字证书了。</p><p>数字证书是公司向一个证书发布机构”SecureTrust CA”申请的。这个证书发布机构”SecureTrust CA”是一个大家公认并被一些权威机构接受的证书发布机构，<strong>并且我们的操作系统里面已经安装了”SecureTrust CA”的证书</strong>。”SecureTrust CA”在给我们发布证书时，把Issuer,Public key,Subject,Valid from,Valid to等信息以明文的形式写到证书里面，然后用一个摘要算法计算出这些数字证书内容的一个Digest，并使用CA自己的私钥对Digest进行加密，生成证书的数字签名。</p><p>验证公钥过程：</p><ol><li>服务端将证书发送给客户端，<strong>这里不是公钥</strong></li><li>客户端提取证书中的发布机构(Issuer)为”SecureTrust CA”，在操作系统中受信任的发布机构的证书中去找”SecureTrust CA”的证书，如果查不到说明证书有问题。</li><li>如果找到了”SecureTrust CA”的证书，客户端从系统的证书中提取”SecureTrust CA”的公钥，</li><li>使用CA公钥对步骤1中获取到证书中的签名信息的进行解密获取解密摘要，并使用摘要算法计算证书的摘要</li><li>对比解密摘要和计算出的摘要信息是否一致。如果一致说明认证成功，当前证书中包含的公钥信息是可以信认的。</li></ol><p><img src="/res/https/https-3.jpeg" alt></p><p>数字证书中包含公钥和证书所有者信息，并且保证数字证书里的公钥确实是这个证书的所有者的，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p><strong>数字签名：</strong>为了说明谁编写的报文，同时证明报文未被篡改过。</p><p><strong>数字证书：</strong>由权威的认证机构证明公钥的正确性。</p><h3 id="0x04-参考文档"><a href="#0x04-参考文档" class="headerlink" title="0x04 参考文档"></a>0x04 参考文档</h3><p><a href="http://wetest.qq.com/lab/view/110.html" target="_blank" rel="noopener">HTTPS为什么安全 &amp;分析 HTTPS 连接建立全过程</a></p><p><a href="https://www.cnblogs.com/franson-2016/p/5530671.html" target="_blank" rel="noopener">一个故事教你看懂什么是数字证书，它的原理是什么?它的作用是什么？</a></p><h3 id="转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="转载请标明出处病已blog https://ivonhoe.github.io/"></a>转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;https为什么安全？因为相对http的明文传输，https引入了数据加密和身份认证。服务器和客户端的消息只有服务器和客户端能够读懂，保证了数据的保密性。同时在交换数据之前，验证了对方的合法身份，保证了通信双方的安全。这篇总结主要记录了在理解https安全性的过程中遇到的问题。&lt;/p&gt;
&lt;h3 id=&quot;0x01-什么是对称加密和非对称加密&quot;&gt;&lt;a href=&quot;#0x01-什么是对称加密和非对称加密&quot; class=&quot;headerlink&quot; title=&quot;0x01 什么是对称加密和非对称加密&quot;&gt;&lt;/a&gt;0x01 什么是对称加密和非对称加密&lt;/h3&gt;&lt;p&gt;在https的协议中如何实现数据加密和身份认证呢？简单来说是客户端先获取非对称加密的公钥，通过公钥和服务器协商生成对称加密的对称密钥，并使用对称密钥加密传输数据。&lt;/p&gt;
    
    </summary>
    
      <category term="学习总结" scheme="https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="网络" scheme="https://ivonhoe.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="对称加密" scheme="https://ivonhoe.github.io/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="非对称加密" scheme="https://ivonhoe.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="数字签名，数字证书" scheme="https://ivonhoe.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%EF%BC%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化之资源加载机制</title>
    <link href="https://ivonhoe.github.io/2018/03/14/small-bug-555-fix/"/>
    <id>https://ivonhoe.github.io/2018/03/14/small-bug-555-fix/</id>
    <published>2018-03-14T09:23:27.000Z</published>
    <updated>2018-09-18T09:52:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>这篇文章主要记录了在使用Small插件化框架中遇到的资源加载问题及相应解决方案，并梳理出Android的资源加载流程和插件化框架的资源加载原理。在前两篇插件化技术介绍的基础上会关注更多技术细节，希望能有所收获！</p><h3 id="关于Small插件化的其他文档："><a href="#关于Small插件化的其他文档：" class="headerlink" title="关于Small插件化的其他文档："></a>关于Small插件化的其他文档：</h3><p><a href="http://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"><strong>《Android插件化之Small框架实践总结》</strong></a><br><a href="http://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"><strong>《Android插件化之Small框架原理》</strong></a><br><a href="https://ivonhoe.github.io/2018/07/18/abandon-the-plugin-framework/"><strong>《Android插件化之从入门到放弃》</strong></a></p><h3 id="0x01-Small框架的资源加载异常"><a href="#0x01-Small框架的资源加载异常" class="headerlink" title="0x01 Small框架的资源加载异常"></a>0x01 Small框架的资源加载异常</h3><p>最近收到一个客户反馈，在他们的中兴V0840手机上打开我们的app会持续崩溃。第一时间在百度移动质量平台上短时租用了该机型，抓取了log。发现是资源查找失败异常。并在Small github issues中搜索<code>android.content.res.Resources$NotFoundException</code> 可以发现很多类似的问题，详细日志可查看下图。</p><a id="more"></a><p>Github issus链接：<a href="https://github.com/wequick/Small/issues/555" target="_blank" rel="noopener">#555 Small Sample项目打包后在ZTE上闪退</a></p><p><strong>项目崩溃日志：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): FATAL EXCEPTION: main</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): Process: com.shandiangou.kaguanjia, PID: 8189</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.shandiangou.kaguanjia/com.shandiangou.kaguanjia.app.main.activity.GuideActivity&#125;: android.content.res.Resources$NotFoundException: Resource ID #0x2a030010</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2669)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2730)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.ActivityThread.-wrap12(ActivityThread.java)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1481)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.os.Looper.loop(Looper.java:154)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.ActivityThread.main(ActivityThread.java:6144)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:886)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:776)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): Caused by: android.content.res.Resources$NotFoundException: Resource ID #0x2a030010</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.content.res.ResourcesImpl.getValue(ResourcesImpl.java:196)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.content.res.Resources.loadXmlResourceParser(Resources.java:2101)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.content.res.Resources.getLayout(Resources.java:1115)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.view.LayoutInflater.inflate(LayoutInflater.java:424)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.view.LayoutInflater.inflate(LayoutInflater.java:377)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.shandiangou.kaguanjia.common.base.CustomProgressDialog.init(CustomProgressDialog.java:38)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.shandiangou.kaguanjia.common.base.CustomProgressDialog.&lt;init&gt;(CustomProgressDialog.java:26)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.shandiangou.kaguanjia.common.base.BaseActivity.initProgressDialog(BaseActivity.java:27)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.shandiangou.kaguanjia.common.base.BaseActivity.onCreate(BaseActivity.java:22)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.shandiangou.kaguanjia.app.main.activity.GuideActivity.onCreate(GuideActivity.java:45)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.Activity.performCreate(Activity.java:6722)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1119)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at net.wequick.small.ApkBundleLauncher$InstrumentationWrapper.callActivityOnCreate(ApkBundleLauncher.java:334)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2622)</span><br><span class="line">03-06 17:48:31.685 E/AndroidRuntime( 8189): ... 9 more</span><br><span class="line">03-06 17:48:31.688 W/ActivityManager( 1384):   Force finishing activity com.shandiangou.kaguanjia/net.wequick.small.A</span><br></pre></td></tr></table></figure><p><strong>Small框架官方Sample崩溃日志</strong></p><p><img src="/res/small/small-error.png" alt></p><h3 id="0x02-Android资源加载流程"><a href="#0x02-Android资源加载流程" class="headerlink" title="0x02 Android资源加载流程"></a>0x02 Android资源加载流程</h3><p><strong>Android源码Resources创建流程图：</strong></p><p><img src="/res/small/android-resources1.png" alt></p><p>ActivityThread在接收到LAUNCH_ACTIVITY消息以后，在 <code>performLaunchActivity</code>方法中，使用Instrumentation通过反射的方式创建Activity实例，再创建Activity的Base Context, 并在创建Context过程中实例化AssetManger和Resources。<br>ActivityThread在LAUNCH_ACTIVITY消息中，完成了Activity生命周期中的三个回调，分别是<code>onCreate</code> <code>onStart</code> <code>onRestoreInstanceState</code>。</p><p>Android中资源管理类在不同sdk版本中的关系如下图所示。</p><p><img src="/res/small/android-resources2.png" alt="Android源码资源类图"></p><h3 id="0x03-Small框架插件资源加载方案"><a href="#0x03-Small框架插件资源加载方案" class="headerlink" title="0x03 Small框架插件资源加载方案"></a>0x03 Small框架插件资源加载方案</h3><p>Small框架的资源加载流程在ApkBundleLauncher中完成，<code>setup</code>流程获取到所有插件so的信息，在<code>postSetUp</code>中获取所有插件包的资源路径，通过反射调用AssetManager的<code>addAssetPaths</code>方法，构造一个包含宿主包资源、系统资源和插件包资源的AssetManger。最后还是通过反射，使用包含所有资源的AssetManager替换掉ResourcesManager中Resources的AssetManger，最终达到加载插件中资源的目的。</p><p><strong>Small框架资源加载流程:</strong></p><p><img src="/res/small/android-resources4.png" alt="Android源码资源类图"></p><h3 id="0x04-bug修复方案"><a href="#0x04-bug修复方案" class="headerlink" title="0x04 bug修复方案"></a>0x04 bug修复方案</h3><p>看完Small插件资源加载流程，你是否有疑问？Small只在框架加载时对ResourcesManager进行了hook，好像在创建新的Resources并没有进行hook操作？那么当系统新创建Resources实例时，新的Resources中包含的资源路径并没有插件资源，这好像说不通吧。其实关注Small的源码中<code>ReflectAccelerator.ensureCacheResources</code>，这个方法想要的达到的作用是当每次启动Activity时遍历系统缓存的ResourceImpl，将它的AssetManager替换成包含插件资源的AssetManager。当然这个机制只在SDK&gt;=24时生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void ensureCacheResources() &#123;</span><br><span class="line">    if (Build.VERSION.SDK_INT &lt; 24) return;</span><br><span class="line">    if (sResourceImpls == null || sMergedResourcesImpl == null) return;</span><br><span class="line"></span><br><span class="line">    Set&lt;?&gt; resourceKeys = sResourceImpls.keySet();</span><br><span class="line">    for (Object resourceKey : resourceKeys) &#123;</span><br><span class="line">        WeakReference resourceImpl = (WeakReference)sResourceImpls.get(resourceKey);</span><br><span class="line">        if (resourceImpl != null &amp;&amp; resourceImpl.get() != sMergedResourcesImpl) &#123;</span><br><span class="line">            // Sometimes? the weak reference for the key was released by what</span><br><span class="line">            // we can not find the cache resources we had merged before.</span><br><span class="line">            // And the system will recreate a new one which only build with host resources.</span><br><span class="line">            // So we needs to restore the cache. Fix #429.</span><br><span class="line">            // FIXME: we&apos;d better to find the way to KEEP the weak reference.</span><br><span class="line">            sResourceImpls.put(resourceKey, new WeakReference&lt;Object&gt;(sMergedResourcesImpl));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里有两个问题:</strong></p><ol><li>SDK&lt;24时，在原生的Android系统中并不是每启动一个Activity都会创建一个新的Resources实例，ResourcesManager会使用缓存的Resources实例，所以只需要Hook一次资源加载。但是一旦创建多个Resources实例时，是不是意味着新创建的Resources并会包含插件的资源路径。个人理解是这样的。这应该也能解释为啥Small框架会在某些手机的<strong>分屏模式</strong>和某些<strong>横竖屏切换</strong>的时候会发生Crash，详情请查看<a href="https://github.com/wequick/Small/issues/356" target="_blank" rel="noopener">#356</a>和<a href="https://github.com/wequick/Small/issues/548" target="_blank" rel="noopener">#548</a></li><li>SDK&gt;24时，Small会执行<code>ensureCacheResources</code>希望将新创建的ResourcesImpl的AssetsManger替换掉。但是看到源码中的实现方式是，通过反射为ActivityThread的<code>mH</code>Handler注入一个<code>Handler.Callback</code>。当HandlerCallback handleMessage LAUNCH_ACTIVITY消息时，执行<code>ensureCacheResources</code>方法。查看Handler的<code>dispatchMessage</code>发现<code>mCallback.handleMessage</code>是先于<code>mHandler.handleMessage</code>的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Handle system messages here.</span><br><span class="line"> */</span><br><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 <strong>0x02 Android资源加载流程</strong> 的资源流程，你会发现Resources对象的实例化并将ResourcesImpl添加到ResourcesManger的缓存列表中是在<code>Handler.handleMessage</code>之后的。所以<code>ensureCacheResources</code>并不能保证启动Activity时<strong>新创建的</strong>ResourcesImpl实例能够被正常hook的！！</p><p>综上所述，这就是文章开头中兴手机Android7.1系统的手机上使用Small框架会发生Crash问题的原因，因为<strong>中兴系统每次打开新的Activity都会创建一个新的Resources和ResourcesImpl实例，而这些都是没有被hook的，不包含插件资源路径</strong>，自然就会发生资源查找失败的异常。解决方法也比较简单，因为是SDK&gt;24的机器，只需要在Small框架的<code>InstrumentationWrapper.callActivityOnCreate</code>方法中执行<code>ReflectAccelerator.ensureCacheResources()</code>就可以解决上面的问题了。</p><p>同时你需要注意另一个问题，查看ActivityThread的源码，在启动Activity流程的<code>performLaunchActivity</code>方法中，在<code>mInstrumentation.callActivityOnCreate</code>之前系统会为Activity设置主题。如果你选择在<code>mInstrumentation.callActivityOnCreate</code>中执行Resources的hook，并且此时需要的主题资源恰好在插件中，那依然会发生Crash。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    ....</span><br><span class="line">    ....省略其他代码</span><br><span class="line">    int theme = r.activityInfo.getThemeResource();</span><br><span class="line">    if (theme != 0) &#123;</span><br><span class="line">        activity.setTheme(theme);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    activity.mCalled = false;</span><br><span class="line">    if (r.isPersistable()) &#123;</span><br><span class="line">        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">    &#125;</span><br><span class="line">    ....省略其他代码</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我的建议是把你项目中所有的主题定义都放在宿主中，并且修改Small的框架代码在<code>InstrumentationWrapper.callActivityOnCreate</code>方法中执行<code>ReflectAccelerator.ensureCacheResources</code>方法，这样就可以解决Small框架在某些场景下发生<code>Resources$NotFoundException</code>异常的问题。</p><h3 id="0x05-完"><a href="#0x05-完" class="headerlink" title="0x05 完"></a>0x05 完</h3><p>Small插件化框架是我在项目中使用的框架，他的设计和实现思路上都非常优雅，是首选的轻量级插件化框架。以上分析只是对Android源码和Small框架的个人理解，如有理解有误的地方还望指出，个人微信号:tykYang，邮箱:<a href="mailto:yangfan3687@163.com" target="_blank" rel="noopener">yangfan3687@163.com</a>。🙏🙏🙏</p><h3 id="转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="转载请标明出处病已blog https://ivonhoe.github.io/"></a>转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;这篇文章主要记录了在使用Small插件化框架中遇到的资源加载问题及相应解决方案，并梳理出Android的资源加载流程和插件化框架的资源加载原理。在前两篇插件化技术介绍的基础上会关注更多技术细节，希望能有所收获！&lt;/p&gt;
&lt;h3 id=&quot;关于Small插件化的其他文档：&quot;&gt;&lt;a href=&quot;#关于Small插件化的其他文档：&quot; class=&quot;headerlink&quot; title=&quot;关于Small插件化的其他文档：&quot;&gt;&lt;/a&gt;关于Small插件化的其他文档：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/&quot;&gt;&lt;strong&gt;《Android插件化之Small框架实践总结》&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/&quot;&gt;&lt;strong&gt;《Android插件化之Small框架原理》&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://ivonhoe.github.io/2018/07/18/abandon-the-plugin-framework/&quot;&gt;&lt;strong&gt;《Android插件化之从入门到放弃》&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x01-Small框架的资源加载异常&quot;&gt;&lt;a href=&quot;#0x01-Small框架的资源加载异常&quot; class=&quot;headerlink&quot; title=&quot;0x01 Small框架的资源加载异常&quot;&gt;&lt;/a&gt;0x01 Small框架的资源加载异常&lt;/h3&gt;&lt;p&gt;最近收到一个客户反馈，在他们的中兴V0840手机上打开我们的app会持续崩溃。第一时间在百度移动质量平台上短时租用了该机型，抓取了log。发现是资源查找失败异常。并在Small github issues中搜索&lt;code&gt;android.content.res.Resources$NotFoundException&lt;/code&gt; 可以发现很多类似的问题，详细日志可查看下图。&lt;/p&gt;
    
    </summary>
    
      <category term="Android插件化" scheme="https://ivonhoe.github.io/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="插件化" scheme="https://ivonhoe.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Android源码" scheme="https://ivonhoe.github.io/tags/Android%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化之Small框架原理</title>
    <link href="https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"/>
    <id>https://ivonhoe.github.io/2018/01/18/Small框架原理/</id>
    <published>2018-01-18T09:54:19.000Z</published>
    <updated>2018-09-18T09:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>Small是一个轻量化的插件化框架，Small的使用介绍可以查看<a href="http://code.wequick.net/Small/cn/quickstart" target="_blank" rel="noopener">官网文档</a>了解，Small项目接入总结可以查看博客的另一篇<a href="https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/">《Small框架实践总结》</a>。这篇文章主要从以下几个角度来看Small框架的实现原理。</p><ol><li>Small如何实现插件代码打包和资源打包</li><li>Small加载插件代码和资源的原理</li><li>Small代理插件activity生命周期的原理</li></ol><h3 id="关于Small插件化的其他文档："><a href="#关于Small插件化的其他文档：" class="headerlink" title="关于Small插件化的其他文档："></a>关于Small插件化的其他文档：</h3><p><a href="http://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"><strong>《Android插件化之Small框架实践总结》</strong></a><br><a href="http://ivonhoe.github.io/2018/03/14/small-bug-555-fix/"><strong>《Android插件化之资源加载机制》</strong></a><br><a href="https://ivonhoe.github.io/2018/07/18/abandon-the-plugin-framework/"><strong>《Android插件化之从入门到放弃》</strong></a></p><a id="more"></a><h3 id="0x01-Small如何打包module代码"><a href="#0x01-Small如何打包module代码" class="headerlink" title="0x01 Small如何打包module代码?"></a>0x01 Small如何打包module代码?</h3><p>small插件化中的三种组件角色，分别是<code>app.*</code>，<code>lib.*</code>，<code>宿主</code>。small在打包过程中会根据不同module的类型针对不同组件使用不同编译插件做处理，分别是:</p><ol><li><code>AppPlugin</code> –&gt; <code>app.*</code></li><li><code>LibraryPlugin</code> –&gt; <code>lib.*</code></li><li><code>HostPlugin</code> –&gt; <code>app</code></li><li><code>AssetPlugin</code> –&gt; <code>其他</code> </li></ol><p>在处理模块依赖上，首先区分gradle的两种依赖方式:</p><ol><li>Compile: compile是对所有的build type以及flavors都会参与编译并且打包到最终的apk文件中。</li><li>Provided: Provided是对所有的build type以及flavors只在编译时使用，只参与编译，不打包到最终apk。</li></ol><p>在打包<code>app.*</code>插件时，将<code>app.*</code>对其他module的依赖转换成<code>provided</code>依赖。当执行插件打包时可以看做是插件模块执行<code>assembleRelease</code>。</p><p>在打包<code>lib.*</code>插件时，<code>LibraryPlugin</code>会修改插件模块的<code>build.gradle</code>文件，<code>apply plugin:</code>从<code>&#39;com.android.library&#39;</code>修改成<code>&#39;com.android.application&#39;</code>，将对lib的方式转换成app的打包，再执行<code>assembleRelease</code>任务。</p><h4 id="0x02-Small如何解决资源id冲突"><a href="#0x02-Small如何解决资源id冲突" class="headerlink" title="0x02 Small如何解决资源id冲突?"></a>0x02 Small如何解决资源id冲突?</h4><p>Android App资源id的格式是0xPPTTNNNN，其中：</p><ul><li>PP 资源的package id</li><li>TT 资源类型的id，类型是attr、layout、string等等</li><li>NNNN 资源的entry id</li></ul><p>Android App资源的默认packageId是0x7f，当同时加载多个插件apk时。必然会有插件间资源id冲突的情况。业界解决资源id冲突主要通过package id的分段，实现方式一般有两种方式，第一种方式是修改aapt工具源码，让aapt针对插件打包时每个插件的packageId都不相同，重新编译出aapt，而达到解决资源id冲突的问题。small框架使用的是另外一种方式，那就是读取并重写resources.arsc文件。大致的处理流程如下（出自small原作者在github issues的回答）：</p><ol><li>编译完整的资源包，利用symbol/R.txt搜集完整包entries的资源信息</li><li>搜集当前插件包res目录的entry信息</li><li>根据(2)，通过重新排序分配各个entry的资源id，并结合(1),形成旧id到新id的映射</li><li>解析(1)生成的resources.arsc文件，利用(3)进行过滤输出</li></ol><h4 id="0x03-Small如何加载插件代码？"><a href="#0x03-Small如何加载插件代码？" class="headerlink" title="0x03 Small如何加载插件代码？"></a>0x03 Small如何加载插件代码？</h4><p>Small的加载插件代码的方式基于android dex分包方案的，简单的说small通过将多个dex文件塞入到app的classloader中，达到加载插件代码的目的。Small并不会更换系统的classloader，所以这样在面对多种不同机型时可能就不会遇到的兼容性问题。</p><p>怎样把多个dex文件塞入系统classloader中，可以看下<a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=0" target="_blank" rel="noopener">QQ空间的热修复方案</a></p><h4 id="0x04-Small如何加载插件资源"><a href="#0x04-Small如何加载插件资源" class="headerlink" title="0x04 Small如何加载插件资源?"></a>0x04 Small如何加载插件资源?</h4><p>Android资源是由 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/content/res/AssetManager.java" target="_blank" rel="noopener">AssetManager</a> 加载的。应用启动时系统创建一个AssetManager实例，并通过<code>addAssetPath</code>方法添加资源路径，默认添加:</p><ul><li>“/framework/base.apk” - Android base resources (base)</li><li>“/data/app/*.apk” - The launching apk resources (host)</li></ul><p>那么如何让插件的资源能够被系统加载？Small的方式是自己创建的AssetManager，调用AssetManger的<code>addAssetPath</code>方法添加插件资源路径，再将系统创建的AssetManager替换掉。</p><p>Hook AssetManager路径如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread</span><br><span class="line">|</span><br><span class="line">|---ResourcesManager mResourcesManager</span><br><span class="line">    |</span><br><span class="line">    |--- ArrayList&lt;WeakReference&lt;Resources&gt;&gt; mResourceReferences</span><br><span class="line">         |</span><br><span class="line">         |--- ResourcesImpl mResourcesImpl</span><br><span class="line">              |</span><br><span class="line">              |--- AssetManager mAssets</span><br><span class="line">         </span><br><span class="line">    |--- ArrayMap&lt;ResourcesKey, WeakReference&lt;ResourcesImpl&gt;&gt; mResourceImpls</span><br><span class="line">         |</span><br><span class="line">         |--- ResourcesImpl mResourcesImpl</span><br><span class="line">              |</span><br><span class="line">              |--- AssetManager mAssets</span><br></pre></td></tr></table></figure><h4 id="0x05-Small如何代理插件Activity的生命周期"><a href="#0x05-Small如何代理插件Activity的生命周期" class="headerlink" title="0x05 Small如何代理插件Activity的生命周期?"></a>0x05 Small如何代理插件Activity的生命周期?</h4><p>先看Andriod中Activity是如何启动的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyActivity.startActivity()</span><br><span class="line">|</span><br><span class="line">|--&gt;Activity.startActivity() </span><br><span class="line">    |</span><br><span class="line">    |--&gt;Activity.startActivityForResult()</span><br><span class="line">        |</span><br><span class="line">        |--&gt;Instrumentation.execStartActivty()</span><br><span class="line">            |</span><br><span class="line">            |--&gt;ActivityManagerNative.getDefault().startActivityAsUser()</span><br></pre></td></tr></table></figure><p>通过 Activity 的启动流程可以发现，Activity是由 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/ActivityThread.java" target="_blank" rel="noopener">ActivityThread</a> 和 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/Instrumentation.java" target="_blank" rel="noopener">Instrumentation</a> 启动的，Instrumentation有关Activity启动相关的方法大概有：execStartActivity、newActivity等等。Small是这样操作的: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MyActivity.startActivity()</span><br><span class="line">|</span><br><span class="line">|--&gt;Activity.startActivity() </span><br><span class="line">    |</span><br><span class="line">    |--&gt;Activity.startActivityForResult()</span><br><span class="line">        |</span><br><span class="line">        |--&gt;InstrumentationWrapper.execStartActivty()</span><br><span class="line">            |</span><br><span class="line">            |--&gt; InstrumentationWrapper.wrapIntent() 将 Intent &#123; cmp=net.wequick.example.small/.app.main.MainActivity &#125;</span><br><span class="line">            |--&gt; 转换成 Intent &#123; cat=[&gt;net.wequick.example.small.app.main.MainActivity] cmp=net.wequick.example.small/net.wequick.small.A &#125;</span><br><span class="line">                |</span><br><span class="line">                |--&gt;Instrumentation.execStartActivty()</span><br><span class="line">                    |</span><br><span class="line">                    |--&gt;ActivityManagerNative.getDefault().startActivityAsUser()</span><br></pre></td></tr></table></figure><p>Small首先在宿主manifest中注册一个命名特殊的占坑activity来欺骗系统获取生命周期，在封装一个Instrumentation替换掉宿主的，系统启动的是A这个activity，但classloader实际加载的代码却是 MainActivity.class 这个类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Stub Activities --&gt;</span><br><span class="line">&lt;activity android:name=&quot;.A&quot; android:launchMode=&quot;standard&quot;/&gt;</span><br></pre></td></tr></table></figure><p>伪代码如下: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread thread = currentActivityThread();</span><br><span class="line">Instrumentation base = thread.@mInstrumentation;</span><br><span class="line">Instrumentation wrapper = new InstrumentationWrapper(base);</span><br><span class="line">thread.@mInstrumentation = wrapper;</span><br><span class="line"></span><br><span class="line">class InstrumentationWrapper extends Instrumentation &#123;</span><br><span class="line">    public ActivityResult execStartActivity(..., Intent intent, ...) &#123;</span><br><span class="line">        fakeToStub(intent);</span><br><span class="line">        base.execStartActivity(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Activity newActivity(ClassLoader cl, String className, Intent intent) &#123;</span><br><span class="line">        className = restoreToReal(intent, className);</span><br><span class="line">        return base.newActivity(cl, className, intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x06-Small如何动态更新插件模块"><a href="#0x06-Small如何动态更新插件模块" class="headerlink" title="0x06 Small如何动态更新插件模块?"></a>0x06 Small如何动态更新插件模块?</h4><p><a href="https://github.com/wequick/Small/blob/master/Android/Sample/app.home/src/main/java/net/wequick/example/small/app/home/MainFragment.java" target="_blank" rel="noopener">查看github sample实现方式</a></p><h4 id="0x07-参考文档"><a href="#0x07-参考文档" class="headerlink" title="0x07 参考文档"></a>0x07 参考文档</h4><p><a href="https://github.com/wequick/Small/wiki" target="_blank" rel="noopener">Small 官方 wiki</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=0" target="_blank" rel="noopener">QQ空间热补丁动态修复技术介绍</a></p><h3 id="转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="转载请标明出处病已blog https://ivonhoe.github.io/"></a>转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;Small是一个轻量化的插件化框架，Small的使用介绍可以查看&lt;a href=&quot;http://code.wequick.net/Small/cn/quickstart&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网文档&lt;/a&gt;了解，Small项目接入总结可以查看博客的另一篇&lt;a href=&quot;https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/&quot;&gt;《Small框架实践总结》&lt;/a&gt;。这篇文章主要从以下几个角度来看Small框架的实现原理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Small如何实现插件代码打包和资源打包&lt;/li&gt;
&lt;li&gt;Small加载插件代码和资源的原理&lt;/li&gt;
&lt;li&gt;Small代理插件activity生命周期的原理&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;关于Small插件化的其他文档：&quot;&gt;&lt;a href=&quot;#关于Small插件化的其他文档：&quot; class=&quot;headerlink&quot; title=&quot;关于Small插件化的其他文档：&quot;&gt;&lt;/a&gt;关于Small插件化的其他文档：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/&quot;&gt;&lt;strong&gt;《Android插件化之Small框架实践总结》&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://ivonhoe.github.io/2018/03/14/small-bug-555-fix/&quot;&gt;&lt;strong&gt;《Android插件化之资源加载机制》&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://ivonhoe.github.io/2018/07/18/abandon-the-plugin-framework/&quot;&gt;&lt;strong&gt;《Android插件化之从入门到放弃》&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android插件化" scheme="https://ivonhoe.github.io/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="插件化" scheme="https://ivonhoe.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化之Small框架实践总结</title>
    <link href="https://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://ivonhoe.github.io/2018/01/18/Small框架实践总结/</id>
    <published>2018-01-18T09:42:57.000Z</published>
    <updated>2018-09-18T09:50:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>这篇文章主要总结了在使用Small框架改造老项目过程中遇到的问题和相应的解决方案，也总结了使用Small框架的基础知识点，并从一个使用者的角度来分析Small框架的优缺点。如果你的项目也面临业务模块耦合，边界不清晰，没有动态部署方案等等需要插件化方案来解决的问题，不妨先看下这篇文章再试一试Small框架，Small的功能未必全面但绝对聚焦了插件化框架需要解决的的核心问题。</p><p>什么是Small框架？ Small是一个轻量级的插件化框架，Small也是一个dex分包方案，Small也是一个业务模块解耦方案，同时Small也是一个动态化加载和更新方案。先去看官网文档了解Small的基础知识~~</p><p><a href="http://code.wequick.net/Small/cn/quickstart" target="_blank" rel="noopener">Small官网文档</a></p><h3 id="关于Small插件化的其他文档："><a href="#关于Small插件化的其他文档：" class="headerlink" title="关于Small插件化的其他文档："></a>关于Small插件化的其他文档：</h3><p><a href="http://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"><strong>《Android插件化之Small框架原理》</strong></a><br><a href="http://ivonhoe.github.io/2018/03/14/small-bug-555-fix/"><strong>《Android插件化之资源加载机制》</strong></a><br><a href="https://ivonhoe.github.io/2018/07/18/abandon-the-plugin-framework/"><strong>《Android插件化之从入门到放弃》</strong></a></p><a id="more"></a><h4 id="0x01-Small必知必会"><a href="#0x01-Small必知必会" class="headerlink" title="0x01 Small必知必会"></a>0x01 Small必知必会</h4><p><img src="/res/small/small-1.png" alt="Small角色关系"></p><ol><li>Small框架将工程模块分为这几个角色，宿主，宿主分身，app插件，公共lib插件</li><li>宿主不依赖任何模块，宿主分身被所有app和lib依赖，但是宿主和宿主分身都被打包在主应用的主dex中，app插件和公共lib插件被单独打包在自己的插件so中</li><li>Small如何编译? <ul><li>./gradlew cleanLib </li><li><strong>编译公共库:</strong> ./gradlew buildLib </li><li>./gradlew cleanBundle</li><li><strong>编译app插件:</strong> ./gradle buildBundle </li><li><strong>编译宿主app:</strong> ./gradle :app:assembleDaily  <strong>注意：</strong>这里不是assembleDaily 而是:app:assembleDaily</li></ul></li><li>app插件的模块名称必须是app.<em> , 公共库lib插件的模块名称必须是lib.</em>。</li><li>在宿主app assets目录的bundle.json文件中声明每个插件的包名、类型和页面路由等信息。当app插件的包名为 <code>**.app.*</code> 或 <code>**.app*</code>时, small框架会默认该插件模块为app插件。</li><li>app插件和app插件之间无法相互依赖，app插件之间可以通过路由uri传参，或者LocalBroadcast、Eventbus等消息机制实现通信。</li><li><p>Small中插件的packageId是自动根据模块名称hash计算生成，有可能会遇到插件模块packageId冲突的情况，在这种情况下需要在发生冲突模块的build.gradle重新声明packageId, 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">  packageId = 0x33</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成插件到 x86 架构下./gradlew buildLib -q -Dbundle.arch=x86，<strong>需要注意</strong> 宿主的ndk abiFilters 要和<code>bundle.arch</code>一致哦。</p></li><li>如何启动其他插件模块的页面？通过<code>Small.openUri()</code>方法打开页面的路由地址。</li><li>动态更新插件时，需要升级插件的versionCode才会生效</li><li>非Activity组件需要声明在宿主或者宿主分身的manifest中</li></ol><h4 id="0x02-Small框架的优缺点"><a href="#0x02-Small框架的优缺点" class="headerlink" title="0x02 Small框架的优缺点"></a>0x02 Small框架的优缺点</h4><p><strong>选择small框架的原因：</strong></p><ol><li>集成简单</li><li>开发方式非常接近Android app的原生开发方式</li><li>不需要更换编译工具，已有项目中针对业务需求开发的编译工具依然可以继续使用</li><li>优雅，特别是对资源id冲突的处理方式</li><li>轻量化，尽可能少的hook系统变量，兼容性问题较少</li></ol><p><strong>不选择small框架的原因：</strong></p><ol><li>插件的加载并不是按需加载</li><li>插件的更新实现较简单，且没有回滚方案</li><li>有些隐藏bug还未解决，但可以绕过</li><li>功能相对其他插件化框架(比如atlas)来说还不够完善，但足够解决项目插件化目标中遇到的80%问题</li></ol><h4 id="0x03-Small插件化实践踩过的那些坑"><a href="#0x03-Small插件化实践踩过的那些坑" class="headerlink" title="0x03 Small插件化实践踩过的那些坑"></a>0x03 Small插件化实践踩过的那些坑</h4><p>遇到问题怎么办？到github issues里查询你遇到的问题，一般都可以找到答案。这里大致总结了我们团队在small框架使用过程中遇到的常见问题。</p><ol><li>lib插件中增加或减少资源时，需要删除模块目录下public.xml再重新编译。public.xml是为了锁定lib中资源id</li><li>增加或修改插件中ndk module覆盖安装不生效，需要将native module编译生成的so文件放在宿主中才能实现更新</li><li>遇到ClassNotFoundException异常或者无法启动某些activity companentInfo，排查问题的方法:<ul><li>查看Fatal Runtime Exception日志，查看日志中已经加载的so是否包含你的插件so</li><li>如果插件so被加载，再确定相应代码已经被编译进插件so中，查看方法很简单，将插件so重命名为apk直接在Android Studio中打开 </li><li>确认是否将插件so正确声明在bundle.json文件中</li><li>确认该异常类继承的父类或者接口满足上述几个条件</li></ul></li><li>Class ref in pre-verified class resolved to unexpected implementation ，使用gradle smallLint命令查看是否有class重复了 <a href="https://github.com/wequick/Small/issues/423" target="_blank" rel="noopener">https://github.com/wequick/Small/issues/423</a></li><li>Activity launch mode为singletop时在activity style中设置透明背景无效 <a href="https://github.com/wequick/Small/issues/94" target="_blank" rel="noopener">https://github.com/wequick/Small/issues/94</a></li><li>无法通过Small.openUri()方法启动页面怎么办？一定是你用法不对，debug找原因。</li></ol><h4 id="0x04-Small插件化规范"><a href="#0x04-Small插件化规范" class="headerlink" title="0x04 Small插件化规范"></a>0x04 Small插件化规范</h4><ol><li>不要在宿主中添加业务代码</li><li>native module so放在宿主中, 原因关注Github issue: <a href="https://github.com/wequick/Small/issues/560" target="_blank" rel="noopener">增加或修改插件中ndk module覆盖安装不生效 </a></li><li>不同插件模块中依赖相同第三方aar或jar的版本号要相同，建议将aar或jar的版本号统一声明在gradle.properties中，将共同依赖的第三方sdk声明在宿主分身中</li><li>所有Theme的定义都放在宿主和宿主分身中，具体原因看我的另一篇问题总结：<a href="https://ivonhoe.github.io/2018/03/14/small-bug-555-fix/">Android插件化之资源加载</a></li></ol><p><strong>Small插件化项目的完全体</strong></p><p><img src="/res/small/small-2.png" alt="Small插件化完全体"></p><h4 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h4><p>Small官网文档 <a href="http://code.wequick.net/Small/cn/quickstart" target="_blank" rel="noopener">http://code.wequick.net/Small/cn/quickstart</a></p><p>Small github主页 <a href="https://github.com/wequick/Small" target="_blank" rel="noopener">https://github.com/wequick/Small</a></p><p><a href="http://code.wequick.net/small/docs/ppt/gmtc-galen-small.ppsx" target="_blank" rel="noopener">GMTC演讲PPT</a></p><h3 id="转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="转载请标明出处病已blog https://ivonhoe.github.io/"></a>转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;这篇文章主要总结了在使用Small框架改造老项目过程中遇到的问题和相应的解决方案，也总结了使用Small框架的基础知识点，并从一个使用者的角度来分析Small框架的优缺点。如果你的项目也面临业务模块耦合，边界不清晰，没有动态部署方案等等需要插件化方案来解决的问题，不妨先看下这篇文章再试一试Small框架，Small的功能未必全面但绝对聚焦了插件化框架需要解决的的核心问题。&lt;/p&gt;
&lt;p&gt;什么是Small框架？ Small是一个轻量级的插件化框架，Small也是一个dex分包方案，Small也是一个业务模块解耦方案，同时Small也是一个动态化加载和更新方案。先去看官网文档了解Small的基础知识~~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://code.wequick.net/Small/cn/quickstart&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Small官网文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于Small插件化的其他文档：&quot;&gt;&lt;a href=&quot;#关于Small插件化的其他文档：&quot; class=&quot;headerlink&quot; title=&quot;关于Small插件化的其他文档：&quot;&gt;&lt;/a&gt;关于Small插件化的其他文档：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://ivonhoe.github.io/2018/01/18/Small%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/&quot;&gt;&lt;strong&gt;《Android插件化之Small框架原理》&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://ivonhoe.github.io/2018/03/14/small-bug-555-fix/&quot;&gt;&lt;strong&gt;《Android插件化之资源加载机制》&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://ivonhoe.github.io/2018/07/18/abandon-the-plugin-framework/&quot;&gt;&lt;strong&gt;《Android插件化之从入门到放弃》&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android插件化" scheme="https://ivonhoe.github.io/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="插件化" scheme="https://ivonhoe.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android安全之某团请求加密破解</title>
    <link href="https://ivonhoe.github.io/2017/06/18/android-app-gold-flow-hack/"/>
    <id>https://ivonhoe.github.io/2017/06/18/android-app-gold-flow-hack/</id>
    <published>2017-06-18T10:13:19.000Z</published>
    <updated>2018-09-11T13:26:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>本文记录了破解某外卖App http请求参数加密过程中遇到的问题和解决思路，实现的目标是希望是能够通过一些手段实现自由调用其服务接口。<br>这篇文章主要讲述什么？</p><ol><li>静态分析和动态调试的基本方法和遇到的问题</li><li>如何听过修改android源码实现全局hook</li></ol><p><img src="/res/meituan_hack/meituan-1.png" alt="想要破解的网络请求"></p><a id="more"></a><p>可以看到每次请求都会自动生成相应的请求参数，并计算出一个加密后的参数<code>__skcy</code>，服务端根据这些参数信息和请求内容做校验，校验通过服务端才会返回正确的结果。通过抓包和反编译后的代码大致梳理了上图请求参数的含义和生成方法，具体参数如下所示:</p><ul><li><strong>__skck:</strong>Java层面<strong>常量</strong>，6a375bce8c66a0dc293860dfa83833ef</li><li><strong>__skts:</strong>系统时间值，通过Sytem.currentTime()获取，例如：1487054997740</li><li><strong>__skua:</strong>通过UserAgent方法，获取ua，并计算出md5，通过动态调试发现该UserAgent方法返回为空，所以该值也为<strong>常量</strong>，d41d8cd98f00b204e9800998ecf8427e</li><li><strong>__skno:</strong>通过Java randomUUID获取随机数，例如：eccb0210-c86f-43bb-b12d-04927547b9ea</li><li><strong>__skcy:</strong>以上四个参数加上PostContent，调用native方法获取加密后得到该值</li></ul><!-- more --><h3 id="0x01-尝试静态分析"><a href="#0x01-尝试静态分析" class="headerlink" title="0x01 尝试静态分析"></a>0x01 尝试静态分析</h3><p>首先使用常用的静态分析工具，如apkTools、dex2jar做apk的反编译和转Jar。虽然该App安装包没有加壳，但在反编译过程中依然遇到一些问题。</p><h4 id="1-1、遇到问题"><a href="#1-1、遇到问题" class="headerlink" title="1.1、遇到问题"></a>1.1、遇到问题</h4><p>该App针对dex2jar工具做了防范. 原理分析请看<a href="https://ivonhoe.github.io/2017/02/09/%E7%BE%8E%E5%9B%A2%E5%A6%82%E4%BD%95%E9%98%B2dex2jar/">Android安全之应用防dex2jar原理及实现</a></p><h4 id="1-2、解决方案"><a href="#1-2、解决方案" class="headerlink" title="1.2、解决方案"></a>1.2、解决方案</h4><ul><li>将插入的Exist代码删除，再做smali–&gt;dex–&gt;jar处理。</li><li>或者，直接阅读smali代码。</li></ul><h4 id="1-3、分析结果"><a href="#1-3、分析结果" class="headerlink" title="1.3、分析结果"></a>1.3、分析结果</h4><ul><li>该App在java层处理Http请求的核心类是<code>CandyPreProcessor.java</code></li><li>该App调用加密so的JNI类是 <code>CandyJni.java</code></li><li>该App执行参数加密的so是<code>libmtguard.so</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CandyJni</span><br><span class="line">&#123;</span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    System.loadLibrary(&quot;mtguard&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static native String getCandyDataWithKey(Object paramObject, byte[] paramArrayOfByte, String paramString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x02-尝试动态调试smali"><a href="#0x02-尝试动态调试smali" class="headerlink" title="0x02 尝试动态调试smali"></a>0x02 尝试动态调试smali</h3><p>这里先使用了源apk包在root手机上进行调试，但没有成功。只能尝试重打包调试。</p><h4 id="2-1、如何使用AS动态调试"><a href="#2-1、如何使用AS动态调试" class="headerlink" title="2.1、如何使用AS动态调试"></a>2.1、如何使用AS动态调试</h4><p>参考<a href="http://www.52pojie.cn/thread-502219-1-1.html" target="_blank" rel="noopener">吾爱破解</a>这篇文章，需要下载AS baksmali插件，需要注意的是：</p><ul><li>AS remote debug端口号设置为8700</li><li>AS没有识别安卓代码情况下工具栏没有Android Device monitor的按钮，这时候通过monitor命令启动monitor</li><li>如果monitor启动时提示8700端口已经被占用，可以通过 <code>lsof -n -i4TCP:8700 | grep LISTEN</code> 命令查看8700端口目前对应的进程名</li><li>attach前一定要先在monitor里选中想要调试的进程，再debug</li></ul><h4 id="2-2、重写Java代码，直接调用加密so"><a href="#2-2、重写Java代码，直接调用加密so" class="headerlink" title="2.2、重写Java代码，直接调用加密so"></a>2.2、重写Java代码，直接调用加密so</h4><p>动态调试可以比较清楚的看到Java层的内部调用逻辑，通过debug watch功能可以清楚的看到寄存器值，结合反编译和静态分析可以知道调用native方法的入参格式。</p><p>现在的思路是解压出源apk包中的so文件，编写java代码直接调用so文件中的native方法获取计算__skcy参数。但测试的结果是一直返回<code>null</code>。这里猜测在native层中对运行环境做了监测，所以一直返回空值。</p><p>这里该app的参数签名详细过程是，通过<code>__skck、__skts、__skno、__skua(详细规则见上)</code>，调用<code>CandyPreprocessor.java</code>的<code>getParametersSignature()</code>方法获取<code>__skcy</code>参数。Java层核心方法<code>getParametersSignature()</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param paramBuilder https://eapi.*****/api/poi/logon/acctdevice?__skck=6a375bce8c66a0dc293860dfa83833ef&amp;__skts=1486970558719&amp;__skua=d41d8cd98f00b204e9800998ecf8427e&amp;__skno=5ed4629c-098c-489c-b598-81841e0479e0</span><br><span class="line"> */</span><br><span class="line">String getParametersSignature(Uri.Builder paramBuilder, Context paramContext) &#123;</span><br><span class="line">    if (paramBuilder == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;CandyPreprocessor getParametersSignature builder is null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取网络接口名称 https://eapi.waimai.meituan.com/api/poi/logon/acctdevice</span><br><span class="line">    Object localObject = baseString();</span><br><span class="line">    if (TextUtils.isEmpty((CharSequence) localObject)) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;CandyPreprocessor getParametersSignature normalizedURI is null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList localArrayList = new ArrayList();</span><br><span class="line">    /**</span><br><span class="line">     * 0 = &#123;CandyPreprocessor$MyEntry@5016&#125; &quot;__skck&quot; -&gt; &quot;6a375bce8c66a0dc293860dfa83833ef&quot;</span><br><span class="line">     1 = &#123;CandyPreprocessor$MyEntry@5017&#125; &quot;__skts&quot; -&gt; &quot;1486970558719&quot;</span><br><span class="line">     2 = &#123;CandyPreprocessor$MyEntry@5018&#125; &quot;__skua&quot; -&gt; &quot;d41d8cd98f00b204e9800998ecf8427e&quot;</span><br><span class="line">     3 = &#123;CandyPreprocessor$MyEntry@5019&#125; &quot;__skno&quot; -&gt; &quot;5ed4629c-098c-489c-b598-81841e0479e0&quot;</span><br><span class="line">     */</span><br><span class="line">    // 获取参数key和参数value放到数组中</span><br><span class="line">    appendList(localArrayList, paramBuilder, false);</span><br><span class="line">    // add &quot;__sksc&quot; -&gt; &quot;https&quot;</span><br><span class="line">    // 获取scheme放入数组中</span><br><span class="line">    localArrayList.add(new CandyPreprocessor.MyEntry(&quot;__sksc&quot;, this.candyOriginalMaterial.getScheme()));</span><br><span class="line">    // 将post content放入数组中</span><br><span class="line">    if (formURLEncoded()) &#123;</span><br><span class="line">        // /?dVersion=23_6.0&amp;utm_medium=android&amp;password=2222&amp;utm_content=867689027084732&amp;appCode=388&amp;acctId=&amp;wmPoiId=&amp;token=&amp;uuid=03EB35F2C93419DC64AFFBC9EF6BB6BADE4DD72DC1E2F4733198E91C91AEAF93&amp;logType=C&amp;appName=%E7%BE%8E%E5%9B%A2%E5%A4%96%E5%8D%96%E5%95%86%E5%AE%B6%E7%89%88&amp;appType=4&amp;dType=PLK-TL01H&amp;userName=1111&amp;utm_term=4.2.0.388&amp;utm_source=&amp;utm_campaign=&amp;wm_appversion=4.2.0.388&amp;</span><br><span class="line">        // post 的内容入参</span><br><span class="line">        /**</span><br><span class="line">         * 5 = &#123;CandyPreprocessor$MyEntry@5071&#125; &quot;dVersion&quot; -&gt; &quot;23_6.0&quot;</span><br><span class="line">         6 = &#123;CandyPreprocessor$MyEntry@5072&#125; &quot;utm_medium&quot; -&gt; &quot;android&quot;</span><br><span class="line">         7 = &#123;CandyPreprocessor$MyEntry@5073&#125; &quot;password&quot; -&gt; &quot;123&quot;</span><br><span class="line">         8 = &#123;CandyPreprocessor$MyEntry@5074&#125; &quot;utm_content&quot; -&gt; &quot;867689027084732&quot;</span><br><span class="line">         9 = &#123;CandyPreprocessor$MyEntry@5075&#125; &quot;appCode&quot; -&gt; &quot;388&quot;</span><br><span class="line">         10 = &#123;CandyPreprocessor$MyEntry@5076&#125; &quot;acctId&quot; -&gt;</span><br><span class="line">         11 = &#123;CandyPreprocessor$MyEntry@5077&#125; &quot;wmPoiId&quot; -&gt;</span><br><span class="line">         12 = &#123;CandyPreprocessor$MyEntry@5078&#125; &quot;token&quot; -&gt;</span><br><span class="line">         13 = &#123;CandyPreprocessor$MyEntry@5079&#125; &quot;uuid&quot; -&gt; &quot;03EB35F2C93419DC64AFFBC9EF6BB6BADE4DD72DC1E2F4733198E91C91AEAF93&quot;</span><br><span class="line">         14 = &#123;CandyPreprocessor$MyEntry@5080&#125; &quot;logType&quot; -&gt; &quot;C&quot;</span><br><span class="line">         15 = &#123;CandyPreprocessor$MyEntry@5081&#125; &quot;appName&quot; -&gt; &quot;****&quot;</span><br><span class="line">         16 = &#123;CandyPreprocessor$MyEntry@5082&#125; &quot;appType&quot; -&gt; &quot;4&quot;</span><br><span class="line">         17 = &#123;CandyPreprocessor$MyEntry@5083&#125; &quot;dType&quot; -&gt; &quot;PLK-TL01H&quot;</span><br><span class="line">         18 = &#123;CandyPreprocessor$MyEntry@5084&#125; &quot;userName&quot; -&gt; &quot;***&quot;</span><br><span class="line">         19 = &#123;CandyPreprocessor$MyEntry@5085&#125; &quot;utm_term&quot; -&gt; &quot;4.2.0.388&quot;</span><br><span class="line">         20 = &#123;CandyPreprocessor$MyEntry@5086&#125; &quot;utm_source&quot; -&gt;</span><br><span class="line">         21 = &#123;CandyPreprocessor$MyEntry@5087&#125; &quot;utm_campaign&quot; -&gt;</span><br><span class="line">         22 = &#123;CandyPreprocessor$MyEntry@5088&#125; &quot;wm_appversion&quot; -&gt; &quot;4.2.0.388&quot;</span><br><span class="line">         */</span><br><span class="line">        appendList(localArrayList, Uri.parse(&quot;/?&quot; + new String(this.candyOriginalMaterial.getPostContent())).buildUpon(), true);</span><br><span class="line">    &#125;</span><br><span class="line">    // 特殊字符转码</span><br><span class="line">    List percentParamList = getPercentList(localArrayList);</span><br><span class="line">    // 分别对Value和Key做升序排列</span><br><span class="line">    dictionarySort(percentParamList);</span><br><span class="line">    // 将排序后的数组，拼接成字符串__skck=6a375bce8c66a0dc293860dfa83833ef&amp;__skno=5ed4629c-098c-489c-b598-81841e0479e0&amp;__sksc=https&amp;__skts=1486970558719&amp;__skua=d41d8cd98f00b204e9800998ecf8427e&amp;acctId=&amp;appCode=388&amp;appName=%E7%BE%8E%E5%9B%A2%E5%A4%96%E5%8D%96%E5%95%86%E5%AE%B6%E7%89%88&amp;appType=4&amp;dType=PLK-TL01H&amp;dVersion=23_6.0&amp;logType=C&amp;password=2222&amp;token=&amp;userName=1111&amp;utm_campaign=&amp;utm_content=867689027084732&amp;utm_medium=android&amp;utm_source=&amp;utm_term=4.2.0.388&amp;uuid=03EB35F2C93419DC64AFFBC9EF6BB6BADE4DD72DC1E2F4733198E91C91AEAF93&amp;wmPoiId=&amp;wm_appversion=4.2.0.388</span><br><span class="line">    String paramBuilderString = getNormalizedParameters(percentParamList);</span><br><span class="line">    // POST+空格+&quot;接口名称&quot;+空格+&quot;参数内容&quot;</span><br><span class="line">    // POST http://eapi.waimai.meituan.com/api/poi/logon/acctdevice __skck=6a375bce8c66a0dc293860dfa83833ef&amp;__skno=57749130-26d4-4239-8abd-b99c16584908&amp;__sksc=http&amp;__skts=1486995346041&amp;__skua=d41d8cd98f00b204e9800998ecf8427e&amp;acctId=&amp;appCode=388&amp;appName=%E7%BE%8E%E5%9B%A2%E5%A4%96%E5%8D%96%E5%95%86%E5%AE%B6%E7%89%88&amp;appType=4&amp;dType=PLK-TL01H&amp;dVersion=23_6.0&amp;logType=C&amp;password=2222&amp;token=&amp;userName=1111&amp;utm_campaign=&amp;utm_content=867689027084732&amp;utm_medium=android&amp;utm_source=&amp;utm_term=4.2.0.388&amp;uuid=03EB35F2C93419DC64AFFBC9EF6BB6BADE4DD72DC1E2F4733198E91C91AEAF93&amp;wmPoiId=&amp;wm_appversion=4.2.0.388</span><br><span class="line">    paramBuilderString = this.candyOriginalMaterial.getHttpMethod() + &quot; &quot; + (String) localObject + &quot; &quot; + paramBuilderString;</span><br><span class="line">    // JV1EOT1VZGN8USskB3jZYnVGyyQ=</span><br><span class="line">    // 调用jni获取加密后的参数值__skcy</span><br><span class="line">    localObject = CandyJni.getCandyDataWithKey(paramContext, paramBuilderString.getBytes(), &quot;candyKey&quot;);</span><br><span class="line"></span><br><span class="line">    // TODO for test</span><br><span class="line">    return (String) localObject;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="2-3、修改app代码，重打包调用so"><a href="#2-3、修改app代码，重打包调用so" class="headerlink" title="2.3、修改app代码，重打包调用so"></a>2.3、修改app代码，重打包调用so</h4><p>直接调用so的方法失败了，现在尝试反编译APK后，加入包含自己逻辑的smali代码，调用CandyJni的目的。具体的步骤是：</p><ul><li>利用上2.2的项目，拷贝和该App CandyJni完全相同的类名，方法名。</li><li>编写CandyHackActivity.Java和CandyHack.java，去调用新项目中的CandyJni，并打包。</li><li>apktools反编译新项目包，获取CandyHack.smali 和CandyHackActivity.smali。</li><li>修改反编译后项目的AndroidManifest.xml文件，将CandyHackActivity注册到manifest中进去。</li><li>重打包，签名，安装。</li><li>通过adb命令启动CandyHackActivity。</li></ul><p><img src="/res/meituan_hack/meituan_smali1.png" alt></p><p>结果一点不意外，能够成功调用CandyJni中的方法并且有返回值，但是经过测试在相同入参的情况下，和源APK包的加密结果不一致。问题应该出在签名。猜测应该是so中的方法将应用签名作为了一个加密参数。虽然能正常调用，但结果是错的~~</p><h4 id="2-4、尝试IDA-pro反编译so"><a href="#2-4、尝试IDA-pro反编译so" class="headerlink" title="2.4、尝试IDA pro反编译so"></a>2.4、尝试IDA pro反编译so</h4><p>一句话，IDA反编译后发现，在function窗口中找不到getCandyDataWithKey或者getCandyData这些在Java层声明的native方法。应该是使用了动态注册的方式注册了native方法，又一次把代码阅读门槛从C升级到了汇编，泪目~~~</p><p><img src="/res/meituan_hack/meituan_ida.jpeg" alt="native方法混淆"></p><h4 id="2-5、总结问题"><a href="#2-5、总结问题" class="headerlink" title="2.5、总结问题"></a>2.5、总结问题</h4><ul><li>想要在root机器上动态调试dex，但不进行重打包，就需要绕过他的反调试手段。反调试手段是什么？怎么绕过？我不知道</li><li>想要通过重打包动态调试dex，重打包必须重新签名，重新签名会导致加密算法计算结果出错。</li><li>想要反编译so，需要阅读加密后的C语言和汇编语言。汗！我是菜鸟汇编阅读不来</li></ul><h3 id="0x03-万金流破解思路"><a href="#0x03-万金流破解思路" class="headerlink" title="0x03 万金流破解思路"></a>0x03 万金流破解思路</h3><p>根据以上分析的过程，发现不管是重打包、借用so、静态分析、动态调试等基础的破解方式，该app都做了相应的防护措施，总的破解思路都是破坏了app原有环境。在一次逛安全论坛的过程中，看到通过修改Android原生代码加载特定so的思路，其实这种破解思路也适用于app的破解。如果在app启动时，让app进程的DexClassLoader能够加载你自己的代码，那么不管在任何的app运行环境中，诸如修改内存变量、调用方法或者是改变原有app系统的处理流程等目的都能够轻松达到。当然前提是运行在自己编译的Android源码或者是已经root的机器上。下面就以这个思路针对该外卖app做具体的破解实操，目标是在pc上能够自由调用该app服务端的http接口。</p><h4 id="3-1-下载并修改源码"><a href="#3-1-下载并修改源码" class="headerlink" title="3.1. 下载并修改源码"></a>3.1. 下载并修改源码</h4><p>如何下载编译源码这里不废话，没有尝试过的可以参考这篇<a href="http://ivonhoe.github.io/2017/01/20/MacOS%E4%B8%8A%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81/">《Mac OS上编译Android源码》</a>。<br>在<code>ActivityThread.java</code>的<code>handleBindApplication()</code>方法中增加dex注入的逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    // 省略源码...</span><br><span class="line">    </span><br><span class="line">    //=================全局注入之修改java层===================================================</span><br><span class="line">    checkFrameworkInject(data.processName);</span><br><span class="line">    //=============================================================================</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void checkFrameworkInject(String processName) &#123;</span><br><span class="line">    //=================全局注入之修改java层===================================================</span><br><span class="line">    Log.e(&quot;frameworkInjector&quot;, &quot;--processName=&quot; + processName);</span><br><span class="line">    invokeJarLoader(processName);</span><br><span class="line">    //=============================================================================</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从指定路径加载配置文件，配置信息包括要dex注入的进程名，dex路径，dex中main函数信息。<br>当相应的进程启动时，加载指定路径的dex，并运用其中的main函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 根据配置加载jar，执行指定类的main方法</span><br><span class="line">     */</span><br><span class="line">    public void invokeJarLoader(String processName) &#123;</span><br><span class="line">        List&lt;String&gt; config = readHookConfig(&quot;/data/local/jarHookConfig.txt&quot;);</span><br><span class="line"></span><br><span class="line">        if (config == null || config.size() &lt; 3) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String configProcessName = config.get(0);</span><br><span class="line">        String configJarPath = config.get(1);</span><br><span class="line">        String configClassName = config.get(2);</span><br><span class="line"></span><br><span class="line">        if (processName.equals(configProcessName) &amp;&amp; !TextUtils.isEmpty(configJarPath)</span><br><span class="line">                &amp;&amp; !TextUtils.isEmpty(configClassName)) &#123;</span><br><span class="line">            Log.e(&quot;frameworkInjector&quot;, &quot;targetPackage:&quot; + configProcessName +</span><br><span class="line">                    &quot;,start-load-jarPath&quot; + configJarPath + &quot;, class name:&quot; + configClassName);</span><br><span class="line">            jarInvokeTest(configJarPath, configClassName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void jarInvokeTest(String jarPath, String className) &#123;</span><br><span class="line">        final File optimizedDexOutputPath = new File(jarPath);</span><br><span class="line">        Context context = getApplication();</span><br><span class="line">        File dexOutputDir = context.getDir(&quot;dex&quot;, 0);</span><br><span class="line">        DexClassLoader cl = new DexClassLoader(</span><br><span class="line">                optimizedDexOutputPath.getAbsolutePath(),</span><br><span class="line">                dexOutputDir.getAbsolutePath(), null, context.getClassLoader());</span><br><span class="line">        Class libProviderClazz = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            libProviderClazz = cl.loadClass(className);</span><br><span class="line">            Method method = libProviderClazz.getMethod(&quot;main&quot;);</span><br><span class="line">            method.invoke(null, (Object[]) null);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-生成注入的dex"><a href="#3-2-生成注入的dex" class="headerlink" title="3.2 生成注入的dex"></a>3.2 生成注入的dex</h4><p>在这里具体的注入代码就不啰嗦了，总的来说你可以针对任何app中的任何方法变量任意操作。如果你想在pc上实现请求的自由收发要稍微复杂些，你需要实现一个简单的Hook socket server（简称HSS），将HSS打包成dex做注入，将参与参数加密的数据发送给HSS，HSS调用app中的加密方法获取加密结果，并将最终的加密结果发送出来就可以啦。具体的实现如下图所示:</p><p><img src="/res/meituan_hack/meituan_hook.png" alt="hook结构图"></p><h3 id="0x04-严重声明"><a href="#0x04-严重声明" class="headerlink" title="0x04 严重声明"></a>0x04 严重声明</h3><p><strong>本文的意图只有一个，就是通过分析app学习更多的逆向技术，如果有人利用本文知识和技术进行非法操作进行牟利，带来的任何法律责任都将由操作者本人承担，和本文作者无任何关系，最终还是希望大家能够秉着学习的心态阅读此文。</strong></p><h3 id="0x05-参考文档"><a href="#0x05-参考文档" class="headerlink" title="0x05 参考文档"></a>0x05 参考文档</h3><ul><li><a href="http://www.jianshu.com/p/730c6e3e21f6" target="_blank" rel="noopener">Smali语法</a></li><li><a href="http://blog.csdn.net/niexinming/article/details/54318634" target="_blank" rel="noopener">逆向加固的apk详细教程</a></li><li><a href="http://www.52pojie.cn/thread-564459-1-1.html" target="_blank" rel="noopener">修改源码实现全局(无需root)注入躲开注入检测</a></li><li><a href="http://www.jianshu.com/p/6438f161875a" target="_blank" rel="noopener">Android动态加载jar</a></li><li><a href="http://www.jianshu.com/p/61cfa1347894" target="_blank" rel="noopener">Java之jar打包</a></li></ul><h3 id="0x06-转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#0x06-转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="0x06 转载请标明出处病已blog https://ivonhoe.github.io/"></a>0x06 转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;本文记录了破解某外卖App http请求参数加密过程中遇到的问题和解决思路，实现的目标是希望是能够通过一些手段实现自由调用其服务接口。&lt;br&gt;这篇文章主要讲述什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态分析和动态调试的基本方法和遇到的问题&lt;/li&gt;
&lt;li&gt;如何听过修改android源码实现全局hook&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/res/meituan_hack/meituan-1.png&quot; alt=&quot;想要破解的网络请求&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android安全" scheme="https://ivonhoe.github.io/categories/Android%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="移动安全" scheme="https://ivonhoe.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>捕获线程池任务异常引发的血案</title>
    <link href="https://ivonhoe.github.io/2017/05/12/executor-eat-exception/"/>
    <id>https://ivonhoe.github.io/2017/05/12/executor-eat-exception/</id>
    <published>2017-05-12T08:41:53.000Z</published>
    <updated>2019-05-20T07:31:06.109Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>今天遇到一个很诡异的问题，在多款Android 4.2.2版本的手机上发现处理后台任务的服务对前台请求毫无响应。这里的后台服务是一个RemoteService，目的为了处理更新&amp;上传等任务。本来以为是跨进程组件间通讯出现兼容性问题，后来根据分析发现问题没有那么简单，这里记录下问题原因。</p><a id="more"></a><h3 id="二、第一个错误"><a href="#二、第一个错误" class="headerlink" title="二、第一个错误"></a>二、第一个错误</h3><p>在后台服务处理任务请求时,使用了自定义线程池处理异步任务，而Java 线程池java.util.concurrent.ThreadPoolExecutor会Catch住所有异常，即便是你运行例如下面的代码也不会抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Test test = null;</span><br><span class="line">        System.out.println(test.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mExecutor.submit(runnable);</span><br></pre></td></tr></table></figure><p>在处理线程池异常捕获的问题时，犯下了第一个错误，使用了submit方法拿到任务执行结果会阻塞当前线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    Future&lt;?&gt; future = mExecutor.submit(task);</span><br><span class="line">    try &#123;</span><br><span class="line">        future.get();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt(); // Reset interrupted status</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        Throwable exception = e.getCause();</span><br><span class="line">        // Forward to exception reporter</span><br><span class="line">        if (exception instanceof UncatchException) &#123;</span><br><span class="line">            throw (UncatchException) exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、第二个错误"><a href="#三、第二个错误" class="headerlink" title="三、第二个错误"></a>三、第二个错误</h3><p>在错误一的基础上，使用了一个开源并发库<a href="https://github.com/litesuits/android-lite-go" target="_blank" rel="noopener">android-lite-go</a>，先看它的异步任务是如何调度的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int coreSize = CPU_CORE;</span><br><span class="line">int queueSize = coreSize * 32;</span><br><span class="line"></span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">    if (runningList.size() &lt; coreSize) &#123;</span><br><span class="line">        runningList.add(scheduler);</span><br><span class="line">        threadPool.execute(scheduler);</span><br><span class="line">    &#125; else if (waitingList.size() &lt; queueSize) &#123;</span><br><span class="line">        waitingList.addLast(scheduler);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当正在运行的任务数小于设定的coreSize时，submit的任务会提交到线程池。</li><li>coreSize由系统核心数确定。</li><li>当正在运行的任务数小于queueSize时，submit的任务会提交到等待队列中。</li><li>当一个任务执行完后，会从等待队列中获取一个任务提交给线程池执行。</li></ul><p>在一个异步任务中使用阻塞当前线程的方法，把另一个任务提交给了executor。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void runTaskOne() &#123;</span><br><span class="line">    Runnable runnable = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // do something</span><br><span class="line">            runTaskTwo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mTaskController.submit(runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void runTaskTwo() &#123;</span><br><span class="line">    Runnable runnable = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // do task2</span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mTaskController.submit(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、问题原因及解决方案"><a href="#三、问题原因及解决方案" class="headerlink" title="三、问题原因及解决方案"></a>三、问题原因及解决方案</h3><p>当正在运行的任务使用阻塞当前进程的submit方法提交另一个异步任务时，后提交的任务被放入等待队列等待线程池执行，但在Running list中的任务又在等待后任务执行的结果，这样就造成了死锁！！这个问题跟Android系统版本并没有关系，但因为Android 4.2.2版本的手机低端较多核心数较少，所以runningList的大小就比较小，Running List很容易就被填满。</p><p><img src="/res/deadlock/deadlock.png" alt></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>使用非阻塞的方法提交异步任务</li><li>自定义线程池，重写<code>afterExecute()</code>方法，在该中获取线程池运行的异步任务运行时异常。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(11, 100, 1, TimeUnit.MINUTES, //</span><br><span class="line">        new ArrayBlockingQueue&lt;Runnable&gt;(10000),//</span><br><span class="line">        new DefaultThreadFactory()) &#123;</span><br><span class="line"></span><br><span class="line">    protected void afterExecute(Runnable r, Throwable t) &#123;</span><br><span class="line">        super.afterExecute(r, t);</span><br><span class="line">        printException(r, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private static void printException(Runnable r, Throwable t) &#123;</span><br><span class="line">    if (t == null &amp;&amp; r instanceof Future&lt;?&gt;) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Future&lt;?&gt; future = (Future&lt;?&gt;) r;</span><br><span class="line">            if (future.isDone())</span><br><span class="line">                future.get();</span><br><span class="line">        &#125; catch (CancellationException ce) &#123;</span><br><span class="line">            t = ce;</span><br><span class="line">        &#125; catch (ExecutionException ee) &#123;</span><br><span class="line">            t = ee.getCause();</span><br><span class="line">        &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">            Thread.currentThread().interrupt(); // ignore/reset</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (t != null)</span><br><span class="line">        log.error(t.getMessage(), t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、参考文档"><a href="#四、参考文档" class="headerlink" title="四、参考文档"></a>四、参考文档</h3><ol><li><a href="http://imxylz.com/blog/2013/08/02/handling-the-uncaught-exception-of-java-thread-pool/" target="_blank" rel="noopener">捕获Java线程池执行任务抛出的异常</a></li></ol><h3 id="转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="转载请标明出处病已blog https://ivonhoe.github.io/"></a>转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;今天遇到一个很诡异的问题，在多款Android 4.2.2版本的手机上发现处理后台任务的服务对前台请求毫无响应。这里的后台服务是一个RemoteService，目的为了处理更新&amp;amp;上传等任务。本来以为是跨进程组件间通讯出现兼容性问题，后来根据分析发现问题没有那么简单，这里记录下问题原因。&lt;/p&gt;
    
    </summary>
    
      <category term="Bug总结" scheme="https://ivonhoe.github.io/categories/Bug%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="多线程" scheme="https://ivonhoe.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="死锁" scheme="https://ivonhoe.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化之一刀流优化[持续更新]</title>
    <link href="https://ivonhoe.github.io/2017/05/05/android-performance-tips/"/>
    <id>https://ivonhoe.github.io/2017/05/05/android-performance-tips/</id>
    <published>2017-05-05T14:59:14.000Z</published>
    <updated>2019-07-07T14:35:44.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用windowBackground实现应用秒开"><a href="#使用windowBackground实现应用秒开" class="headerlink" title="使用windowBackground实现应用秒开"></a>使用windowBackground实现应用秒开</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;SplashTheme&quot; parent=&quot;@android:style/Theme.Black.NoTitleBar.Fullscreen&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/bg_splash_activity&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;@android:windowAnimationStyle&quot;&gt;@style/myact&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="使用windowBackground减少过度绘制"><a href="#使用windowBackground减少过度绘制" class="headerlink" title="使用windowBackground减少过度绘制"></a>使用windowBackground减少过度绘制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;AppMainTheme&quot; parent=&quot;@android:style/Theme.Holo.Light&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowBackground&quot;&gt;@color/white&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;@android:windowAnimationStyle&quot;&gt;@style/myact&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/res/performance-tips/overdraw.png" alt="使用windowBackground前后对比"></p><h3 id="手动清除GPU绘图缓存，降低应用PSS内存值"><a href="#手动清除GPU绘图缓存，降低应用PSS内存值" class="headerlink" title="手动清除GPU绘图缓存，降低应用PSS内存值"></a>手动清除GPU绘图缓存，降低应用PSS内存值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 清除GPU绘图缓存</span><br><span class="line"> */</span><br><span class="line">private void cleanGraphicsCache() &#123;</span><br><span class="line">    Object instance = ReflectUtils.getStaticMethod(&quot;android.view.WindowManagerGlobal&quot;,</span><br><span class="line">            &quot;getInstance&quot;, null, null);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Class threadClazz = Class.forName(&quot;android.view.WindowManagerGlobal&quot;);</span><br><span class="line">        Method m1 = threadClazz.getDeclaredMethod(&quot;trimMemory&quot;, int.class);</span><br><span class="line">        m1.invoke(instance, TRIM_MEMORY_COMPLETE);</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转载请标明出处病已blog-https-ivonhoe-github-io"><a href="#转载请标明出处病已blog-https-ivonhoe-github-io" class="headerlink" title="转载请标明出处病已blog https://ivonhoe.github.io/"></a>转载请标明出处<a href="https://ivonhoe.github.io/">病已blog https://ivonhoe.github.io/</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用windowBackground实现应用秒开&quot;&gt;&lt;a href=&quot;#使用windowBackground实现应用秒开&quot; class=&quot;headerlink&quot; title=&quot;使用windowBackground实现应用秒开&quot;&gt;&lt;/a&gt;使用windowBackground实现应用秒开&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;style name=&amp;quot;SplashTheme&amp;quot; parent=&amp;quot;@android:style/Theme.Black.NoTitleBar.Fullscreen&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;item name=&amp;quot;android:windowBackground&amp;quot;&amp;gt;@drawable/bg_splash_activity&amp;lt;/item&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;item name=&amp;quot;@android:windowAnimationStyle&amp;quot;&amp;gt;@style/myact&amp;lt;/item&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;使用windowBackground减少过度绘制&quot;&gt;&lt;a href=&quot;#使用windowBackground减少过度绘制&quot; class=&quot;headerlink&quot; title=&quot;使用windowBackground减少过度绘制&quot;&gt;&lt;/a&gt;使用windowBackground减少过度绘制&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;style name=&amp;quot;AppMainTheme&amp;quot; parent=&amp;quot;@android:style/Theme.Holo.Light&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;item name=&amp;quot;android:windowBackground&amp;quot;&amp;gt;@color/white&amp;lt;/item&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;item name=&amp;quot;android:windowNoTitle&amp;quot;&amp;gt;true&amp;lt;/item&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;item name=&amp;quot;@android:windowAnimationStyle&amp;quot;&amp;gt;@style/myact&amp;lt;/item&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android性能优化" scheme="https://ivonhoe.github.io/categories/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
