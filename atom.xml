<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>别辜负自己</title>
  <subtitle>Read The Fucking Source Code</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ivonhoe.github.io/"/>
  <updated>2017-04-27T08:09:49.000Z</updated>
  <id>https://ivonhoe.github.io/</id>
  
  <author>
    <name>病已</name>
    <email>yangfan3687@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Zygote与内存</title>
    <link href="https://ivonhoe.github.io/2017/04/26/Zygote-2/"/>
    <id>https://ivonhoe.github.io/2017/04/26/Zygote-2/</id>
    <published>2017-04-25T16:49:27.000Z</published>
    <updated>2017-04-27T08:09:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="BitmapAnalyer看Hello_World">BitmapAnalyer看Hello World</h3><p>当使用BitmapAnalyzer分析一个Android5.0+的Hello World App时你会dump出400+张图片，分析仔细看一下可以发现，这些都是Android系统的主题资源图片，为什么会有这么多主题资源被加载？是不是选择其他的theme这些资源是会改变？不需要的无用资源能否避免被加载？How？毕竟单单Resources中sPreloadedDrawables所引用的Drawable就会占用10M以上的内存空间。</p>
<p><img src="/res/hprof/hprof-3.png" alt=""></p>
<p>使用Android Studio的monitor工具dump内存如上图所示，AS将hprof中的内存信息分为三类，分别是App heap，Image heap，Zygote heap。App heap很好理解，就是应用进程独占的内存空间，在应用中创建的对象都会在App heap上。而在使用Dalvik虚拟机的手机上，并没有Image heap，只有App heap和Zygote heap。<a href="https://developer.android.com/studio/profile/am-hprof.html#why" target="_blank" rel="external">Android官网文档</a>的三者的解释是：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App heap - The heap used by the current app.&#10;&#10;Image heap - The memory mapped copy of the current app on disk.&#10;&#10;Zygote heap - The common set of libraries and runtime classes and data that all apps are forked from. The zygote space is created during device startup and is never allocated into.</span><br></pre></td></tr></table></figure>
<p>较详细的Zygote机制可以看翻译的<a href="https://ivonhoe.github.io/2017/04/25/Zygote/">Zygote</a>,总的来说是<code>app_process</code>调用Zygote的main()方法启动Zygote并创建第一个虚拟机进程，Zygote启动时会预加载所有需要的Java classes和”必要的”资源文件，这些资源文件就包括我们在hprof文件中看到的被sPreloadedDrawables所直接引用的Bitmap资源。所以应用进程都是从Zygote中fork出来的，所以所有的应用进程都会包含上面提到的资源文件。而这些资源的拷贝可以看成浅拷贝，并不是真正的内存copy，而是作为进程间的共享内存使用。</p>
<p><img src="/res/hprof/hprof-2.png" alt=""></p>
<p>当通过反射手动清除sPreloadDrawable对这些资源的强引用，通过Android Studio的monitor工具发现，gc以后App heap发生了断崖式的内存回收，<code>adb shell dumpsys meminfo</code>发现Heap Alloc和Heap Size都发生了显著的减小，但Pss total并没有显著变化。这里的理解是PSS = Private RAM + 按比例计算的Shared RAM，这两部分都没有发生显著变化，所以PSS Total没有变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void clearPreloadedDrawables() &#123;&#10;    try &#123;&#10;        Field mFieldPreloadedDrawables = getField(Resources.class, &#34;sPreloadedDrawables&#34;);&#10;        if (mFieldPreloadedDrawables != null) &#123;&#10;            mFieldPreloadedDrawables.setAccessible(true);&#10;&#10;            boolean access = mFieldPreloadedDrawables.isAccessible();&#10;            if (!access) &#123;&#10;                mFieldPreloadedDrawables.setAccessible(true);&#10;            &#125;&#10;&#10;            if (Build.VERSION.SDK_INT &#60;= 17) &#123;&#10;                LongSparseArray&#60;Drawable.ConstantState&#62; dArray = (LongSparseArray&#60;Drawable.ConstantState&#62;) mFieldPreloadedDrawables.get(getResources());&#10;                if (dArray != null) &#123;&#10;                    dArray.clear();&#10;                &#125;&#10;&#10;                // dArray.put(1, createDrawableConstant());&#10;            &#125; else if (Build.VERSION.SDK_INT &#62;= 18) &#123;&#10;                LongSparseArray&#60;Drawable.ConstantState&#62;[] dArray = (LongSparseArray&#60;Drawable.ConstantState&#62;[]) mFieldPreloadedDrawables.get(getResources());&#10;                if (dArray != null) &#123;&#10;                    for (int i = 0; i &#60; dArray.length; i++) &#123;&#10;                        if (dArray[i] != null) &#123;&#10;                            dArray[i].clear();&#10;                            // dArray[i].put(1, createDrawableConstant());&#10;                        &#125;&#10;                    &#125;&#10;                &#125;&#10;            &#125;&#10;&#10;            mFieldPreloadedDrawables.setAccessible(true);&#10;        &#125;&#10;    &#125; catch (Exception e) &#123;&#10;        e.printStackTrace();&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/res/hprof/hprof-7.png" alt=""></p>
<p><img src="/res/hprof/hprof-5.png" alt=""></p>
<p>那请问，上面👆的内存清理有意义吗？Heap allocated较少了10M，但PSS并没有明显的变化，给我的感觉就像大家在吃大锅饭，我只吃了1碗，别人吃了10碗，付钱的时候却是AA。</p>
<h3 id="Copy-On-Write(COW)">Copy-On-Write(COW)</h3><p>Zygote heap是系统共享内存heap，这里我尝试修改<code>sPreloadDrawable</code>对应数据时，如下图所示，系统默认预加载399张资源图片，当手动插入一张新的图片到缓存后，缓存大小变成了400。但让我觉得诡异的是，不是说Android系统使用COW机制吗？为啥插入前后sPreloadDrawable相关的内存地址根本没有变化？难道我把共享内存的数据也改掉了？其实并没有。</p>
<p><img src="/res/hprof/hprof-4.png" alt=""></p>
<p><img src="/res/hprof/hprof-8.jpg" alt=""></p>
<p>linux没有那么傻，在fork子进程的时候并不会真正拷贝父进程内存数据，而是子进程的虚拟内存空间指向父进程的物理内存空间。子进程和父进程的虚拟空间不同，但物理空间是同一个。当子进程需要重写共享内存数据时，系统才会为子进程分配响应的物理内存。这里的虚拟内存空间对应用程序来说就是逻辑地址，对于CPU来说就是线性地址。</p>
<h3 id="总结">总结</h3><p>回到之前思考的几个问题：</p>
<ul>
<li><p>为什么会有这么多主题资源被加载？是不是选择其他的theme这些资源是会改变？<br>这些主题资源是系统启动时Zygote预加载的系统资源，Zygote任务这些资源每个App都会用到，特别是5.0+的系统会达到400+的默认theme图片，占用10M+的内存空间，不过这些内存是系统共享的你用或不用他们都在那里。改变应用的主题样式并不会改变sPreloadDrawable的加载内容。</p>
</li>
<li><p>不需要的无用资源能否避免被加载？<br>这些默认系统资源无法避免被系统预加载，但是不同ROM厂商针对这些资源的看法差别还是很大的，根据测试的情况看，三星的预加载资源比源码的还要多，并且清空sPreloadDrawable也不能减少Heap allocte的大小。相反锤子手机对这些预加载资源的作用倒是不太看好，在锤子坚果上看到的预加载资源就很少，几乎可以忽略不计。而在Android 5.0以下的系统版本，这块预加载的资源也不是很夸张。</p>
</li>
<li><p>清空预加载资源对应用内存有无优化作用？<br>说下个人看法，如果你的应用分为UI进程和后台服务进程。在UI进程清除系统预加载资源可能并不是明智的选择，为啥？因为这是一件吃力未必讨好的事情，虽然这10M空间你并没有使用，但系统并没有领情，反而当你想要在使用系统资源的时候，那这些资源就会完全算到你的头上。反而会造成应用进程内存的上升。<br>如果是后台服务进程，打死也不会用到系统主题资源，清除预加载资源为什么不是对自己有利的事情呢？因为这样确实让Heap变小了呀！</p>
<p>当然以上都是个人的理解，如有理解错误，恳请能够指出。对于如何获取Java对象的物理地址，我还没有找到更好的办法，所以暂时还没有实践验证COW。</p>
</li>
</ul>
<p>临帖顿首，不知所言，2017.4.26日夜。</p>
<h3 id="参考">参考</h3><p><a href="https://developer.android.com/studio/profile/investigate-ram.html" target="_blank" rel="external"></a></p>
<p><a href="https://developer.android.com/studio/profile/am-hprof.html#why" target="_blank" rel="external">HPROF Viewer and Analyzer</a></p>
<p><a href="http://www.jianshu.com/p/d061fa36a0d9" target="_blank" rel="external">Manage Your App’s Memory</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/deep-android-v1/zygote.html" target="_blank" rel="external">深入理解 Zygote</a></p>
<p><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="external">Linux写时拷贝技术(copy-on-write)</a></p>
<p><a href="http://luodw.cc/2016/02/17/address/" target="_blank" rel="external">linux虚拟地址转物理地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;BitmapAnalyer看Hello_World&quot;&gt;BitmapAnalyer看Hello World&lt;/h3&gt;&lt;p&gt;当使用BitmapAnalyzer分析一个Android5.0+的Hello World App时你会dump出400+张图片，分析仔细看一下可以发现，这些都是Android系统的主题资源图片，为什么会有这么多主题资源被加载？是不是选择其他的theme这些资源是会改变？不需要的无用资源能否避免被加载？How？毕竟单单Resources中sPreloadedDrawables所引用的Drawable就会占用10M以上的内存空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/res/hprof/hprof-3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用Android Studio的monitor工具dump内存如上图所示，AS将hprof中的内存信息分为三类，分别是App heap，Image heap，Zygote heap。App heap很好理解，就是应用进程独占的内存空间，在应用中创建的对象都会在App heap上。而在使用Dalvik虚拟机的手机上，并没有Image heap，只有App heap和Zygote heap。&lt;a href=&quot;https://developer.android.com/studio/profile/am-hprof.html#why&quot;&gt;Android官网文档&lt;/a&gt;的三者的解释是：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Copy-on-wirte" scheme="https://ivonhoe.github.io/tags/Copy-on-wirte/"/>
    
      <category term="Zygote" scheme="https://ivonhoe.github.io/tags/Zygote/"/>
    
  </entry>
  
  <entry>
    <title>Zygote</title>
    <link href="https://ivonhoe.github.io/2017/04/15/Zygote/"/>
    <id>https://ivonhoe.github.io/2017/04/15/Zygote/</id>
    <published>2017-04-15T15:32:51.000Z</published>
    <updated>2017-04-25T16:50:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="[译]Zygote">[译]Zygote</h2><p>原文地址：<a href="https://anatomyofandroid.com/2013/10/15/zygote/" target="_blank" rel="external">Zygote https://anatomyofandroid.com/2013/10/15/zygote/</a></p>
<p>Zygote（受精卵）是一个启动应用的守护进程，在Server Manager之后被init.rc触发，但其实他是真正被app_process启动的，下面是启动这个特殊进程的流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server&#10;class main&#10;socket zygote stream 660 root system&#10;onrestart write /sys/android_power/request_state wake&#10;onrestart write /sys/power/state on&#10;onrestart restart media&#10;onrestart restart netd</span><br></pre></td></tr></table></figure>
<p>你可以发现Zygote是如何当做系统服务启动的，你也可以看到app_process为什么说app_process是启动Zygote的真正命令。就像之前说的，Zygote是一个以专门启动应用为的守护进程。这意味着Zygote是所有App进程的父进程。当app_process启动Zygote时，它通过调用Zygote的main()方法创建了第一个Dalvik虚拟机。当Zygote启动后，zygote会预加载所有必须的Java类和资源，启动System Server并打开一个名为/dev/socket/zygote的socket服务，去监听所有启动应用的请求。 想之前的文章所说，System Server 是一个和它的父进程完全分离的进程。一旦System Server创建完成，它会初始化一系列不同的System Services并启动Activity Manager。那Zygote是如何启动新的应用的呢？</p>
<a id="more"></a>
<p>Zygote 通过/dev/socket/zygote(一个sockete Socket Server)接收启动应用的请求，就会触发一次fork()调用，会在另一个存储空间创建一个自身的拷贝。这个过程是很高效的。当Zygote执行fork时，它会精准创建一个预加载了应用进程所需的所有必要类和资源的Dalvik虚拟机，这样就会把创建虚拟机和加载资源的过程变得很高效。但这个设计不仅仅是这样。由于Android运行在Linux内核上，Linux Kernal实现了一个叫做Copy On Write（COW）的策略，在fork进程的过程中并不会真正的拷贝内存。一个进程想要修改这个共享的内存是，kernel会拦截这个请求，并对要修改的内存做一个拷贝。当一些Android的类库是不可写的情况下，那就意味着所有从Zygote fork出来的进程都在共享一份系统类文件和资源。另一个好处就是真的节省内存。不管启动多少应用进程在内存的增长上都会小很多。</p>
<p>If you are in an early stage of a porting process, Zygote is another big process that you don’t need to start. You can disable it by adding the keyword “disabled” at the end of the boot sequence in init.rc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server&#10;class main&#10;socket zygote stream 660 root system&#10;onrestart write /sys/android_power/request_state wake&#10;onrestart write /sys/power/state on&#10;onrestart restart media&#10;onrestart restart netd&#10;disabled</span><br></pre></td></tr></table></figure>
<p>下面是一张说明Zygote在Android平台中作用的关系图(from Embedded Android)。</p>
<p><img src="/res/zygote/zygote-1.png" alt=""></p>
<p>zygote的main()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;&#10; try &#123;&#10;     // Start profiling the zygote initialization.&#10;     SamplingProfilerIntegration.start();&#10;&#10;    registerZygoteSocket();&#10;    EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,&#10;    SystemClock.uptimeMillis());&#10;    preload();&#10;    EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,&#10;    SystemClock.uptimeMillis());&#10;&#10;    // Finish profiling the zygote initialization.&#10;    SamplingProfilerIntegration.writeZygoteSnapshot();&#10;&#10;    // Do an initial gc to clean up after startup&#10;    gc();&#10;&#10;    // Disable tracing so that forked processes do not inherit stale tracing tags from&#10;    // Zygote.&#10;    Trace.setTracingEnabled(false);&#10;&#10;    // If requested, start system server directly from Zygote&#10;    if (argv.length != 2) &#123;&#10;        throw new RuntimeException(argv[0] + USAGE_STRING);&#10;    &#125;&#10;&#10;    if (argv[1].equals(&#34;start-system-server&#34;)) &#123;&#10;        startSystemServer();&#10;    &#125; else if (!argv[1].equals(&#34;&#34;)) &#123;&#10;        throw new RuntimeException(argv[0] + USAGE_STRING);&#10;    &#125;&#10;&#10;    Log.i(TAG, &#34;Accepting command socket connections&#34;);&#10;&#10;    runSelectLoop();&#10;&#10;    closeServerSocket();&#10; &#125; catch (MethodAndArgsCaller caller) &#123;&#10;     caller.run();&#10; &#125; catch (RuntimeException ex) &#123;&#10;     Log.e(TAG, &#34;Zygote died with exception&#34;, ex);&#10;     closeServerSocket();&#10;     throw ex;&#10; &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>通过下面代码可以看到Zygote是如何启动System Server的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * Prepare the arguments and fork for the system server process.&#10; */&#10;private static boolean startSystemServer()&#10;        throws MethodAndArgsCaller, RuntimeException &#123;&#10;    /* Hardcoded command line to start the system server */&#10;    String args[] = &#123;&#10;            &#34;--setuid=1000&#34;,&#10;            &#34;--setgid=1000&#34;,&#10;            &#34;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,3001,3002,3003,3006,3007&#34;,&#10;            &#34;--capabilities=130104352,130104352&#34;,&#10;            &#34;--runtime-init&#34;,&#10;            &#34;--nice-name=system_server&#34;,&#10;            &#34;com.android.server.SystemServer&#34;,&#10;    &#125;;&#10;    ZygoteConnection.Arguments parsedArgs = null;&#10;&#10;    int pid;&#10;&#10;    try &#123;&#10;        parsedArgs = new ZygoteConnection.Arguments(args);&#10;        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);&#10;        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);&#10;        &#10;        /* Request to fork the system server process */&#10;        pid = Zygote.forkSystemServer(&#10;                parsedArgs.uid, parsedArgs.gid,&#10;                parsedArgs.gids,&#10;                parsedArgs.debugFlags,&#10;                null,&#10;                parsedArgs.permittedCapabilities,&#10;                parsedArgs.effectiveCapabilities);&#10;    &#125; catch (IllegalArgumentException ex) &#123;&#10;        throw new RuntimeException(ex);&#10;    &#125;&#10;    &#10;    /* For child process */&#10;    if (pid == 0) &#123;&#10;        handleSystemServerProcess(parsedArgs);&#10;    &#125;&#10;&#10;    return true;&#10;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;[译]Zygote&quot;&gt;[译]Zygote&lt;/h2&gt;&lt;p&gt;原文地址：&lt;a href=&quot;https://anatomyofandroid.com/2013/10/15/zygote/&quot;&gt;Zygote https://anatomyofandroid.com/2013/10/15/zygote/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Zygote（受精卵）是一个启动应用的守护进程，在Server Manager之后被init.rc触发，但其实他是真正被app_process启动的，下面是启动这个特殊进程的流程。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server&amp;#10;class main&amp;#10;socket zygote stream 660 root system&amp;#10;onrestart write /sys/android_power/request_state wake&amp;#10;onrestart write /sys/power/state on&amp;#10;onrestart restart media&amp;#10;onrestart restart netd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以发现Zygote是如何当做系统服务启动的，你也可以看到app_process为什么说app_process是启动Zygote的真正命令。就像之前说的，Zygote是一个以专门启动应用为的守护进程。这意味着Zygote是所有App进程的父进程。当app_process启动Zygote时，它通过调用Zygote的main()方法创建了第一个Dalvik虚拟机。当Zygote启动后，zygote会预加载所有必须的Java类和资源，启动System Server并打开一个名为/dev/socket/zygote的socket服务，去监听所有启动应用的请求。 想之前的文章所说，System Server 是一个和它的父进程完全分离的进程。一旦System Server创建完成，它会初始化一系列不同的System Services并启动Activity Manager。那Zygote是如何启动新的应用的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Zygote" scheme="https://ivonhoe.github.io/tags/Zygote/"/>
    
  </entry>
  
  <entry>
    <title>如何使用ddmlib dump出堆文件</title>
    <link href="https://ivonhoe.github.io/2017/04/09/how-to-dump-heap/"/>
    <id>https://ivonhoe.github.io/2017/04/09/how-to-dump-heap/</id>
    <published>2017-04-09T11:03:01.000Z</published>
    <updated>2017-04-26T02:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下如果我想要较详细的分析内存状况，会使用android monitor(下简称monitor)和Memory Analyzer工具(下简称MAT)，但步骤有些麻烦。</p>
<ol>
<li>使用monitor dump堆文件</li>
<li>使用hprof-conv工具，将hprof转换成MAT能够识别的格式</li>
<li>使用MAT分析</li>
</ol>
<p>需要手动dump hprof再使用hprof-conv工具手动转码，上篇<a href="https://ivonhoe.github.io/2017/03/22/Bitmap&amp;Memory/">Android Bitmap的内存大小是如何计算的？</a>说到使用square的<a href="https://github.com/square/haha" target="_blank" rel="external">haha</a>来做内存堆中Bitmap的分析。所以在思考如何一键完成内存dump和analyze的过程，当然也可以任意其他Java对象做分析。<br>如何完成dump和转码，思路还是Read the fucking source code，看下monitor是如何dump hprof文件的。打开Android sdk目录，monitor和其依赖的jar分别在<code>/tools</code>和’/tools/lib’目录，核心代码在<code>ddmlib.jar</code>中，Java swring代码在<code>ddms.jar</code>和<code>ddmuilib.jar</code>中，ddmlib需要依赖<code>common.jar</code>和<code>guava.jar</code>。</p>
<a id="more"></a>
<p><img src="/res/hprof/hprof-1.png" alt=""></p>
<h3 id="如何使用ddmlib获取adb连接的设备">如何使用ddmlib获取adb连接的设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;&#10;        IDevice device;&#10;        // &#36825;&#37324;&#38656;&#35201;&#20256;&#21442;true&#65292;&#19981;&#28982;&#24453;&#20250;&#20250;&#25343;&#19981;&#21040;&#25163;&#26426;&#19978;&#30340;client&#10;        AndroidDebugBridge.init(true);&#10;        AndroidDebugBridge bridge = AndroidDebugBridge.createBridge(&#10;                &#34;/Users/Ivonhoe/Library/Android/sdk/platform-tools/adb&#34;, false);&#10;        waitForDevice(bridge);&#10;        IDevice devices[] = bridge.getDevices();&#10;        device = devices[0];&#10;    &#125;&#10;&#10;    private static void waitForDevice(AndroidDebugBridge bridge) &#123;&#10;        int count = 0;&#10;        while (!bridge.hasInitialDeviceList()) &#123;&#10;            try &#123;&#10;                Thread.sleep(100);&#10;                count++;&#10;            &#125; catch (InterruptedException ignored) &#123;&#10;            &#125;&#10;            if (count &#62; 300) &#123;&#10;                System.err.print(&#34;Time out&#34;);&#10;                break;&#10;            &#125;&#10;        &#125;&#10;    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何dump_hprof">如何dump hprof</h3><p><strong>这里不说看ddms源码的过程了，主要还是通过关键字搜索跟一下dump操作的处理逻辑</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#35774;&#32622;HprofDumpHandler&#65292;&#23545;dump&#20107;&#20214;&#20570;&#30417;&#21548;&#22788;&#29702;dump&#25104;&#21151;&#25110;&#32773;&#22833;&#36133;&#30340;&#22238;&#35843;&#65292;&#10; * &#24182;&#20445;&#23384;hprof&#25991;&#20214;&#25968;&#25454;&#10; *&#10; * @param device&#10; */&#10;public HprofDump(Device device) &#123;&#10;    mDevice = device;&#10;&#10;    ClientData.IHprofDumpHandler hprofDumpHandler = new ClientData.IHprofDumpHandler() &#123;&#10;&#10;        @Override&#10;        public void onSuccess(String remoteFilePath, Client client) &#123;&#10;            String hprofPath = getHprofPath(client.getClientData().getClientDescription());&#10;            mDevice.pull(hprofPath, remoteFilePath);&#10;&#10;            conversionAndRemoveHprof(hprofPath);&#10;&#10;            isDumping = false;&#10;        &#125;&#10;&#10;        @Override&#10;        public void onSuccess(byte[] bytes, Client client) &#123;&#10;            String hprofPath = getHprofPath(client.getClientData().getClientDescription());&#10;            Utilities.saveFile(bytes, hprofPath);&#10;&#10;            conversionAndRemoveHprof(hprofPath);&#10;&#10;            isDumping = false;&#10;        &#125;&#10;&#10;        @Override&#10;        public void onEndFailure(Client client, String s) &#123;&#10;            isDumping = false;&#10;        &#125;&#10;    &#125;;&#10;    ClientData.setHprofDumpHandler(hprofDumpHandler);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里默认选择栈顶进程做dump操作，通过adb shell dumpsys activity top命令获取栈顶TASK的ApplicationId，通过IDevice接口的getClient方法获取Client对象，执行dumpHprof操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * dump&#26632;&#39030;&#36827;&#31243;&#30340;hprof&#10; */&#10;public void dumpTopTaskHprof() &#123;&#10;    if (isDumping) &#123;&#10;        return;&#10;    &#125;&#10;&#10;    IDevice iDevice = mDevice.getIDevice();&#10;&#10;    /**&#10;     * &#36825;&#37324;&#33258;&#21160;&#36873;&#25321;&#25163;&#26426;&#19978;&#26632;&#39030;&#36827;&#31243;&#20570;dump&#25805;&#20316;&#65292;&#33719;&#21462;applicationName&#10;     */&#10;    String topApp = getTopApplication();&#10;    Client client = iDevice.getClient(topApp);&#10;&#10;    if (client == null) &#123;&#10;        throw new RuntimeException(&#34;Can not dump app:&#34; + topApp);&#10;    &#125;&#10;    client.dumpHprof();&#10;    isDumping = true;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在IHprofDumpHandler的回调中, 保存hprof文件，做格式转换，分析Bitmap对象的状况。BitmapAnalyzer.java的代码在上文说过。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void conversionAndRemoveHprof(String hprofPath) &#123;&#10;    String convHprofPath = getConvHprofPath(hprofPath);&#10;    hprofConv(hprofPath, convHprofPath);&#10;    removeFile(hprofPath);&#10;&#10;    analyzerBitmap(convHprofPath);&#10;&#125;&#10;&#10;private void hprofConv(String hprofPath, String convHprofPath) &#123;&#10;    String adbPath = Adb.instance().getAdbPath();&#10;    String hprofConvPath = adbPath.replace(&#34;adb&#34;, &#34;hprof-conv&#34;);&#10;    ShellCommand.exec(hprofConvPath + &#34; &#34; + hprofPath + &#34; &#34; + convHprofPath);&#10;&#125;&#10;&#10;private void analyzerBitmap(String hprofPath) &#123;&#10;    String[] args = new String[2];&#10;    args[0] = hprofPath;&#10;    args[1] = &#34;bitmap&#34;;&#10;    BitmapAnalyzer.main(args);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于BitmapAnalyzer的那些发现">关于BitmapAnalyzer的那些发现</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下如果我想要较详细的分析内存状况，会使用android monitor(下简称monitor)和Memory Analyzer工具(下简称MAT)，但步骤有些麻烦。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用monitor dump堆文件&lt;/li&gt;
&lt;li&gt;使用hprof-conv工具，将hprof转换成MAT能够识别的格式&lt;/li&gt;
&lt;li&gt;使用MAT分析&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要手动dump hprof再使用hprof-conv工具手动转码，上篇&lt;a href=&quot;https://ivonhoe.github.io/2017/03/22/Bitmap&amp;amp;Memory/&quot;&gt;Android Bitmap的内存大小是如何计算的？&lt;/a&gt;说到使用square的&lt;a href=&quot;https://github.com/square/haha&quot;&gt;haha&lt;/a&gt;来做内存堆中Bitmap的分析。所以在思考如何一键完成内存dump和analyze的过程，当然也可以任意其他Java对象做分析。&lt;br&gt;如何完成dump和转码，思路还是Read the fucking source code，看下monitor是如何dump hprof文件的。打开Android sdk目录，monitor和其依赖的jar分别在&lt;code&gt;/tools&lt;/code&gt;和’/tools/lib’目录，核心代码在&lt;code&gt;ddmlib.jar&lt;/code&gt;中，Java swring代码在&lt;code&gt;ddms.jar&lt;/code&gt;和&lt;code&gt;ddmuilib.jar&lt;/code&gt;中，ddmlib需要依赖&lt;code&gt;common.jar&lt;/code&gt;和&lt;code&gt;guava.jar&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="dump heap" scheme="https://ivonhoe.github.io/tags/dump-heap/"/>
    
      <category term="内存" scheme="https://ivonhoe.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Android Bitmap的内存大小是如何计算的？</title>
    <link href="https://ivonhoe.github.io/2017/03/22/Bitmap&amp;Memory/"/>
    <id>https://ivonhoe.github.io/2017/03/22/Bitmap&amp;Memory/</id>
    <published>2017-03-22T11:35:36.000Z</published>
    <updated>2017-04-24T07:02:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言">一、前言</h3><p>本来只想说下Bitmap和内存的基本关系，但发现如果真的想把这看似简单的事情说清楚，实际上未必那么简单，你不信？不妨先尝试下回答下面几个问题！</p>
<ul>
<li>问1：什么是dpi？什么是dp？答：你在侮辱我？我拒绝回答！（：无辜脸</li>
<li>问2：以Nexus6为例，分辨率1440*2560，5.96英寸，ppi是什么？dpi是什么？1dp是多少像素？</li>
<li>问3：还以Nexus6为例，一张180*180的图片，放置在设置了<code>wrap_content</code>属性的ImageView中，当这张图片，分别放在<code>drawable-nodpi</code>,<code>drawable-mdpi</code>,<code>drawable-hdpi</code>, <code>drawable-xxhdpi</code>,<code>drawable-xxxhdpi</code>这几个资源目录中，在屏幕上分别显示多大(像素)的图片？</li>
<li>问4：这张图片占用的内存大小分别为多少？</li>
<li>问5：如果设置ImageView的宽和高为固定的值，如50px，那么上述情况下，加载的Bitmap占用内存大小分别为多大？</li>
</ul>
<p>本文主要围绕上述问题，介绍Android图片资源加载的基本机制，图片的内存大小如何计算，以及内存图片分析工具。</p>
<a id="more"></a>
<h3 id="二、基础概念">二、基础概念</h3><ul>
<li>px：像素(pixel)，指的是屏幕上的物理点，最小的独立显示单位</li>
<li>ppi：每英寸像素点(Pixels Per Inch)，之前我自己的理解就是使用勾股定理，通过屏幕长宽计算出对角线的长度，再除以屏幕对角线英寸值。</li>
<li>dpi：每英寸点(Dots Per Inch)，和ppi有什么区别？</li>
<li>dp：像素无关点(Density-Independent pixel)，这个Android定义的虚拟值，和px关系式是<code>px = dp * (dpi / 160)</code>，为啥？</li>
</ul>
<p><strong>ppi</strong></p>
<p>ppi指的是水平方向或者竖直方向上每英寸的像素值，先说为啥很多对ppi的理解都有问题。很多文章利用勾股定理计算手机屏幕对角线像素个数！！但是手机屏幕的像素分布是点阵分布，点阵的对角线像素点不是用勾股定理算出来的，而是等于它的行数或者列数，为啥用对角线计算？因为一般手机的尺寸说的就是对角线英寸值，而不知道长宽的英寸值。这里有个公式推导：<br>设 X/x = Y/y = ppi，这里X为水平像素值，x为水平英寸值，Y为竖直像素值，y为竖直英寸值。则(X²+Y²）/（x²+y²）=（X/x）²=（Y/y）²，这个公式可通过勾股定理和相似三角形原理证明。ppi的计算只是形式和勾股定理一样但并不是勾股定理的意思，分子也不是对角线的像素数！！ppi的计算公式可表示为：√(X²+Y²）/对角线英寸。但不意味着ppi是使用勾股定理计算对角线像素值获得的~~</p>
<p><img src="/res/bitmap/2.png" alt=""></p>
<p><a href="https://www.zhihu.com/question/21220154/answer/69672901" target="_blank" rel="external">DPI、PPI、DP、PX 的详细计算方法及算法来源是什么？fsk的回答</a></p>
<p><strong>dpi</strong></p>
<p>dpi是由ppi确定的，还是以Nexue6为例，通过ppi的计算公式，可以计算出Nexues6的ppi为<code>492</code>,参照下表，应该在xxxhdpi的范围内，但它的dpi并不是<code>492</code>。实际上dpi只有120(low)、160(medium)、240(high)、260、280、300、320(xhigh)、340、360、400、420、480（xxhpdi）、560、640（xxxhpi）这几种，可以参照<code>android.util.DisplayMetrics</code>的源码。通过<code>getResources().getDisplayMetrics().densityDpi</code>可以获取手机实际的dpi。</p>
<p><img src="/res/bitmap/dpi.png" alt=""></p>
<p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/util/DisplayMetrics.java" target="_blank" rel="external">DisplayMetrics.java源码链接</a></p>
<p><strong>dp</strong></p>
<p>1dp在Nexues6上是多少像素？<br><code>1dp * (560/160) = 3.5px</code></p>
<p><strong>如何更改手机的dpi</strong></p>
<ul>
<li>需要root的手机</li>
<li>更改/system/build.prop中的ro.sf.lcd_density属性，这个值越小，屏幕密度越高</li>
<li>adb reboot 重启手机</li>
</ul>
<p><strong>如何快速查看手机屏幕信息</strong></p>
<p><code>adb shell dumpsys display | findstr DisplayDeviceInfo</code></p>
<h3 id="三、回到问题">三、回到问题</h3><p>以Nexus6为例，一张180*180的图片，放在设置了<code>wrap_content</code>属性的ImageView中，当这张图片，分别放置在<code>drawable-nodpi</code>,<code>drawable-mdpi</code>,<code>drawable-hdpi</code>, <code>drawable-xxhdpi</code>,<code>drawable-xxxhdpi</code>这几个资源目录中，在屏幕上分别显示多大(像素)的图片？</p>
<p>答：根据上面的分析，可以看到nexus6，是属于xxxhpi的屏幕，获取到dpi为560。如果把180大小的图片只放在xxxhdpi目录中，是不是屏幕就会显示180px的大小？其实并不是，dpi=640的才是真正的xxxhdpi(这里需要看DisplayMetrics的源码)，当Android系统加载图片时，会针对当前系统的dpi和图片目录的source dpi比较做相应比例的缩放，如果一张图片放在drawable-xxxhdpi目录，这是告诉系统，针对dpi为640的手机屏幕上，这张图片是刚刚好的，它的scale为1.0，同理，drawable-xxhpi对应480dpi，drawable-xhdpi对应的是320dpi。如果希望<code>180*180</code>在nexues6的屏幕上按照原有尺寸显示，只有将其放在drawable-nodpi或者drawable-560dpi目录中才可以。</p>
<p>回到问题，如果将<code>180*180</code>放入hdpi目录中，那实际显示的图片大小应该为：<code>int (180 * (560 / 240) +0.5f ) = 420px</code>，实际图片的大小应该为420px！同理:<br>放入xhdpi目录中，实际大小应该为<code>int (180 * (560 / 320) +0.5f ) = 315px</code><br>放入xxhdpi目录中，实际大小应该为<code>int (180 * (560 / 480) +0.5f ) = 210px</code></p>
<p><a href="https://android.googlesource.com/platform/frameworks/base/+/7b2f8b8/core/jni/android/graphics/BitmapFactory.cpp" target="_blank" rel="external">BitmapFactory.cpp源码链接</a></p>
<p>如果用小的Bitmap容器，放置较大的Bitmap，那这个Bitmap的尺寸大小是按照容器的大小计算？还是按照dpi缩放的规则计算？</p>
<h3 id="四、一张图片占多大内存">四、一张图片占多大内存</h3><p>现在我们已经知道了一张图片放置在不同的资源目录中，系统decode的bitmap的尺寸大小是如何计算的了。一张图片大概占用多少内存，其实只用看一个像素占用多少内存就可以喽？我们都知道屏幕上的颜色是有R，G，B加透明度表示的，Android官方支持的RGB格式，主要是<code>ALPHA_8</code>，<code>RGB_565</code>，<code>ARGB_4444</code>，<code>ARGB_8888</code>这几种。</p>
<p>以ARGB_8888为例，表示一个像素点，使用8位表示透明度，8位表示Red，8位表示Green，8位表示Blue。加起来，一个像素就需要4byte，同理，RGB_565一个像素需要2byte。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public enum Config &#123;&#10;    ALPHA_8     (1),&#10;    RGB_565     (3),&#10;    @Deprecated&#10;    ARGB_4444   (4),&#10;    ARGB_8888   (5);&#10;    final int nativeInt;&#10;    Config(int ni) &#123;&#10;        this.nativeInt = ni;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Android decode资源图片时默认会选择ARGB_8888，如果将<code>180*180</code>放入hdpi目录中，那实际大小应该为<code>int (180 * (560 / 240) +0.5f ) = 420px</code>，像素内存大小为 <code>420 * 420 * 4 = 705600byte = 689kb</code>。同理:<br>放入xhdpi目录中，实际大小应该为<code>int (180 * (560 / 320) +0.5f ) = 315px</code>，像素内存大小为<code>315 * 315 * 4 = 396900byte = 387.6kb</code><br>放入xxhdpi目录中，实际大小应该为<code>int (180 * (560 / 480) +0.5f ) = 210px</code>，像素内存大小为<code>210 * 210 * 4 = 176400byte = 172.2kb</code></p>
<h3 id="五、如何分析内存中的图片问题？">五、如何分析内存中的图片问题？</h3><p>说了这么多，终于到了我原本想说的。Android的内存优化需要重点关注的几个方面，Bitmap的加载，Activity的泄露，webview内存等。图片的内存问题，是很多Android应用，特别是电商APP需要首要关注的问题。那如何简单的分析出内存中Bitmap的情况，这里提供一个工具。借助leakcanary的思路，通过分析内存堆dump文件中<code>android.graphics.Bitmap</code>对象的情况，<strong>将内存中Bitmap对象批量保存到图片文件中</strong>，这样就可以直观的看到内存中加载的Bitmap个数、内容和大小，进而分析可能的内存问题。</p>
<p><img src="/res/bitmap/bitmap_buffer.png" alt=""></p>
<p><img src="/res/bitmap/1.png" alt=""></p>
<p><strong>示例</strong></p>
<p>以分析蘑菇街APP内存中bitmap为例:</p>
<ul>
<li>先使用Android monitor dump hprof</li>
<li>hprof-conv做格式转换</li>
<li><code>java -jar ./bitmap-analyzer-0.0.1-SNAPSHOT.jar /Users/Ivonhoe/hprof/com.mogujie-conv.hprof 蘑菇街</code></li>
</ul>
<p><strong>参数说明</strong>：</p>
<ul>
<li>参数1：需要处理hprof文件的绝对路径</li>
<li>参数2：图片输出的文件夹名称，在hprof文件目录中创建该文件夹,缺省时直接会在hprof文件目录输出文件</li>
</ul>
<p><strong>输出说明</strong></p>
<p><img src="/res/bitmap/bitmap-analyzer.png" alt=""></p>
<ul>
<li>大小排序.txt 按照图片像素尺寸，从大到小排序</li>
<li>个数排序.txt 按照相同尺寸图片个数，从大到小排序</li>
<li>文件名 width*height_index.png</li>
</ul>
<p><strong>Jar包地址</strong></p>
<p><a href="https://raw.githubusercontent.com/Ivonhoe/mvn-repo/master/ivonhoe/java/heapanalyzer/bitmap-analyzer/0.0.1-SNAPSHOT/bitmap-analyzer-0.0.1-20170327.112600-1.jar" target="_blank" rel="external">https://raw.githubusercontent.com/Ivonhoe/mvn-repo/master/ivonhoe/java/heapanalyzer/bitmap-analyzer/0.0.1-SNAPSHOT/bitmap-analyzer-0.0.1-20170327.112600-1.jar</a></p>
<h3 id="六、参考文档">六、参考文档</h3><p><a href="http://blog.csdn.net/guolin_blog/article/details/50727753" target="_blank" rel="external">Android drawable微技巧，你所不知道的drawable的那些细节</a></p>
<p><a href="http://www.10tiao.com/html/336/201703/2652262290/1.html" target="_blank" rel="external">关于Android适配，看完这篇文章就够了</a></p>
<p><a href="http://wangjunyan.github.io/2014/12/02/export-android-bitmap-from-dump-file/" target="_blank" rel="external">批量导出dump文件中的Bitmap</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=403263974&amp;idx=1&amp;sn=b0315addbc47f3c38e65d9c633a12cd6&amp;scene=21#wechat_redirect" target="_blank" rel="external">Android 开发绕不过的坑：你的 Bitmap 究竟占多大内存？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;一、前言&lt;/h3&gt;&lt;p&gt;本来只想说下Bitmap和内存的基本关系，但发现如果真的想把这看似简单的事情说清楚，实际上未必那么简单，你不信？不妨先尝试下回答下面几个问题！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问1：什么是dpi？什么是dp？答：你在侮辱我？我拒绝回答！（：无辜脸&lt;/li&gt;
&lt;li&gt;问2：以Nexus6为例，分辨率1440*2560，5.96英寸，ppi是什么？dpi是什么？1dp是多少像素？&lt;/li&gt;
&lt;li&gt;问3：还以Nexus6为例，一张180*180的图片，放置在设置了&lt;code&gt;wrap_content&lt;/code&gt;属性的ImageView中，当这张图片，分别放在&lt;code&gt;drawable-nodpi&lt;/code&gt;,&lt;code&gt;drawable-mdpi&lt;/code&gt;,&lt;code&gt;drawable-hdpi&lt;/code&gt;, &lt;code&gt;drawable-xxhdpi&lt;/code&gt;,&lt;code&gt;drawable-xxxhdpi&lt;/code&gt;这几个资源目录中，在屏幕上分别显示多大(像素)的图片？&lt;/li&gt;
&lt;li&gt;问4：这张图片占用的内存大小分别为多少？&lt;/li&gt;
&lt;li&gt;问5：如果设置ImageView的宽和高为固定的值，如50px，那么上述情况下，加载的Bitmap占用内存大小分别为多大？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文主要围绕上述问题，介绍Android图片资源加载的基本机制，图片的内存大小如何计算，以及内存图片分析工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Bitmap" scheme="https://ivonhoe.github.io/tags/Bitmap/"/>
    
      <category term="Drawable" scheme="https://ivonhoe.github.io/tags/Drawable/"/>
    
      <category term="内存" scheme="https://ivonhoe.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Android安全之---应用防dex2jar原理及实现</title>
    <link href="https://ivonhoe.github.io/2017/02/09/%E7%BE%8E%E5%9B%A2%E5%A6%82%E4%BD%95%E9%98%B2dex2jar/"/>
    <id>https://ivonhoe.github.io/2017/02/09/美团如何防dex2jar/</id>
    <published>2017-02-09T13:55:01.000Z</published>
    <updated>2017-03-23T08:47:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、反编译某平台代码">一、反编译某平台代码</h3><p>最近在看某外卖平台的代码，发现某外卖平台最新版本版本无法正常的通过dex2jar工具将dex转换出Java源代码，在转换过程中会提示出错，如图：</p>
<p><img src="https://ivonhoe.github.io/res/dex2jar_error/dex2jar_error1.png" alt="dex2jar异常图"></p>
<p>查看转换出的Java源代码，会发现很多类方法提示下图所示异常，很多方法中都会抛出<code>RuntimeException：can not merge I and Z</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class AsyncTaskService extends IntentService &#123; &#10;  &#10;  protected void onHandleIntent(Intent paramIntent)&#123;&#10;    throw new RuntimeException(&#34;d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat...);&#10;  &#125;&#10;  &#10;  public int onStartCommand(Intent paramIntent, int paramInt1, int paramInt2)&#123;&#10;    throw new RuntimeException(&#34;d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat...&#34;);&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>查看日志文件会发现很多类似的错误信息，可以看到方法内<code>RuntimeException</code>栈信息和反编译的错误信息是相同的，都提示<code>can not merge I and Z</code>。</p>
<p><img src="https://ivonhoe.github.io/res/dex2jar_error/dex2jar_error2.png" alt="dex2jar日志"></p>
<h3 id="二、为什么？">二、为什么？</h3><p>本来以为这是dex2jar工具低版本的一个bug，但更新了dex2jar以后，依然还是会出现上述错误。<br><code>java.lang.RuntimeException: can not merge I and Z</code>这个异常，在<a href="https://sourceforge.net/p/dex2jar/tickets/238/" target="_blank" rel="external">sourceforge</a>上解释的比较清楚，其实是一个dex2jar工具检查出的一个参数异常”，<strong>The problem is caused by strict type calculation, because in java syntaxt, a boolean can not assign to an inteager. so dex2jar forbid merge type Z and I.</strong> 你用布尔类型入参调用一个参数为整型的函数，当然会检查出错，为啥这么说，我使用apktool工具，看了一下apk的smali代码。发现报错的函数的最前面都含有一段奇怪smali的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;&#125;, Lpnf/this/object/does/not/Exist;-&#62;a()Z&#10;&#10;move-result v0&#10;&#10;invoke-static &#123;v0&#125;, Lpnf/this/object/does/not/Exist;-&#62;b(I)V</span><br></pre></td></tr></table></figure>
<p>看上面的代码，<code>pnf.this.object.does.not.Exist.a()</code>方法返回一个boolean类型数据，放入v0寄存器，作为<code>pnf.this.object.does.not.Exist.b(int)</code>函数的入参。正常情况下这样的语法错误在java代码编译时就不会通过的。看到这里你会不会想，如果我不想别人直接看到我的Java代码，是不是可以通过在核心函数中插入上面这段有语法错误的代码，以达到dex2jar工具检查出错的目的呢？从而将代码被阅读的门槛从java提高到smali。</p>
<h3 id="三、手动代码注入">三、手动代码注入</h3><p>为了验证上面的猜想，这里我通过反编译一个apk，手动插入有语法错误的smali代码，以验证防dex2jar的思路，具体步骤如下：</p>
<ul>
<li>1.反编译一个apk。</li>
<li>2.修改smali代码，插入上面这三句有语法错误的代码。</li>
<li>3.重打包，使用dex2jar工具转换新包的dex，看是否能正常转换出Java源代码。并检查运行时是否出错。</li>
</ul>
<p>我这里用一个Hello World应用来测试，使用apktool反编译出smali代码，并在Application的onCreate方法中插入这段有语法错误的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># virtual methods&#10;.method public onCreate()V&#10;    .locals 3&#10;&#10;    invoke-super &#123;p0&#125;, Lcn/trinea/android/lib/h/c;-&#62;onCreate()V&#10;&#10;    invoke-virtual &#123;p0&#125;, Lcn/trinea/android/developertools/MyApplication;-&#62;getApplicationContext()Landroid/content/Context;&#10;&#10;    move-result-object v0&#10;&#10;    invoke-static &#123;&#125;, Lpnf/object/does/not/Exist;-&#62;a()Z&#10;&#10;    move-result v3&#10;&#10;    invoke-static &#123;v3&#125;, Lpnf/object/does/not/Exist;-&#62;b(I)V&#10;&#10;    return-void&#10;.end method</span><br></pre></td></tr></table></figure>
<p>这里不要忘了，你可能需要另外编译出Exist.smali这个文件，不然运行时一定会爆出ClassNotFound异常。将下面的Exist.java<strong>编译出Exist.smali</strong>放入相应的包路径，重打包就可以了。Java代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Exist &#123;&#10;    public static boolean a() &#123;&#10;        return false;&#10;    &#125;&#10;&#10;    public static void b(int test) &#123;&#10;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>最后，验证下果然重新打包后的apk，确实不能正常转换出Java源代码，这里就不贴图了，因为转换出错日志是一样的。并且运行时也不会出错。接下来会写一个Gradle编译插件，针对特定的函数，插入代码，防止dex2jar工具查看Java源代码。</p>
<h3 id="四、实现思路">四、实现思路</h3><p>Android客户端在防止其Java代码被dex2jar转换时其实就是借助dex2jar的语法检查机制，将有语法错误的字节码插入到想要保护的Java函数中里面，以达到dex2jar转换出错的目的。接下来我就大致记录下如何开发Gradle编译插件，在编译过程中实现上述防护思路，先看下Android APK打包流程：</p>
<!--more-->
<p><img src="https://ivonhoe.github.io/res/dexguard/dexguard4.jpeg" alt="Android apk打包流程"></p>
<p>Android APK打包流程如上图所示，Java代码先通过Java Compiler生成.class文件，再通过dx工具生成dex文件，最后使用apkbuilder工具完成代码与资源文件的打包，并使用jarsigner签名，最后可能还有使用zipalign对签名后的apk做对齐处理。</p>
<p>如果需要完成对特定函数的代码注入，可以在Java代码编译生成class文件后，在dex文件生成前，针对class字节码进行操作，以本例为例需要动态生成Exsit类文件的字节码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#21160;&#24577;&#29983;&#25104;Exist.class&#10;public class Exist &#123;&#10;    public static boolean a() &#123;&#10;        return false;&#10;    &#125;&#10;&#10;    public static void b(int test) &#123;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>将下列Java代码转换成字节码插入需要保护的函数中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#25554;&#20837;&#21040;&#29305;&#23450;&#30340;Java&#20989;&#25968;&#20869;&#10;Exist.b(Exist.a());</span><br></pre></td></tr></table></figure>
<p>并将修改后的.class文件放入dex打包目录中，完成dex打包，具体流程如下图所示：</p>
<p><img src="https://ivonhoe.github.io/res/dexguard/dexguard6.png" alt=""></p>
<p>Gradle提供了叫<code>Transform</code>的API，允许三方插件在class文件转换为dex文件前操作编译好的class文件，这个API的目标就是简化class文件的自定义的操作而不用对Task进行处理，并且可以更加灵活地进行操作。详细的可以参考<a href="http://blog.csdn.net/sbsujjbcy/article/details/50839263" target="_blank" rel="external">区长的博客</a>。</p>
<h3 id="五、使用ASM操作Java字节码">五、使用ASM操作Java字节码</h3><p>ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直<br>接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。这里推荐一个IDEA插件:<code>ASM ByteCode Outline</code>。可以查看.class文件的字节码，并可以生成成ASM框架代码。安装<code>ASM Bytecode Outline</code>插件后，可以在<code>Intellij IDEA</code>-&gt;<code>Code</code>-&gt;<code>Show Bytecode Outline</code>查看类文件对应个字节码和ASM框架代码，利用ASM框架代码就可以生成相应的.class文件了。</p>
<p><img src="https://ivonhoe.github.io/res/dexguard/dexguard3.png" alt=""></p>
<p>生成Exist字节码的具体实现，生成Exist.java的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassWriter cw = new ClassWriter(0);&#10;FieldVisitor fv;&#10;MethodVisitor mv;&#10;AnnotationVisitor av0;&#10;&#10;cw.visit(51, ACC_PUBLIC + ACC_SUPER, &#34;ivonhoe/dexguard/java/Exist&#34;, null, &#34;java/lang/Object&#34;, null);&#10;&#10;cw.visitSource(&#34;Exist.java&#34;, null);&#10;&#10;mv = cw.visitMethod(ACC_PUBLIC, &#34;&#60;init&#62;&#34;, &#34;()V&#34;, null, null);&#10;mv.visitCode();&#10;Label l0 = new Label();&#10;mv.visitLabel(l0);&#10;mv.visitLineNumber(7, l0);&#10;mv.visitVarInsn(ALOAD, 0);&#10;mv.visitMethodInsn(INVOKESPECIAL, &#34;java/lang/Object&#34;, &#34;&#60;init&#62;&#34;, &#34;()V&#34;, false);&#10;mv.visitInsn(RETURN);&#10;Label l1 = new Label();&#10;mv.visitLabel(l1);&#10;mv.visitLocalVariable(&#34;this&#34;, &#34;Livonhoe/dexguard/java/Exist;&#34;, null, l0, l1, 0);&#10;mv.visitMaxs(1, 1);&#10;mv.visitEnd();</span><br></pre></td></tr></table></figure>
<p>声明一个函数名为a，返回值为boolean类型的无参函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &#34;a&#34;, &#34;()Z&#34;, null, null);&#10;mv.visitCode();&#10;l0 = new Label();&#10;mv.visitLabel(l0);&#10;mv.visitLineNumber(10, l0);&#10;mv.visitInsn(ICONST_0);&#10;mv.visitInsn(IRETURN);&#10;mv.visitMaxs(1, 0);&#10;mv.visitEnd();</span><br></pre></td></tr></table></figure>
<p>声明一个函数名为b，参数为int型，返回类型为void的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MV = CW.VISITmETHOD(acc_public + acc_static, &#34;b&#34;, &#34;(i)v&#34;, NULL, NULL);&#10;MV.VISITcODE();&#10;L0 = NEW lABEL();&#10;MV.VISITlABEL(L0);&#10;MV.VISITlINEnUMBER(14, L0);&#10;MV.VISITiNSN(return);&#10;L1 = NEW lABEL();&#10;MV.VISITlABEL(L1);&#10;MV.VISITlOCALvARIABLE(&#34;TEST&#34;, &#34;i&#34;, NULL, L0, L1, 0);&#10;MV.VISITmAXS(0, 1);&#10;MV.VISITeND();</span><br></pre></td></tr></table></figure>
<p>在指定函数内，插入<code>Exist.b(Exist.a());</code>对应的字节码的具体实现，绕过Java编译器的语法检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static class InjectClassVisitor extends ClassVisitor &#123;&#10;&#10;        private String methodName;&#10;&#10;        InjectClassVisitor(int i, ClassVisitor classVisitor, String method) &#123;&#10;            super(i, classVisitor)&#10;&#10;            this.methodName = method;&#10;        &#125;&#10;&#10;        @Override&#10;        public MethodVisitor visitMethod(int access, String name, String desc,&#10;                                         String signature, String[] exceptions) &#123;&#10;&#10;            MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);&#10;            mv = new MethodVisitor(Opcodes.ASM4, mv) &#123;&#10;&#10;                @Override&#10;                void visitCode() &#123;&#10;                    // &#22312;&#26041;&#27861;&#20307;&#24320;&#22987;&#35843;&#29992;&#26102;&#10;                    if (name.equals(methodName)) &#123;&#10;                        mv.visitMethodInsn(INVOKESTATIC, &#34;ivonhoe/dexguard/java/Exist&#34;, &#34;a&#34;, &#34;()Z&#34;, false);&#10;                        mv.visitMethodInsn(INVOKESTATIC, &#34;ivonhoe/dexguard/java/Exist&#34;, &#34;b&#34;, &#34;(I)V&#34;, false);&#10;                    &#125;&#10;                    super.visitCode()&#10;                &#125;&#10;&#10;                @Override&#10;                public void visitMaxs(int maxStack, int maxLocal) &#123;&#10;                    if (name.equals(methodName)) &#123;&#10;                        super.visitMaxs(maxStack + 1, maxLocal);&#10;                    &#125; else &#123;&#10;                        super.visitMaxs(maxStack, maxLocal);&#10;                    &#125;&#10;                &#125;&#10;            &#125;&#10;            return mv;&#10;        &#125;&#10;    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="六、总结">六、总结</h3><p>看到这里可能你会有一个疑惑，为什么有语法错误的代码，在运行时不会出错，个人理解不单单是因为bool类型在内存中是以<code>0或1</code>表示，也因为<code>int</code>和<code>bool</code>在Android虚拟机中都存储在32位寄存器中，如果使用<code>int</code>和<code>long</code>类型的参数互换，在dx阶段的编译就会报错。下面是插件源码，有兴趣的同学可以尝试一下~</p>
<h4 id="插件源码">插件源码</h4><p>详细的Gradle源码和实例可参考<a href="https://github.com/Ivonhoe/dexguard" target="_blank" rel="external">https://github.com/Ivonhoe/dexguard</a></p>
<h4 id="使用方法">使用方法</h4><ul>
<li>在root project的build.gradle中添加依赖<code>classpath &#39;ivonhoe.gradle.dexguard:dexguard-gradle:0.0.2-SNAPSHOT&#39;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;&#10;    repositories &#123;&#10;        maven &#123; url &#39;https://raw.githubusercontent.com/Ivonhoe/mvn-repo/master/&#39; &#125;&#10;        mavenCentral()&#10;    &#125;&#10;    dependencies &#123;&#10;        classpath &#39;com.android.tools.build:gradle:2.3.0&#39;&#10;        classpath &#39;ivonhoe.gradle.dexguard:dexguard-gradle:0.0.2-SNAPSHOT&#39;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在app项目的build.gradle中添加插件，map.txt中配置需要保护的方法名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;ivonhoe.dexguard&#39;&#10;dexguard &#123;&#10;    guardConfig = &#34;$&#123;rootDir&#125;/map.txt&#34;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="七、参考文档">七、参考文档</h3><ul>
<li><a href="https://sourceforge.net/p/dex2jar/tickets/238/" target="_blank" rel="external">#238 java.lang.RuntimeException: can not merge I and Z</a></li>
<li><a href="http://www.jianshu.com/p/730c6e3e21f6" target="_blank" rel="external">Smali语法</a></li>
<li><a href="http://blog.csdn.net/sbsujjbcy/article/details/50839263" target="_blank" rel="external">Android 热修复使用Gradle Plugin1.5改造Nuwa插件</a></li>
<li><a href="http://www.wangyuwei.me/2017/01/20/ASM-%E6%93%8D%E4%BD%9C%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%9D%E6%8E%A2/" target="_blank" rel="external">ASM-操作字节码初探</a></li>
<li><a href="https://www.diycode.cc/topics/581" target="_blank" rel="external">手摸手增加字节码往方法体内插代码</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、反编译某平台代码&quot;&gt;一、反编译某平台代码&lt;/h3&gt;&lt;p&gt;最近在看某外卖平台的代码，发现某外卖平台最新版本版本无法正常的通过dex2jar工具将dex转换出Java源代码，在转换过程中会提示出错，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ivonhoe.github.io/res/dex2jar_error/dex2jar_error1.png&quot; alt=&quot;dex2jar异常图&quot;&gt;&lt;/p&gt;
&lt;p&gt;查看转换出的Java源代码，会发现很多类方法提示下图所示异常，很多方法中都会抛出&lt;code&gt;RuntimeException：can not merge I and Z&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class AsyncTaskService extends IntentService &amp;#123; &amp;#10;  &amp;#10;  protected void onHandleIntent(Intent paramIntent)&amp;#123;&amp;#10;    throw new RuntimeException(&amp;#34;d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat...);&amp;#10;  &amp;#125;&amp;#10;  &amp;#10;  public int onStartCommand(Intent paramIntent, int paramInt1, int paramInt2)&amp;#123;&amp;#10;    throw new RuntimeException(&amp;#34;d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat...&amp;#34;);&amp;#10;  &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Gradle" scheme="https://ivonhoe.github.io/tags/Gradle/"/>
    
      <category term="dex2jar" scheme="https://ivonhoe.github.io/tags/dex2jar/"/>
    
      <category term="移动安全" scheme="https://ivonhoe.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android安全之---APP去广告</title>
    <link href="https://ivonhoe.github.io/2017/02/04/Android%E5%AE%89%E5%85%A8%E4%B9%8B---APP%E5%8E%BB%E5%B9%BF%E5%91%8A/"/>
    <id>https://ivonhoe.github.io/2017/02/04/Android安全之---APP去广告/</id>
    <published>2017-02-04T05:27:20.000Z</published>
    <updated>2017-03-09T03:38:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、工具介绍">一、工具介绍</h3><ul>
<li><strong>apktool：</strong>google提供Android apk编译与反编译工具，<a href="https://ibotpeaches.github.io/Apktool/" target="_blank" rel="external">https://ibotpeaches.github.io/Apktool/</a></li>
<li><strong>dex2jar：</strong>dex文件转jar文件工具，<a href="https://github.com/pxb1988/dex2jar" target="_blank" rel="external">https://github.com/pxb1988/dex2jar</a></li>
<li><strong>jd-gui：</strong>查看jar文件，<a href="http://jd.benow.ca/" target="_blank" rel="external">http://jd.benow.ca/</a></li>
<li><strong>keytool：</strong>制作和管理数字证书</li>
<li><strong>jarsigner：</strong>使用数字证书对jar和apk进行签名</li>
<li><strong>Android killer：</strong>Window系统中，上述工具的集成工具</li>
</ul>
<p>更多反编译工具可查看：<a href="http://unclechen.github.io/2016/09/07/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" target="_blank" rel="external">Uncle Chen—Android反编译技术总结</a></p>
<h3 id="二、去除应用开发助手的广告">二、去除应用开发助手的广告</h3><p>CodeKK公众号在17年初推出了一个<a href="https://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=2654472664&amp;idx=1&amp;sn=dfc2b5beb90daa8fd068d8064ce0dcce&amp;chksm=803bfaecb74c73fa9a9addfd4d8bce031186c34b7d7b59ee22df41799c7eaa71a34863890f56&amp;mpshare=1&amp;scene=1&amp;srcid=0220tEQNaL7PwIgfBT8sIITK&amp;key=776fc8cdd0b88c0d0b9a6c8e271e4cfe2b2363aeda110198d4250b0a422befd0f43f78e2a17d528112f757336e136c56f488bc174baa56c116045a9bdbb37dbccf508eb8c70e48a2d09ca1da1b4d92d3&amp;ascene=0&amp;uin=MTMzNzYxMDM2MQ%3D%3D&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.12.1+build(16B2555" target="_blank" rel="external">应用开发助手</a>)。V1.0版本是有广告版本的，下面以这个版本为例，简单看下去广告过程。它的后续的V1.1.0和V1.2.0已经去除了广告功能。</p>
<a id="more"></a>
<h4 id="2-1、反编译">2.1、反编译</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool.sh d -f ./dev-tools.apk</span><br></pre></td></tr></table></figure>
<p><img src="/res/dev-tool/dev-tool1.png" alt=""><br><img src="/res/dev-tool/dev-tool2.png" alt=""></p>
<h4 id="2-2、注释广告代码">2.2、注释广告代码</h4><p>这里可以先用dex2jar转jar后查看下源码，会发现使用的是Google AdMob作为广告平台，简单看下代码可以发现在主页面activty_main.xml中包含广告视图的布局文件。所以只需要找到<code>ad_layout.xml</code>将其<code>android:visibility=&quot;gone&quot;</code>属性设置成<code>gone</code>就可以了。</p>
<p><img src="/res/dev-tool/dev-tool3.png" alt=""></p>
<h4 id="2-3、重打包">2.3、重打包</h4><p>这里重打包的过程可能会遇到一些错误，不过认真查看日志并结合Google都是可以找到解决方案的，这里暂且不表。使用apktool b命令，生成的apk默认路径为<code>/dist</code>路径下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool.sh b ./dev-tools</span><br></pre></td></tr></table></figure>
<p><img src="/res/dev-tool/dev-tool4.png" alt=""></p>
<h4 id="2-4、制作一个名为hackapk-keystore的证书,并重新签名应用">2.4、制作一个名为hackapk.keystore的证书,并重新签名应用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#21046;&#20316;&#35777;&#20070;&#65306;&#10;keytool -genkey -keystore hackapk.keystore -keyalg RSA -validity 10000 -alias hackapk&#10;&#10;&#31614;&#21517;&#65306;&#10;jarsigner -verbose -keystore hackapk.keystore -signedjar dev-tools-no-ads.apk ./dev-tools/dist/dev-tools.apk hackapk</span><br></pre></td></tr></table></figure>
<p><img src="/res/dev-tool/dev-tool5.png" alt=""></p>
<p>详细的参数可以参考：<br><a href="http://www.tttabc.com/android/keytool-keystore-jarsigner-apk.htm" target="_blank" rel="external">APK签名之keytool生成keystore和jarsigner签名apk</a></p>
<h4 id="2-5、安装">2.5、安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install -r dev-tools-no-ads.apk</span><br></pre></td></tr></table></figure>
<p><img src="/res/dev-tool/dev-tool6.png" alt=""></p>
<p><img src="/res/dev-tool/dev-tool11.png" alt="有广告版本"></p>
<p><img src="/res/dev-tool/dev-tool10.png" alt="无广告版本"></p>
<h4 id="2-6、下载去广告版本的应用开发助手">2.6、下载去广告版本的应用开发助手</h4><p><img src="/res/dev-tool/dev-tool7.png" alt=""></p>
<h3 id="三、反编译脚本">三、反编译脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh&#10;workDir=./&#10;if [ &#34;$2&#34; ]&#10;then&#10;         mkdir $2&#10;         workDir=./$2/&#10;fi&#10;&#10;echo $workDir&#10;name=`basename $1 .apk`&#10;zipPath=$workDir$name.zip&#10;&#10;##apkTool&#21453;&#32534;&#35793;&#10;smaliDir=$workDir$name@smali&#10;apktool.sh d -f $1 -o $smaliDir&#10;&#10;## &#35299;&#21387;&#32553;&#65292;&#20351;&#29992;dex2jar&#22788;&#29702;&#10;unzipDir=$workDir$name@unzip&#10;cp $1 $zipPath&#10;unzip $zipPath -d $unzipDir&#10;&#10;d2j-dex2jar.sh -f $unzipDir/classes.dex -o $&#123;workDir&#125;dex2jar.jar&#10;d2j-dex2jar.sh -f $unzipDir/classes2.dex -o $&#123;workDir&#125;dex2jar2.jar&#10;d2j-dex2jar.sh -f $unzipDir/classes3.dex -o $&#123;workDir&#125;dex2jar3.jar&#10;open $workDir</span><br></pre></td></tr></table></figure>
<p>将上述内容保存到本地<code>hack.sh</code>文件中，使用下面的命令就会把apktool和dex2jar的结果输出到<code>meipu</code>这个目录中，这样就不需要每次收到敲命令喽，只要知道需要反编译的apk和输出的文件夹名称就可以~</p>
<p><code>./hack.sh ./美铺_1487845975713.apk meipu</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、工具介绍&quot;&gt;一、工具介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;apktool：&lt;/strong&gt;google提供Android apk编译与反编译工具，&lt;a href=&quot;https://ibotpeaches.github.io/Apktool/&quot;&gt;https://ibotpeaches.github.io/Apktool/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dex2jar：&lt;/strong&gt;dex文件转jar文件工具，&lt;a href=&quot;https://github.com/pxb1988/dex2jar&quot;&gt;https://github.com/pxb1988/dex2jar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;jd-gui：&lt;/strong&gt;查看jar文件，&lt;a href=&quot;http://jd.benow.ca/&quot;&gt;http://jd.benow.ca/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;keytool：&lt;/strong&gt;制作和管理数字证书&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;jarsigner：&lt;/strong&gt;使用数字证书对jar和apk进行签名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Android killer：&lt;/strong&gt;Window系统中，上述工具的集成工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多反编译工具可查看：&lt;a href=&quot;http://unclechen.github.io/2016/09/07/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/&quot;&gt;Uncle Chen—Android反编译技术总结&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、去除应用开发助手的广告&quot;&gt;二、去除应用开发助手的广告&lt;/h3&gt;&lt;p&gt;CodeKK公众号在17年初推出了一个&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;amp;mid=2654472664&amp;amp;idx=1&amp;amp;sn=dfc2b5beb90daa8fd068d8064ce0dcce&amp;amp;chksm=803bfaecb74c73fa9a9addfd4d8bce031186c34b7d7b59ee22df41799c7eaa71a34863890f56&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0220tEQNaL7PwIgfBT8sIITK&amp;amp;key=776fc8cdd0b88c0d0b9a6c8e271e4cfe2b2363aeda110198d4250b0a422befd0f43f78e2a17d528112f757336e136c56f488bc174baa56c116045a9bdbb37dbccf508eb8c70e48a2d09ca1da1b4d92d3&amp;amp;ascene=0&amp;amp;uin=MTMzNzYxMDM2MQ%3D%3D&amp;amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.12.1+build(16B2555&quot;&gt;应用开发助手&lt;/a&gt;)。V1.0版本是有广告版本的，下面以这个版本为例，简单看下去广告过程。它的后续的V1.1.0和V1.2.0已经去除了广告功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="去广告" scheme="https://ivonhoe.github.io/tags/%E5%8E%BB%E5%B9%BF%E5%91%8A/"/>
    
      <category term="移动安全" scheme="https://ivonhoe.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS上编译Android源码</title>
    <link href="https://ivonhoe.github.io/2017/01/20/MacOS%E4%B8%8A%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81/"/>
    <id>https://ivonhoe.github.io/2017/01/20/MacOS上编译Android源码/</id>
    <published>2017-01-20T14:16:46.000Z</published>
    <updated>2017-02-21T10:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、制作一个大小写敏感的磁盘分区">一、制作一个大小写敏感的磁盘分区</h3><h4 id="1-1-Mac_OS磁盘工具">1.1.Mac OS磁盘工具</h4><p>这里我使用一块移动硬盘，将移动硬盘的一个分区使用Mac OS的硬盘工具，抹掉数据，选择MacOS扩展(区分大小写，日志式)，创建成大小写敏感的分区。</p>
<p><img src="/res/compile_android_source/android-source-disk1.jpeg" alt=""></p>
<p>这里会遇到一个问题，抹掉分区数据的时候，<code>会报错：“Mac OSX 抹盘发生错误:Mediakit 报告设备上空间不足以执行此操作”</code>，这里的原因是磁盘没有大于200M的UEFI分区。</p>
<a id="more"></a>
<h4 id="1-2-制作UEFI分区">1.2.制作UEFI分区</h4><blockquote>
<p>我是在windows上操作的，<br>使用DiskGenius工具，在移动硬盘的第一分区前部，划分出200MB的空间。<br>在cmd命令行下运行下列命令,记得分步执行啊，小心出错，数据无价。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskpart&#10;list disk&#10;select disk 1 ###&#36825;&#37324;&#36873;&#20013;&#35201;&#20998;&#21306;&#30340;&#30913;&#30424;&#65292;&#22240;&#20026;&#25105;&#26159;&#31227;&#21160;&#30828;&#30424;&#65292;index&#26159;1&#65292;&#36825;&#37324;&#24212;&#35813;&#20250;&#30475;&#21040;&#36873;&#25321;&#20809;&#26631;&#19981;&#35201;&#36873;&#38169;&#20102;&#10;&#10;create partition efi size=200</span><br></pre></td></tr></table></figure>
<p>详细的图文请参考:</p>
<p><a href="https://blog.zzzmode.com/2016/05/02/osx-mediakit-reports-partition-map-too-small/" target="_blank" rel="external">Mac OSX 抹盘发生错误:Mediakit 报告设备上空间不足以执行此操作的解决办法
</a></p>
<h3 id="二、下载Android源码">二、下载Android源码</h3><h4 id="2-1-repo_sync_出错">2.1.repo sync 出错</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: RPC failed; result=56, HTTP code = 200&#60;br&#62;&#10;fatal: The remote end hung up unexpectedly&#60;br&#62;&#10;fatal: early EOF&#60;br&#62;&#10;fatal: index-pack failed</span><br></pre></td></tr></table></figure>
<p>repo sync时会出现如上错误，安装<code>gnutls</code>和<code>wget</code>后,<br>并参考<a href="http://stackoverflow.com/questions/6842687/the-remote-end-hung-up-unexpectedly-while-git-cloning" target="_blank" rel="external">stackoverflow</a>解决。</p>
<h4 id="2-2-如何选择驱动">2.2.如何选择驱动</h4><p><a href="https://source.android.com/source/build-numbers.html#source-code-tags-and-builds" target="_blank" rel="external">Source Code Tags and Builds</a></p>
<p><img src="/res/compile_android_source/android-source2.jpeg" alt=""></p>
<p><a href="https://developers.google.com/android/drivers" target="_blank" rel="external">Android原生设备驱动</a><br><img src="/res/compile_android_source/android-source3.jpeg" alt=""></p>
<p>详细的图文请参考:</p>
<p><a href="http://wl9739.github.io/2016/05/09/Android%E6%BA%90%E7%A0%81%E7%9A%84%E4%B8%8B%E8%BD%BD%E3%80%81%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AF%BC%E5%85%A5%E5%88%B0Android-Studio/" target="_blank" rel="external">Android源码的下载、编译与导入到Android Studio</a></p>
<p><a href="http://www.jianshu.com/p/1c3d47b2031f" target="_blank" rel="external">Mac OS X下编译Android M源码</a></p>
<h3 id="三、编译">三、编译</h3><p><code>一定要下载并安装驱动，下载nexus5 6.0.1_r17版本为例，需要下载执行下图三个sh</code></p>
<p><img src="/res/compile_android_source/android-source4.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$chmod a+x ./*****.sh&#10;$./*****.sh&#10;&#10;&#36755;&#20837;I ACCEPT&#23436;&#25104;&#23433;&#35013;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$source build/envsetup.sh&#10;&#10;$lunch&#10;&#10;$make -j16</span><br></pre></td></tr></table></figure>
<h3 id="四、如何将编译好的Android_img刷入模拟器">四、如何将编译好的Android img刷入模拟器</h3><p>需要设置<code>ANDROID_PRODUCT_OUT</code>变量到<code>~/.bash_profile</code>文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Android &#28304;&#30721;&#32534;&#35793;&#30446;&#24405;&#10;export PATH=$PATH:/Volumes/AOSP/android-6.0.1_r17-x86_64/out/host/darwin-x86/bin&#10;export ANDROID_PRODUCT_OUT=/Volumes/AOSP/android-6.0.1_r17-x86_64/out/target/product/generic_x86_64&#10;export PATH=$PATH:$ANDROID_PRODUCT_OUT</span><br></pre></td></tr></table></figure>
<p>使用命令启动emulator，加载指定的kernel内核和img</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kans-MacBook-Pro:android-6.0.1_r17-x86_64 Ivonhoe$&#10;emulator -kernel  /Volumes/AOSP/android-6.0.1_r17-x86_64/prebuilts/qemu-kernel/x86_64/kernel-qemu -sysdir ./out/target/product/generic_x86_64/ -system /Volumes/AOSP/android-6.0.1_r17-x86_64/out/target/product/generic_x86_64/system.img -data /Volumes/AOSP/android-6.0.1_r17-x86_64/out/target/product/generic_x86_64/userdata.img -ramdisk /Volumes/AOSP/android-6.0.1_r17-x86_64/out/target/product/generic_x86_64/ramdisk.img</span><br></pre></td></tr></table></figure>
<p>参考老罗的博客<a href="http://blog.csdn.net/luoshengyang/article/details/6559955" target="_blank" rel="external">在Ubuntu上下载、编译和安装Android最新源代码</a></p>
<h3 id="五、刷入Nexus6真机">五、刷入Nexus6真机</h3><p>Nexus6关机状态下,长按音量下+电源,进入recovery模式</p>
<p>然后在源码根目录下(Android根目录下)执行下面命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot -w flashall</span><br></pre></td></tr></table></figure>
<p><img src="/res/compile_android_source/android-source5.png" alt=""></p>
<p>使用<code>mmm framework/base</code>单独编译framework代码</p>
<p>adb push可能会提示 <code>Read-only file system</code></p>
<p><code>failed to copy &#39;out/target/product/shamu/system/framework/framework.jar&#39;
 to &#39;/system/framework/framework.jar&#39;: Read-only file system</code></p>
<p>通过下列命令解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb root&#10;adb remount&#10;adb disable-verity&#10;adb reboot&#10;adb root&#10;adb remount</span><br></pre></td></tr></table></figure>
<h3 id="六、参考文档">六、参考文档</h3><p><a href="http://blog.csdn.net/ljphhj/article/details/51512263" target="_blank" rel="external">Android系统源码下载与编译、刷机–Nexus6实测</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、制作一个大小写敏感的磁盘分区&quot;&gt;一、制作一个大小写敏感的磁盘分区&lt;/h3&gt;&lt;h4 id=&quot;1-1-Mac_OS磁盘工具&quot;&gt;1.1.Mac OS磁盘工具&lt;/h4&gt;&lt;p&gt;这里我使用一块移动硬盘，将移动硬盘的一个分区使用Mac OS的硬盘工具，抹掉数据，选择MacOS扩展(区分大小写，日志式)，创建成大小写敏感的分区。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/res/compile_android_source/android-source-disk1.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里会遇到一个问题，抹掉分区数据的时候，&lt;code&gt;会报错：“Mac OSX 抹盘发生错误:Mediakit 报告设备上空间不足以执行此操作”&lt;/code&gt;，这里的原因是磁盘没有大于200M的UEFI分区。&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码编译" scheme="https://ivonhoe.github.io/tags/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Mac/Linux下gcc编译动态链接库[.so文件]</title>
    <link href="https://ivonhoe.github.io/2016/12/16/Mac-Linux%E4%B8%8Bgcc%E7%BC%96%E8%AF%91%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93-so%E6%96%87%E4%BB%B6/"/>
    <id>https://ivonhoe.github.io/2016/12/16/Mac-Linux下gcc编译动态链接库-so文件/</id>
    <published>2016-12-16T05:47:55.000Z</published>
    <updated>2017-02-09T10:03:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、以bsdiff-c和bspatch-c为例编译bsdiff-so">一、以bsdiff.c和bspatch.c为例编译bsdiff.so</h2><p>bsdiff.c和bspatch.c分别依赖bzip2</p>
<h3 id="项目结构">项目结构</h3><h3 id="步骤">步骤</h3><ul>
<li><p>使用BsDiff.java生成BsDiff.class文件</p>
<p><strong>javac</strong> ivonhoe/spring/wrcenter/jni/BsDiff.java</p>
</li>
<li><p>生成BsDiff.h文件</p>
<p><strong>javah</strong> ivonhoe.spring.wrcenter.jni.BsDiff </p>
</li>
<li><p>生成bspatch.o</p>
<a id="more"></a>
<p><strong>gcc -fPIC -D_REENTRANT</strong> -I<strong>JAVA_INCLUDE1</strong> -I/JAVA_INCLUDE2/ -I/Users/Ivonhoe/Downloads/VelocityDemo/src/main/java/jni/bzip2 -I/Users/Ivonhoe/Downloads/VelocityDemo/src/main/java/jni -c ./jni/bspatch.c</p>
</li>
<li><p>生成bsdiff.o</p>
<p><strong>gcc -fPIC -D_REENTRANT</strong> -I/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/include/darwin -I/Users/Ivonhoe/Downloads/VelocityDemo/src/main/java/jni/bzip2 -I/Users/Ivonhoe/Downloads/VelocityDemo/src/main/java/jni -c ./jni/bsdiff.c</p>
</li>
<li><p>将bzip2下的c文件生成相应的.o文件</p>
<p><strong>gcc -fPIC -D_REENTRANT</strong> -I/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/include/darwin -I/Users/Ivonhoe/Downloads/VelocityDemo/src/main/java/jni/bzip2 -c ./jni/bzip2/*.c</p>
</li>
<li><p>生成so文件</p>
<p><strong>gcc *.o -o bsdiff.so -shared  -v</strong></p>
</li>
</ul>
<ul>
<li>注:</li>
</ul>
<p>  JAVA_INCLUDE1:/usr/local/java/jdk1.7.0_40/include<br>  JAVA_INCLUDE2:/usr/local/java/jdk1.7.0_40/include/linux<br>  是 jdk 中的 jni.h 文件的所在目录，这两个目录需要大家替换为自己的对应路径</p>
<p>  BZIP2_INCLUDE:</p>
<p>参考文档：<br><a href="http://www.cppblog.com/deane/articles/165216.html" target="_blank" rel="external">http://www.cppblog.com/deane/articles/165216.html</a><br><a href="http://blog.csdn.net/hongquan1991/article/details/12426615" target="_blank" rel="external">http://blog.csdn.net/hongquan1991/article/details/12426615</a><br><a href="http://codepub.cn/2015/05/19/How-to-load-dll-file-in-Java-Web-Project/" target="_blank" rel="external">http://codepub.cn/2015/05/19/How-to-load-dll-file-in-Java-Web-Project/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、以bsdiff-c和bspatch-c为例编译bsdiff-so&quot;&gt;一、以bsdiff.c和bspatch.c为例编译bsdiff.so&lt;/h2&gt;&lt;p&gt;bsdiff.c和bspatch.c分别依赖bzip2&lt;/p&gt;
&lt;h3 id=&quot;项目结构&quot;&gt;项目结构&lt;/h3&gt;&lt;h3 id=&quot;步骤&quot;&gt;步骤&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用BsDiff.java生成BsDiff.class文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;javac&lt;/strong&gt; ivonhoe/spring/wrcenter/jni/BsDiff.java&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成BsDiff.h文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;javah&lt;/strong&gt; ivonhoe.spring.wrcenter.jni.BsDiff &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成bspatch.o&lt;/p&gt;
    
    </summary>
    
    
      <category term="动态链接库" scheme="https://ivonhoe.github.io/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>[转载]如何写出GC友好的Android应用</title>
    <link href="https://ivonhoe.github.io/2015/10/25/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BAGC%E5%8F%8B%E5%A5%BD%E7%9A%84Android%E5%BA%94%E7%94%A8/"/>
    <id>https://ivonhoe.github.io/2015/10/25/如何写出GC友好的Android应用/</id>
    <published>2015-10-25T13:21:23.000Z</published>
    <updated>2015-11-08T04:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者：乐蛙科技高级研发经理 易宁</p>
<p>Android应用普遍没有iOS应用流畅，这与Android应用是运行在Java虚拟机上有很大的关系，而关系最大的恐怕就是Java虚拟机上的Garbage Collection（GC）了。Java语言提供了自动内存管理，垃圾对象会在GC过程中自动被释放。这提供了开发效率，使开发者能集中精力在业务逻辑上；但天下没有免费的午餐，你写的Android应用的某些性能上的问题很可能就是GC导致的。</p>
<p>下面是一段非常简单的Java语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span> * <span class="number">512</span> * <span class="number">4</span>];</span><br></pre></td></tr></table></figure></p>
<p>这条语句申请了一块大小相等于512*512大小图片的内存。执行这条语句会消耗多少时间呢？0+ms吗？基本没有性能影响吗？</p>
<a id="more"></a>
<p>实际的情况是：0~200ms，甚至更多！这取决于应用当前Heap使用情况。在一个类似Hello World的测试程序里，执行这条语句有时候只需要0+ms就完成了，但一般情况是16+ms，甚至有时候需要30+ms。我们知道一段流畅的动画每帧绘图消耗的时间应该小于16ms，因为这样才能保证动画有60FPS的帧率。但如果执行上面那句简单的语句就要错过1~2帧，那就难怪动画不流畅了。</p>
<p>不过，有人可能要说了：“没人会傻到在每帧绘图的时候去申请一块这么大的内存，实际情况不会有这个问题”。实际的工程中的确不会这么写，但造成执行这条语句耗时比较长的原因不是因为申请的内存太大，而是申请过程中产生了GC，就算是一个Byte的内存申请也可能消耗比这更长的时间。</p>
<h3 id="Dalvik中GC的原理">Dalvik中GC的原理</h3><p>在Dalvik虚拟机中定义了四种触发GC的条件（参看<a href="http://androidxref.com/4.2.2_r1/xref/dalvik/vm/alloc/Heap.h" target="_blank" rel="external">Heap.h</a>）：</p>
<blockquote>
<ul>
<li><code>GC_CONCURRENT</code>，当Heap的使用率达到某一阈值时自动触发。</li>
<li><code>GC_FOR_MALLOC</code>，当Heap没有足够的空间用于容下新创建的对象时。</li>
<li><code>GC_EXPLICIT</code>，用户主动调用GC时。</li>
<li><code>GC_BEFORE_OOM</code>，当要发生OOM时系统尝试进行最后GC的努力。</li>
</ul>
</blockquote>
<p><code>GC_CONCURRENT</code>和<code>GC_EXPLICIT</code>是并行的，GC过程中应用不会被暂停，只在GC开始和结束时会暂停应用，每次暂停的时间比较短，一般只有3~4ms。<code>GC_FOR_MALLOC</code>是非并行的，GC过程中应用被暂停，耗时比较长，可能几十毫秒也可能几百毫秒。在应用向Dalvik申请内存时，Dalvik先检查当前Heap中有无足够的空余空间用来安排对象，当发现没有足够的空间的时候会先进行<code>GC_FOR_MALLOC</code>以试图释放垃圾对象来获取新的空间，如果发现空间还不够则进行Heap的增长。在每次成功分配完新的空间后，Dalvik会检查当前Heap的使用情况，如果使用空间超过一定的阈值的时候，<code>GC_CONCURRENT</code>就会触发。</p>
<p>每次GC的时候会打印如下的Log信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/dalvikvm(10497): GC_CONCURRENT freed 2940K, 54% free 2885K/6204K, paused 1ms+4ms&#65292; total 38ms</span><br></pre></td></tr></table></figure>
<p>上面的Log信息表明：这次<code>GC_CONCURRENT</code>释放了2940K的空间，当前Heap使用率为54%，总的Heap大小是6204K，空余2885K，GC开始时暂停了1ms，GC结束时暂停了4ms，GC总共花了38ms。</p>
<p>Dalvik虚拟机通过下面几个个属性值来控制Heap的空间配置：</p>
<blockquote>
<ul>
<li><code>targetUtilization</code>，理想的Heap利用率，每当Heap增长时Dalvik会使增长后的Heap维持在这个利用率附近。</li>
<li><code>minFree</code>，空余空间最小值。</li>
<li><code>maxFree</code>，空余空间最大值。</li>
<li><code>startSize</code>，虚拟机启动时初始的Heap大小。</li>
<li><code>growthLimit</code>，用户设置的允许的最大Heap大小。</li>
<li><code>maximumSize</code>， Heap空间最大极限值。</li>
</ul>
</blockquote>
<p>这些属性值都可以通过<code>system/build.prop</code>来配置，zygote启动dalvik虚拟机时会从该文件中读取这些参数。通常来说，Heap空余空间越大应用越流畅，消耗的内存也更多。</p>
<p>下图为一次“顺利”的4M内存申请:<br><img src="/res/dalvik_gc/1.png" alt="Alt text"><br>可以看到在申请之前，空余的空间达到8M，申请4M的内存很顺利没有任何GC发生。</p>
<p>下图为一次“不顺利”的8M内存申请：<br><img src="/res/dalvik_gc/2.png" alt="Alt text"><br>虽然空余的空间已经有8M，但是为了保证正常的Heap利用率，Heap空间还是增长了，并且增长Heap之前进行了一次<code>GC_FOR_MALLOC</code>。</p>
<p>下图为继续申请8M的内存：<br><img src="/res/dalvik_gc/3.png" alt="Alt text"><br>相应的输出Log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/dalvikvm&#65109; GC_FOR_ALLOC freed 8195K, 34% free 16726K/24972K, paused 23ms, total 23ms</span><br></pre></td></tr></table></figure></p>
<p>上图和Log更加清晰的表明Heap空间不够时会先进行一次GC，GC的类型就是<code>GC_FOR_MALLOC</code>。</p>
<h3 id="Android流畅的关键：GC_FOR_MALLOC">Android流畅的关键：<code>GC_FOR_MALLOC</code></h3><p><code>GC_CONCURRENT</code>和<code>GC_FOR_MALLOC</code>虽然都是系统自动调用的，都暂停了应用，但它们花费的时间不在一个数量级。通过上面的分析我们知道每次申请内存空间不够时就会产生<code>GC_FOR_MALLOC</code>，我们不可能不申请内存，所以也不可能完全避免<code>GC_FOR_MALLOC</code>，但还是有些策略能降低<code>GC_FOR_MALLOC</code>的影响：</p>
<ol>
<li><p>避免不必要的<code>GC_FOR_MALLOC</code></p>
<blockquote>
<ul>
<li>Heap空间都有其理想的利用率，在理想的利用空间内，申请内存是不会发生<code>GC_FOR_MALLOC</code>。</li>
<li>应用应该避免内存开销的波动，将内存的波动维持在<code>maxFree</code>和<code>mixFree</code>之间。</li>
<li>避免大的内存需求。比如，不要轻易去用<code>WallpaperManager</code>，因为壁纸占用巨大的内存。</li>
<li>应该尽量复用对象。比如，使用<code>BitmapFactory</code>加载图片时使用<code>BitmapFactory.Option.inBitmap</code>复用Bitmap，避免申请内存。</li>
<li>对于已知有垃圾对象的情况下，先进行手动的<code>System.gc()</code>来释放空间，而不是等到系统自动调用<code>GC_FOR_MALLOC</code>。因为<code>GC_EXPLICIT</code>是异步的，暂停应用的时间远小于<code>GC_FOR_MALLOC</code>。</li>
<li>不要在循环中申请创建对象。循环中申请的对象会不断累积，直到空间不够发生<code>GC_FOR_MALLOC</code>。</li>
</ul>
</blockquote>
</li>
<li><p>减少<code>GC_FOR_MALLOC</code>的影响</p>
<blockquote>
<ul>
<li>不要在Android应用运行的关键阶段申请内存。比如，不要在<code>onDraw</code>, <code>onLayout</code>, <code>onXXX</code>中创建对象。在关键阶段创建对象可能使应用出现随机性卡顿。</li>
<li>尽量在<code>onCreate</code>和<code>onStart</code>阶段创建对象，同时在<code>onStop</code>和<code>onDestroy</code>阶段释放对象。</li>
<li>尽量复用<code>ListView</code>中Item，在<code>ListView</code>滑动时不要创建对象。</li>
</ul>
</blockquote>
</li>
<li><p>降低每次<code>GC_FOR_MALLOC</code>的时间消耗</p>
<blockquote>
<ul>
<li>避免大量的，细小的对象。这些对象会增加Heap空间的复杂度，在GC时会严重影响GC的耗时。</li>
<li>对于不用的对象近早将其引用消除，减少Heap空间占用和复杂度。</li>
<li>尽量用数据结构，数组来组织对象。</li>
<li>明确对象之间的关系，使对象之间的依赖关系简单明了。</li>
<li>减少View的数量。每个View包含大量属性，对于没有交互的View，大多数的属性都是没有用的，可以用Drawable替代。</li>
</ul>
</blockquote>
</li>
</ol>
<p><em>需要注意的是</em>：本文讨论的只限于Dalvik虚拟机。对于Art虚拟机，<a href="https://developer.android.com/guide/practices/verifying-apps-art.html#GC_Migration" target="_blank" rel="external">官方文档</a>已经表明Art虚拟机有极大的改进，其中就特别提到<strong>不用</strong>主动调用<code>System.gc()</code>来避免产生<code>GC_FOR_MALLOC</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：乐蛙科技高级研发经理 易宁&lt;/p&gt;
&lt;p&gt;Android应用普遍没有iOS应用流畅，这与Android应用是运行在Java虚拟机上有很大的关系，而关系最大的恐怕就是Java虚拟机上的Garbage Collection（GC）了。Java语言提供了自动内存管理，垃圾对象会在GC过程中自动被释放。这提供了开发效率，使开发者能集中精力在业务逻辑上；但天下没有免费的午餐，你写的Android应用的某些性能上的问题很可能就是GC导致的。&lt;/p&gt;
&lt;p&gt;下面是一段非常简单的Java语句：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] data = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;512&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;512&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这条语句申请了一块大小相等于512*512大小图片的内存。执行这条语句会消耗多少时间呢？0+ms吗？基本没有性能影响吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="Delvik" scheme="https://ivonhoe.github.io/tags/Delvik/"/>
    
      <category term="GC" scheme="https://ivonhoe.github.io/tags/GC/"/>
    
      <category term="转载" scheme="https://ivonhoe.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Android动画总结之有赞、邮箱大师进度条实现原理</title>
    <link href="https://ivonhoe.github.io/2015/09/01/Android%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%E4%B9%8B%E6%9C%89%E8%B5%9E%E3%80%81%E9%82%AE%E7%AE%B1%E5%A4%A7%E5%B8%88%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://ivonhoe.github.io/2015/09/01/Android动画总结之有赞、邮箱大师进度条实现原理/</id>
    <published>2015-09-01T15:17:29.000Z</published>
    <updated>2017-02-09T10:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、效果">一、效果</h2><p><img src="/res/android_animation2/xiaoguo.gif" alt=" "></p>
<h2 id="二、有赞加载进度条">二、有赞加载进度条</h2><p>四个正方形的运动可以分解成两个分运动，一个是平移运动，一个是自身的旋转运动。在实现这个动画上有两个思路：</p>
<ul>
<li>一个是通过Android提供的Animation或者Animator操作视图，让一个正方形的视图在translate动画的同时进行rotate动画，只需要设置rotate动画的pivot坐标为视图的中心点就可以了。</li>
<li>另一个是直接在canvas上绘制正方形，通过canvas的坐标变换实现动画。</li>
</ul>
<a id="more"></a>
<p>下面主要说第二种方式的原理：</p>
<ul>
<li><p>平移：平移canvas，在平行与手机屏幕的平面坐标系中，水平向右方向为X轴，竖直向下方向为Y轴，把原点平移到视图的中心点，只需要在水平和竖直的正方向平移就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.translate(mBounds.width() / 2, mBounds.height() / 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>旋转：想要完成一个矩形围绕其中心点顺时针旋转一个角度，首先要意识到旋转的过程中，只改变了坐标系的方向并没有改变坐标系的原点位置。换句话说，如果你需要围绕坐标系原点做旋转，那么你只需要旋转操作，如果你需要围绕除了原点以外的另外一个点（比如当前现在正方形的中心点），那么你需要先做平移操作，先把坐标系平移到一个正确的点在做旋转操作。如图所示：<br><img src="/res/android_animation2/xuanzhuanzuobiao.png" alt=" "></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.translate((float) (x + (1 - 1.414f * Math.sin((45 - degree) / 180f * Math.PI)) * halfLength),(float) (y - (1.414f * Math.cos((45 - degree) / 180f * Math.PI) - 1) * halfLength));&#10;canvas.rotate(degree);&#10;drawable.draw(canvas);</span><br></pre></td></tr></table></figure>
<ul>
<li>动画插值：可以看到，每个正方形的平移运动周期是从起始点回到起始点，在时间的中点上达到平移的最大值。反应在平面坐标中的情况就是，一条通过(0, 0), (0.5, 1),(1, 0)三点，在(0.5, 1)达到最大值的一元二次方程。可以间接得到这个插值器是：<br><img src="/res/android_animation2/chazhiqi.jpg" alt=" "></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#36807;&#65288;0,0&#65289;&#65292;&#65288;0.5,1&#65289;&#65292;&#65288;1,0&#65289;&#30340;&#19968;&#20803;&#20108;&#27425;&#26041;&#31243;&#10;Interpolator mInterpolator = new Interpolator() &#123;&#10;    @Override&#10;    public float getInterpolation(float input) &#123;&#10;        return -4 * input * input + 4 * input;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三、网易邮箱大师加载进度条">三、网易邮箱大师加载进度条</h2><p>圆弧的动画需要分解成四个分动画：</p>
<ul>
<li>画笔宽度变化：绘制圆弧的画笔宽度在动画</li>
<li>圆弧长度变化：绘制圆弧的长度在动画</li>
<li>旋转变化：绘制每段圆弧的起点在动画</li>
<li>圆弧半径变化：绘制圆弧的半径在动画</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ObjectAnimator[] getAtomAnimator(Atom atom, Rect bound) &#123;&#10;    ObjectAnimator[] result = new ObjectAnimator[4];&#10;    result[0] = ObjectAnimator.ofFloat(atom, &#34;delta&#34;, 4f, 9f);&#10;    result[0].setInterpolator(mPaintInterpolator);&#10;    switch (atom.getId()) &#123;&#10;        case 0:&#10;            result[1] = ObjectAnimator.ofInt(atom, &#34;rotate&#34;, 0, 360);&#10;            break;&#10;        case 1:&#10;            result[1] = ObjectAnimator.ofInt(atom, &#34;rotate&#34;, 120, 480);&#10;            break;&#10;        case 2:&#10;            result[1] = ObjectAnimator.ofInt(atom, &#34;rotate&#34;, 240, 600);&#10;            break;&#10;        default:&#10;            throw new RuntimeException();&#10;    &#125;&#10;    result[1].setInterpolator(mRotateInterpolator);&#10;    result[2] = ObjectAnimator.ofFloat(atom, &#34;length&#34;, 80f, 59f);&#10;    result[2].setInterpolator(mPaintInterpolator);&#10;    result[3] = ObjectAnimator.ofFloat(atom, &#34;r&#34;, 0, mScaleFactor * getIntrinsicWidth());&#10;    result[3].setInterpolator(mPaintInterpolator);&#10;    return result;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、Canvas图形变换原理">四、Canvas图形变换原理</h2><h3 id="2-1、平移">2.1、平移</h3><p>设图形上点P(x, y)，在x轴和y轴方向分别移动Tx和Ty，结果生成新的点P’(x’, y’)，则:<br> <img src="/res/android_animation2/pingy0.png" alt=" "></p>
<p>用矩阵形式可表示为:<br><img src="/res/android_animation2/pingyi.png" alt=" "><br>平移变换矩阵为：<br><img src="/res/android_animation2/pingyi2.png" alt=" "><br><img src="/res/android_animation2/pingyimatrix_副本.png" alt=" "></p>
<h3 id="2-2、缩放">2.2、缩放</h3><p>设图形上的点P(x, y)在x轴和y轴方向分别作Sx倍和Sy倍的缩放，结果生成新的点坐标P’(x’, y’)，则:<br><img src="/res/android_animation2/suofang.png" alt=" "><br>用矩阵表示为：<br><img src="/res/android_animation2/suofang2.png" alt=" "><br>比例变换矩阵为：<br><img src="/res/android_animation2/suofang 3.png" alt=" "><br><img src="/res/android_animation2/suofangMatrix_副本.png" alt=" "></p>
<h3 id="2-3、旋转">2.3、旋转</h3><p>设点P(x, y)绕原点旋转变换θ角度(假设按逆时针旋转为正角)，生成的新的点坐标P’(x’, y’)，则：<br><img src="/res/android_animation2/xuanzhuan1.png" alt=" "><br>用矩阵表示为：<br><img src="/res/android_animation2/xuanzhuan2.png" alt=" "><br>旋转变换矩阵为：<br><img src="/res/android_animation2/xuanzhuan3.png" alt=" "><br><img src="/res/android_animation2/xuanzhuanMatrix_副本.png" alt=" "></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、效果&quot;&gt;一、效果&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/res/android_animation2/xiaoguo.gif&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、有赞加载进度条&quot;&gt;二、有赞加载进度条&lt;/h2&gt;&lt;p&gt;四个正方形的运动可以分解成两个分运动，一个是平移运动，一个是自身的旋转运动。在实现这个动画上有两个思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是通过Android提供的Animation或者Animator操作视图，让一个正方形的视图在translate动画的同时进行rotate动画，只需要设置rotate动画的pivot坐标为视图的中心点就可以了。&lt;/li&gt;
&lt;li&gt;另一个是直接在canvas上绘制正方形，通过canvas的坐标变换实现动画。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="动画" scheme="https://ivonhoe.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="进度条" scheme="https://ivonhoe.github.io/tags/%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据解析工具</title>
    <link href="https://ivonhoe.github.io/2015/08/19/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <id>https://ivonhoe.github.io/2015/08/19/数据解析工具设计文档/</id>
    <published>2015-08-19T13:49:49.000Z</published>
    <updated>2016-03-06T13:35:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、设计目标">一、设计目标</h2><ul>
<li>设计一个相对通用的数据解析工具，高效解析通过抓包工具抓取的网络数据内容</li>
<li>只需要添加少量代码，实现不同数据格式的解析，并支持不同文件格式保存</li>
</ul>
<h2 id="二、实施步骤">二、实施步骤</h2><p>总的来说，就是使用MonkeyRunner自动测试脚本对手机进行某一些具体的操作时，通过Fiddler工具截取手机App的Http通讯数据，通过对这些数据进行解析从而达到获取应用数据的过程。</p>
<h3 id="2-1、编写MonkeyRunner自动脚本">2.1、编写MonkeyRunner自动脚本</h3><ul>
<li>环境和工具：Python，Android SDK开发环境， Android手机一台（debug选项连接PC）</li>
<li>脚本目标：循环对手机屏幕进行上划操作</li>
<li>代码：<a id="more"></a>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8&#10;from com.android.monkeyrunner import MonkeyRunner,MonkeyDevice,MonkeyImage&#10;device = MonkeyRunner.waitForConnection(5,&#39;351BBJHUHDPU&#39;)&#10;sleepTime = 0.2&#10;for x in xrange(1,10000):&#10;&#9;MonkeyRunner.sleep(sleepTime)&#10;&#9;device.drag((436,1234),(378,346),1,10)</span><br></pre></td></tr></table></figure>
<ul>
<li>注：MonkeyRunner.waitForConnection方法参数为adb devices 下的手机设备名</li>
</ul>
<h3 id="2-2、抓取应用流量信息">2.2、抓取应用流量信息</h3><ul>
<li>下载并安装需要抓取数据的Android应用</li>
<li>Google搜索获得<a href="http://jingyan.baidu.com/article/fd8044faebfaa85030137a72.html" target="_blank" rel="external">Android手机设置代理上网</a>方法，并成功设置手机通过PC代理上网功能</li>
<li>安装Fiddler，通过设置Fiddler host过滤可以获取固定host的HTTP Request和Response</li>
<li>使用MonkeyRunner测试脚本，循环触发手机上划操作，自动浏览手机应用商店的应用分类界面，通过Fiddler抓取手机的HTTP请求和响应消息内容，并导出</li>
</ul>
<h3 id="2-3、数据解析实现">2.3、数据解析实现</h3><h4 id="2-3-1、数据处理流程">2.3.1、数据处理流程</h4><p><img src="/res/parser/liuchentu.png" alt="Alt text"></p>
<h4 id="2-3-2、使用生产者消费者模式处理数据">2.3.2、使用生产者消费者模式处理数据</h4><p>生产者线程读取源数据文件，生产出待解析的字符串数据放入数据池中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10;  * &#29983;&#20135;&#32773;&#30340;&#29983;&#20135;&#23481;&#22120;&#10;  */&#10;private LinkedList&#60;Object&#62; mProductPool = new LinkedList&#60;Object&#62;();&#10;&#10;private void addProduct(List&#60;Object&#62; data) &#123;&#10;    while (!data.isEmpty()) &#123;&#10;        synchronized (mProductPool) &#123;&#10;             while (mProductPool.size() &#62;= MAX_SIZE) &#123;&#10;                try &#123;&#10;                    mProductPool.wait();&#10;                &#125; catch (InterruptedException e) &#123;&#10;                    e.printStackTrace();&#10;                &#125;&#10;            &#125;&#10;&#10;        getDataProducer().startProduce();&#10;&#10;        for (int i = 0; i &#60; Math.min(MAX_SIZE, data.size()) &#38;&#38;&#10;                mProductPool.size() &#60; MAX_SIZE; i++) &#123;&#10;                if (!data.isEmpty()) &#123;&#10;                    mProductPool.add(data.get(0));&#10;                    data.remove(0);&#10;                &#125;&#10;            &#125;&#10;            mProductPool.notifyAll();&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>多个消费者线程每次从数据池中获取一定数量的数据内容用来解析，并把解析结果放入最终的处理结果池中。这里并没有使用二级的消费者去做数据保存操作，因为可能需要把所有数据解析完成后做统一的分类、统计、筛选操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10;  * &#28040;&#36153;&#32773;&#22788;&#29702;&#25968;&#25454;&#21518;&#30340;&#23481;&#22120;&#10;  */&#10;private List&#60;Unit&#62; mConsumedPool = new ArrayList&#60;Unit&#62;()&#65307;&#10;&#10;public class Consumer implements Runnable &#123;&#10;&#10;    @Override&#10;    public void run() &#123;&#10;        while (true) &#123;&#10;            List&#60;Object&#62; queue = mEngine.getProductPool();&#10;            if (queue == null) &#123;&#10;                return;&#10;            &#125;&#10;&#10;            List&#60;Object&#62; temp = new ArrayList&#60;Object&#62;();&#10;            synchronized (queue) &#123;&#10;                while (queue.size() == 0 &#38;&#38; !mEngine.isProduceComplete()) &#123;&#10;                    try &#123;&#10;                        queue.wait();&#10;                    &#125; catch (InterruptedException e) &#123;&#10;                        e.printStackTrace();&#10;                        queue.notify();&#10;                    &#125;&#10;                &#125;&#10;&#10;                int size = queue.size();&#10;                int k = Math.max(0, size - NUM_PER_CONSUME);&#10;                for (int i = size - 1; i &#62;= k; i--) &#123;&#10;                    temp.add(queue.get(i));&#10;                    queue.remove(i);&#10;                &#125;&#10;&#10;                queue.notifyAll();&#10;            &#125;&#10;&#10;            for (Object str : temp) &#123;&#10;                ArrayList&#60;Unit&#62; result = onParse((String) str);&#10;                if (result != null) &#123;&#10;                    mEngine.addParsedUnit(result);&#10;                &#125;&#10;            &#125;&#10;&#10;            if (mEngine.isProduceComplete() &#38;&#38; queue.isEmpty()) &#123;&#10;                complete(this);&#10;                Thread t = Thread.currentThread();&#10;                t.interrupt();&#10;                return;&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>Engine.java作为整个解析过程的引擎，不同的数据需要不同的解析实现和保存格式实现,使用Reader读取数据的数据，将读取的数据填充到数据池中，当池满时，Reader线程阻塞当池空时，解析线程阻塞。在数据全部读取并解析完成之后，通过IWriter将结果保存到文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Engine implements IParser.ParseListener &#123;&#10;    // &#25351;&#23450;&#35299;&#26512;&#30340;&#25968;&#25454;&#36335;&#24452;&#10;    public void setSourcePath(String path) &#123;&#125;&#10;    // &#35774;&#32622;Reader&#10;    public void setReader(IReader reader) &#123;&#125;&#10;    // &#35774;&#32622;&#35299;&#26512;&#22120;&#10;    public void setParser(IParser parser) &#123;&#125;&#10;    // &#35774;&#32622;Writer&#10;    public void setWriter(IWriter writer) &#123;&#125;&#10;    // &#35299;&#26512;&#22120;&#35299;&#26512;&#23436;&#25104;&#30340;&#22238;&#35843;&#10;    public void onParseComplete() &#123;&#125;&#10;    // &#21551;&#21160;&#65292;&#24320;&#22987;&#22788;&#29702;&#25968;&#25454;&#10;    public void start()&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、针对第三方应用商店分类数据的解析">三、针对第三方应用商店分类数据的解析</h2><h3 id="2-1、定义不同类型的解析器">2.1、定义不同类型的解析器</h3><p>在分析第三方商店数据的过程中发现，每个应用市场都会选择性的屏蔽竞品信息的行为，例如除非通过搜索功能，你很难在360应用商店看到直接百度的应用。淘宝应用商店的屏蔽行为相对较少，但是会刻意提高一些推广应用的下载排名。很难在应用商店中抓取完全的应用信息，可能需要解析一些自己手动收集的应用分类信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#20570;&#20855;&#20307;&#38024;&#23545;&#28120;&#23453;&#25968;&#25454;&#30340;JSON&#23383;&#31526;&#20018;&#36827;&#34892;&#25968;&#25454;&#35299;&#26512;&#10;public class TBParser extends IParser &#123;&#10;    @Override&#10;    public ArrayList&#60;Unit&#62; onParse(String source) &#123;&#10;    &#125;&#10;&#125;&#10;//&#20570;&#20855;&#20307;&#38024;&#23545;360&#30340;JSON&#23383;&#31526;&#20018;&#36827;&#34892;&#25968;&#25454;&#35299;&#26512;&#10;public class QHParser extends IParser &#123;&#10;    @Override&#10;    public ArrayList&#60;Unit&#62; onParse(String source) &#123;&#10;    &#125;&#10;&#125;&#10;// &#38024;&#23545;&#33258;&#24049;&#23450;&#20041;&#30340;&#25968;&#25454;&#36827;&#34892;&#35299;&#26512;&#10;public class CustomParser extends IParser &#123;&#10;    @Override&#10;    public ArrayList&#60;Unit&#62; onParse(String source) &#123;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2、Zip压缩和Huffman编码数据压缩的比较">2.2、Zip压缩和Huffman编码数据压缩的比较</h3><p>针对ZIP压缩，java提供了标准的接口<br>针对Huffman编码压缩文本的原理，可以参照<a href="http://coolshell.cn/articles/7459.html" target="_blank" rel="external">这里</a>,具体实现在工程代码在：com.ivonhoe.parser.huffman.HuffmanCode.java的实现<br>比较发现针对字符的压缩，直接ZIP压缩比先Huffman压缩后ZIP压缩的压缩比率高。</p>
<h3 id="2-3、保存文本格式">2.3、保存文本格式</h3><p>保存的数据文件包含两个部分</p>
<ul>
<li>第一部分表示各种分类数据的条目数量<br>{健康运动:81}<br>{通讯社交:326}<br>{生活休闲:485}<br>……</li>
<li>第二部分表示所有的包名，按照文件开始部分的分类顺序和条目数依次保存<br>com.hk515.patient<br>com.guokr.zhixing<br>com.yidian.health<br>……</li>
<li>如上所示，健康运动应用数量81个，分别是第二部分的1~81条目，通讯社交应用有326个，分别是第二部分的82~408条目，依次类推。</li>
</ul>
<h2 id="四、针对京东商品评论数据的解析">四、针对京东商品评论数据的解析</h2><p>针对京东的评论数据信息，通过继承IParser的接口实现具体针对京东数据的解析方式。<br>针对解析数据的保存，通过继承IWriter的保存接口，实现针对Excel文件格式的保存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**&#10; * &#38024;&#23545;JD&#30340;&#35780;&#35770;&#25968;&#25454;&#35299;&#26512;&#10; *&#10; * @author ivonhoe&#10; */&#10;public class JDWebParser extends IParser &#123;&#10;    @Override&#10;    public ArrayList&#60;Unit&#62; onParse(String source) &#123;&#10;    &#125;&#10;&#125;&#10;&#10;**&#10; * &#36890;&#36807;&#25509;&#21475;&#20445;&#23384;&#21040;Excel&#34920;&#26684;&#20013;&#10; *&#10; * @author ivonhoe&#10; */&#10;public class JDCommentWriter extends ExlWriter &#123;&#10;    @Override&#10;    public void onWrite(List&#60;Unit&#62; list) &#123;&#10;        // TODO Auto-generated method stub&#10;        exportToSheet(&#34;comments&#34;, TITLE_STRINGS, list);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="五、总结">五、总结</h2><ul>
<li>在python部分，在实现上只需要通过简单的循环让手机屏幕不停的滑动就可以了。针对移动端数据传输的特点，绝大多数的客户端应用和服务器数据传输的格式都是通过JSON或者XML。你不再需要想办法在爬取网站页面的基础上进行数据收集，不再需要考虑如何从繁杂的网页上筛选你想要的正文。通过抓包分析的方式，这就像一个漏斗，你不需要再去筛选数据。你拿到的都是格式化的数据了。</li>
<li>如果能够集合一些更智能的自动化测试工具如百度的MTC测试工具，录制一些特殊的操作脚本，那应该可以做更多的事情。</li>
<li>如果针对复杂的业务需求，可以增加二级的消费者针对数据进行进一步的处理。</li>
<li>针对应用分类数据的筛选，因为不同数据源的信息（如下载量）也并不是完全可信的。还需要做进一步的筛选。目前的做法是根据不同数据源进行加权平均取排名的方式（测试效果并不好），或者根据数据源的并集和应用下载量的排名综合筛选，应该可以有更好的方式。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、设计目标&quot;&gt;一、设计目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;设计一个相对通用的数据解析工具，高效解析通过抓包工具抓取的网络数据内容&lt;/li&gt;
&lt;li&gt;只需要添加少量代码，实现不同数据格式的解析，并支持不同文件格式保存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;二、实施步骤&quot;&gt;二、实施步骤&lt;/h2&gt;&lt;p&gt;总的来说，就是使用MonkeyRunner自动测试脚本对手机进行某一些具体的操作时，通过Fiddler工具截取手机App的Http通讯数据，通过对这些数据进行解析从而达到获取应用数据的过程。&lt;/p&gt;
&lt;h3 id=&quot;2-1、编写MonkeyRunner自动脚本&quot;&gt;2.1、编写MonkeyRunner自动脚本&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;环境和工具：Python，Android SDK开发环境， Android手机一台（debug选项连接PC）&lt;/li&gt;
&lt;li&gt;脚本目标：循环对手机屏幕进行上划操作&lt;/li&gt;
&lt;li&gt;代码：
    
    </summary>
    
    
      <category term="数据解析" scheme="https://ivonhoe.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="生产者消费者模式" scheme="https://ivonhoe.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Drawable,从简化布局谈起</title>
    <link href="https://ivonhoe.github.io/2015/04/28/Drawable-%E4%BB%8E%E7%AE%80%E5%8C%96%E5%B8%83%E5%B1%80%E8%B0%88%E8%B5%B7/"/>
    <id>https://ivonhoe.github.io/2015/04/28/Drawable-从简化布局谈起/</id>
    <published>2015-04-28T15:31:29.000Z</published>
    <updated>2016-03-06T13:37:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Drawble是干嘛的？">一、Drawble是干嘛的？</h2><p>说到Drawable肯定会第一时间想到图片资源，可能有人会认为Drawable就是图片。Drawble从字面上说就是“可绘制的”，google文档的描述:“A Drawable is a general abstraction for “something that can be drawn.””，Drawable其实就是为那些”可以被绘制的’’提供的抽象类。</p>
<ul>
<li><strong>哪些东西是”can be drawn”？</strong></li>
<li><strong>绘制在哪里的？</strong></li>
</ul>
<p>看下android原生的Drawable和Canvas提供了的绘图的接口：<a href="http://developer.android.com/reference/android/graphics/drawable/package-summary.html" target="_blank" rel="external">android.graphics.drawable</a><br><a href="http://developer.android.com/reference/android/graphics/Canvas.html" target="_blank" rel="external">android.graphics.Canvas</a>。Canvas提供了一系列的接口去实现绘制想要的图形、图片、颜色或者其他something，Drawable就是为了这些”something”提供的。</p>
<a id="more"></a>
<h2 id="二、如何自定义Drawable？如何简化布局？">二、如何自定义Drawable？如何简化布局？</h2><p><img src="/res/drawable/1.jpg" alt="Canvas和布局实现"></p>
<p>相信一定见过类似这样的布局，在Android系统中如何把想要的图形绘制处理，一般有两种方式：</p>
<ul>
<li>把你想要的视图简单的定义到布局文件中，系统读取布局文件绘制视图</li>
<li>把想要的图形通过canvas的绘图接口直接进行绘制<br>在第二种方式中，你需要通过比如Drawable，比如自定义的View的onDraw()方法，或者调用Canvas的draw…()方法，而View的方式实际上也是Canvas绘制的方式，View也可以看做是对Canvas绘图接口的包装。而直接绘制到Canvas上的方式也单单是这些，在主线程上你可以通过调用View的invalidate()方法触发绘制，在onDraw()方法处理绘图的回调。另一种非主线程绘制的方式就是SurfaceView了。</li>
</ul>
<p>通过Drawable绘制想要的图形是个不错的选择，Drawable是一个抽象类，draw()方法提供了绘制的Canvas，invalidateSelf()方法提供了重绘的可能。Drawable的抽象方法分别是：</p>
<ul>
<li><p><strong>draw(Canvas canvas)</strong>将想要的东西绘制到这个canvas对象上</p>
</li>
<li><p><strong>setAlpha(int alpha)</strong> 为drawable指定一个alpha值，0代表全透明，255代表全不透明。</p>
</li>
<li><p><strong>setColorFilter(ColorFilter cf)</strong> 为drawable指定一个颜色过滤器</p>
</li>
<li><p><strong>getOpacity()</strong> 获取透明度</p>
</li>
</ul>
<p>实现自定义的Drawable只需要继承Drawable.java，并且在draw方法里通过canvas绘制需要的图形就可以了，听起来很简单。无论是一组图片、一条曲线还是一个色块，所有你想要的图形都可通过canvas参数绘制上去。举个例子，如何使用Drawable简化上图所示的网格布局？假设你需要在网格布局里显示不同的图片，就可以把场景微信朋友群组的图标。当然你可以使用view布局来做，当然也可以使用canvas方式。根据Drawable添加的顺序依次确定每个图片的坐标位置，在draw()方法里根据每个图片的坐标位置和图片显示位置绘制到canvas上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Override&#10;public void draw(Canvas canvas) &#123;&#10;    final int N = Math.min(mChildDrawable.size(), mRowCount * mColumnCount);&#10;    for (int i = 0; i &#60; N; i++) &#123;&#10;        ChildDrawable itemToDraw = mChildDrawable.get(i);&#10;        Drawable drawable = itemToDraw.mDrawable;&#10;        if (drawable != null) &#123;&#10;            itemToDraw.mDrawable.setBounds(itemToDraw.mInsetL, itemToDraw.mInsetT, itemToDraw.mInsetR, itemToDraw.mInsetB);&#10;            drawable.draw(canvas);&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、让Drawable动起来怎么样？">三、让Drawable动起来怎么样？</h2><ul>
<li><strong>首先看下Drawable的Canvas从哪里来</strong></li>
</ul>
<p>一般使用ImageView显示drawable，看下ImageView的onDraw(Canvas canvas)，可以看到Drawable在ImageView里的绘制发生在View的onDraw回调里，根据scaleType和padding确定绘制的方式和位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void onDraw(Canvas canvas) &#123;&#10;    super.onDraw(canvas);&#10;    ....&#10;&#10;    // mDrawMatrix&#26681;&#25454;ImageView&#30340;ScaleType&#26469;&#30830;&#23450;&#30340;&#10;    if (mDrawMatrix == null &#38;&#38; mPaddingTop == 0 &#38;&#38; mPaddingLeft == 0) &#123;&#10;        mDrawable.draw(canvas);&#10;    &#125; else &#123;&#10;        ......&#10;        mDrawable.draw(canvas);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>View绘制Background Drawable在draw(Canvas canvas)方法，并在setBackgroundDrawable时会执行background.setCallback(this)操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Step 1, draw the background, if needed&#10;if (background != null) &#123;&#10;     ......&#10;     if ((scrollX | scrollY) == 0) &#123;&#10;         background.draw(canvas);&#10;     &#125; else &#123;&#10;         ......&#10;         background.draw(canvas);&#10;         ......&#10;     &#125;&#10; &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>再看Drawable如何重绘</strong>，<br>Drawable是依赖Canvas绘制的，查看Drawable源码发现调用invalidateSelf()方法需要获取Callback，在Callback是空的情况下无法重绘Drawable。那么在View里如何实现Drawable的重绘，显然需要先设置Drawable的重绘回调，View.java实现了Drawable.Callback接口，在View里调用setImageDrawable()方法里会首先设置当前View为Drawable的回调。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void invalidateSelf() &#123;&#10;    final Callback callback = getCallback();&#10;    if (callback != null) &#123;&#10;        callback.invalidateDrawable(this);&#10;    &#125;&#10;&#125;&#10;&#10;public static interface Callback &#123;&#10;    public void invalidateDrawable(Drawable who);&#10;    public void scheduleDrawable(Drawable who, Runnable what, long when);&#10;    public void unscheduleDrawable(Drawable who, Runnable what);&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>ImageView调用invalidate触发重绘，回调ImageView的onDraw()方法，完成Drawable的重绘。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Override&#10;public void invalidateDrawable(Drawable dr) &#123;&#10;    if (dr == mDrawable) &#123;&#10;        /* we invalidate the whole view in this case because it&#39;s very&#10;         * hard to know where the drawable actually is. This is made&#10;         * complicated because of the offsets and transformations that&#10;         * can be applied. In theory we could get the drawable&#39;s bounds&#10;         * and run them through the transformation and offsets, but this&#10;         * is probably not worth the effort.&#10;         */&#10;        invalidate();&#10;    &#125; else &#123;&#10;        super.invalidateDrawable(dr);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>了解了Drawable绘制的画布和重绘的方法，如何实现动画的Drawable只需要按时重绘Drawable就可以了，用动画控制重绘效果。具体实现可以看<a href="https://github.com/Ivonhoe/FancyDrawable" target="_blank" rel="external">https://github.com/Ivonhoe/FancyDrawable</a>，现在看如何实现我在<a href="https://ivonhoe.github.io/2015/04/17/%E5%9F%BA%E4%BA%8E%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E7%9A%84Android%E5%8A%A8%E7%94%BB%E5%B7%AE%E5%80%BC%E5%99%A8/">贝赛尔插值器</a>里说过的BallsLine进度条效果，只需要在每次重绘的回调里动态的控制每个小球点的位置就可以了，需要的动画插值器参数可以参考<a href="http://thecodeplayer.com/walkthrough/windows-phone-loading-animation" target="_blank" rel="external">Web代码</a>。</p>
<p><img src="/res/drawable/2.jpg" alt="动态Drawable和GridDrawable"></p>
<pre><code><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> FRAME_DURATION = <span class="number">1000</span> / <span class="number">60</span>;

<span class="keyword">protected</span> Runnable mUpdater = <span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        onFrame();

        scheduleSelf(mUpdater, SystemClock.uptimeMillis() + FRAME_DURATION);
        invalidateSelf();
    }
};

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (!isRunning()) {
        mIsRunning = <span class="keyword">true</span>;

        <span class="comment">// start</span>
        onStart();
        scheduleSelf(mUpdater, SystemClock.uptimeMillis() + FRAME_DURATION);
        invalidateSelf();
    }
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (isRunning()) {
        mIsRunning = <span class="keyword">false</span>;
        unscheduleSelf(mUpdater);

        <span class="comment">//stop</span>
        onStop();
    }
}
</code></pre><h1 id="五、参考文档">五、参考文档</h1><p><a href="http://developer.android.com/reference/android/graphics/drawable/Drawable.html" target="_blank" rel="external">http://developer.android.com/reference/android/graphics/drawable/Drawable.html</a></p>
<p><a href="http://developer.android.com/guide/topics/graphics/2d-graphics.html" target="_blank" rel="external">http://developer.android.com/guide/topics/graphics/2d-graphics.html</a></p>
<p><a href="http://wiresareobsolete.com/2012/12/textdrawable-draw-some-text/" target="_blank" rel="external">http://wiresareobsolete.com/2012/12/textdrawable-draw-some-text/</a></p>
<p><a href="http://cyrilmottier.com/2012/11/27/actionbar-on-the-move/" target="_blank" rel="external">http://cyrilmottier.com/2012/11/27/actionbar-on-the-move/</a></p>
<p><a href="http://antoine-merle.com/blog/2013/11/12/make-your-progressbar-more-smooth/" target="_blank" rel="external">http://antoine-merle.com/blog/2013/11/12/make-your-progressbar-more-smooth/</a></p>
<h2 id="六、Github">六、Github</h2><p><a href="https://github.com/Ivonhoe/FancyDrawable" target="_blank" rel="external">https://github.com/Ivonhoe/FancyDrawable</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Drawble是干嘛的？&quot;&gt;一、Drawble是干嘛的？&lt;/h2&gt;&lt;p&gt;说到Drawable肯定会第一时间想到图片资源，可能有人会认为Drawable就是图片。Drawble从字面上说就是“可绘制的”，google文档的描述:“A Drawable is a general abstraction for “something that can be drawn.””，Drawable其实就是为那些”可以被绘制的’’提供的抽象类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;哪些东西是”can be drawn”？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绘制在哪里的？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看下android原生的Drawable和Canvas提供了的绘图的接口：&lt;a href=&quot;http://developer.android.com/reference/android/graphics/drawable/package-summary.html&quot;&gt;android.graphics.drawable&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://developer.android.com/reference/android/graphics/Canvas.html&quot;&gt;android.graphics.Canvas&lt;/a&gt;。Canvas提供了一系列的接口去实现绘制想要的图形、图片、颜色或者其他something，Drawable就是为了这些”something”提供的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="Drawable" scheme="https://ivonhoe.github.io/tags/Drawable/"/>
    
      <category term="性能优化" scheme="https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ColorOS和APEX桌面产品分析</title>
    <link href="https://ivonhoe.github.io/2015/04/23/ColorOS%E5%92%8CAPEX%E6%A1%8C%E9%9D%A2%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    <id>https://ivonhoe.github.io/2015/04/23/ColorOS和APEX桌面产品分析/</id>
    <published>2015-04-23T13:30:35.000Z</published>
    <updated>2016-03-06T13:37:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、桌面基本操作">一、桌面基本操作</h2><h3 id="1-1_安装初体验">1.1 安装初体验</h3><ul>
<li><p><strong>安装包大小</strong><br>ColorOS桌面含有两个安装包，OppoLauncher.apk(2.8M)和OppoLauncherSystem.apk(8.5KB)<br>APEX桌面安装包大小4.36M，并且进行了代码混淆</p>
</li>
<li><p><strong>默认桌面</strong><br>ColorOS桌面，前两个屏幕是系统应用，包含一个小工具的文件夹，其他所有应用平铺桌面，用户自己安装的应用从第三屏开始平铺。<br>APEX桌面，默认的应用排列就很随意，在不同的手机上的表现有差别，应该是不同手机的系统应用的包名不同，造成APEX的预制桌面并不是顺序紧密在桌面显示应用图标。</p>
<a id="more"></a>
</li>
</ul>
<h3 id="1-2_打开应用">1.2 打开应用</h3><p>   桌面的本分无非就是帮助用户打开其他应用了，体验ColorOS和APEX的打开应用操作过程没有差别，首先是用户找到相应的应用，通过单击图标打开应用。APEX基于Android原生桌面，保留了抽屉功能，所以针对还没有添加到桌面的图标还需要先进入抽屉界面。ColorOS的另一个细节是新安装的应用图标在图标上会有类似IOS的提示，提醒用户这是一个新安装的应用，打开新安装应用后提示就消失。</p>
<h3 id="1-3_移动图标和归纳文件夹">1.3 移动图标和归纳文件夹</h3><ul>
<li><p><strong>长按和拖动</strong><br>几乎所有的桌面产品移动图标的操作都是长按图标拖拽即可移动，ColorOS在长按时所有图标会进入抖动的模式，这点又和IOS的表现一直，同时可卸载的应用左上角会出现可删除的提示。在抖动模式下可直接卸载应用。<br>相比APEX在长按桌面图标后会出现一个弹出的视图，上面可以进行删除、编辑图标名称、增加手势等操作。在拖动过程中，ColorOS的图标会根据拖动反响有倾斜的效果。</p>
</li>
<li><p><strong>归纳应用到文件夹</strong><br>ColorOS、APEX的桌面图标合并都是基于原生Launcher的，没有本质的差别，都不支持同时合并两个文件夹。但像比较之下，ColorOS在拖动图标更换位置上支持跨屏查找位置，即当从Dock位置拖向一个排满图标的屏幕时，图标会自动向后一个屏幕寻找位置。相比其他桌面产品很少有关注这个细节的。同时ColorOS的文件夹中提供了一个“+”操作，可以批量选择桌面上的图标加入当前文件夹中，针对用户归纳应用行为避免了反复拖动和选择的操作，但是“+”操作只能针对桌面图标，已经放入其他文件夹的图标不在被选列表中，同时“+”支持把当前文件夹中的图标移出文件夹的操作，移出的图标自动放到桌面最后的位置。</p>
</li>
</ul>
<h3 id="1-4_卸载应用">1.4 卸载应用</h3><p>ColorOS在长按图标进入跳动模式后，可卸载图标左上角都会出现删除提示，又是IOS的痕迹。<br>APEX卸载操作相对原生Launcher同样没有差别。好懒啊！在桌面上的图标只提供删除接口，从抽屉中长按的图标才可以删除。删除应用同样会弹出框确认。</p>
<h2 id="二、用户感知">二、用户感知</h2><h3 id="2-1_图标风格和桌面主题范围">2.1 图标风格和桌面主题范围</h3><ul>
<li><p><strong>图标风格</strong><br>ColorOS的默认图标并没有定义应用图标的形状也没有加圆角，但是尽量保证了图标大小的统一，同时默认系统图标加了阴影，在色彩上系统默认图标以绿色和白色色调居多，因为并没有给所有的图标加背板，所以整体的感觉是辨识度很好，尽量保持了应用图标的本色。但是统一度不够，不过因为有换主题功能这点也并没有什么不好，不喜欢默认图标？间接的把用户赶向了主题商店。相比APEX的图标风格，还是一个字，“懒惰”。和原生Launcher几乎没有区别，导致三方应用的显示效果很差。</p>
</li>
<li><p><strong>桌面主题范围</strong><br>ColorOS的主题范围</p>
</li>
<li>图标，包含背板、圆角、大小、图标内容<br>l 壁纸，包括动态壁纸(ColorOS的一大特色)、静态壁纸<br>l 文件夹图标背景<br>l 页面指示指示样式</li>
</ul>
<p>APEX:需要到google play下载</p>
<h3 id="2-2_动画和声效">2.2 动画和声效</h3><p>ColorOS桌面的动画只要集中在编辑模式中，长按图标的跳动模式和下侧编辑框空间的进场动画。最有亮点的动画天气效果和其他的动态壁纸，比如默认的蒲公英会随着滑动方向飘动。在音效方面，ColorOS在用户的操作反馈上也很有特点，甚至在天气动画和音效的接合上，下雨的声音，闪电的效果，做的都很到位。更可贵的是，针对雾霾天气的显示并不是灰蒙蒙的一片并不会给人太多很压抑或者消极的暗示。</p>
<p>APEX的动画和声效还是用一个字形容。</p>
<h3 id="2-3_用户编辑和设置">2.3 用户编辑和设置</h3><p>针对用户编辑和设置在上面也已经提到，包括图标和文件夹的交互。还有新建屏幕方面，ColorOS依然是在编辑模式自动向后新加一个屏幕，对于APEX我表示设置项太多我还没找到。ColorOS针对用户的设置，不管是换壁纸换主题还是添加小部件，桌面都会马上程序出用户设置后的效果，并不是通过菜单项的选择或者其他设置页面的跳转来完成，所有的设置都在桌面上完成，并且几乎文字的描述，因为不需要。<br>而相比较APEX，几乎所有的设置都是通过菜单的选择来设置完成的，因为需要同时针对桌面和应用抽屉两个界面，APEX桌面的设置范围和功能不能说不强大。几乎针对桌面所有能想到的设置项它都覆盖到了。甚至很多功能，通过名字也无法理解到底是有什么作用，只要试试才会知道，而设置的过程可能需要2~3个界面的跳转才能设置成功，预览设置效果还需要返回桌面才能看到，在体验上确实太多繁琐。所有针对这么多设置项，一个备份和恢复设置项显得有多么重要，APEX做到了。但是不得不承认，APEX桌面的设置真的是应有尽有，每一块视图区域都对应一系列的设置项，包括主屏幕设置、抽屉设置(这里还包括抽屉应有的分组分类功能)、托盘区域的设置、文件夹样式的设置、通知设置等。竟然还意犹未尽加上了所谓高级设置。我想收回上面对APEX的评价。APEX桌面真是太勤奋了…<br>简单看下高级设置，就包括图标尺寸设置、图标文字大小设置、图标字体设置、语言设置。甚至还有主屏幕和抽屉页面的滚动速度设置。想象力不可谓不丰富。(这里我就不列举了，详细了解请下载体验。)</p>
<h2 id="三、用户体验">三、用户体验</h2><h3 id="3-1_特色和附加功能">3.1 特色和附加功能</h3><p>说到特色，如果针对没有接触过IOS的普通低端用户，照搬IOS的模式是一个很讨巧的方式，在图标的编辑等很多方面ColorOS都有着IOS的烙印。这样也没有错，优秀的事物都是相似的。当然ColorOS称得上特色的不仅仅是这些，天气壁纸和动态壁纸结合图标的效果不可谓不惊艳。在下雨的时候图标上都有雨珠的效果，不单单是产品设置的想象力，在程序设计上也是很有难度的。结合主题的换肤功能，虽然没有太多的亮点，功能上也是中规中矩，但是在素材和资源的质量上也不错，单独就拿图标来说，免费的主题给人的感觉也不是水友随便弄弄的感觉。同时在主题功能上实现了多运营管道的接入，为更多更优质的资源提供了可能。</p>
<p>相对APEX桌面，最大的特色应该就是，“你看到的东西几乎都能改变”，上面已经简单列举过了。抛开用户的操作体验不说，单在程序设计的角度上说，如何组织如此多的设置功能，光是想想都有点头皮发麻，而相对与APEX桌面的流畅和稳定性，它的软件架构一定有很多能够学习的地方。可惜代码被混淆了。</p>
<h3 id="3-2_流程度和内存">3.2 流程度和内存</h3><ul>
<li><p><strong>流畅度</strong><br>ColorOS在桌面滑动特效上，开始滑动的几帧可能会有掉帧的现象，而且就蒲公英动态壁纸，在滑动桌面是蒲公英的飞动效果也稍有掉帧的感觉，可能是刷新频率的问题。<br>APEX桌面的流畅性上也是表现不错，APEX在原生桌面的交互基础上进行的开发，交互并不复杂，视图的层次和复杂度也并不复杂。</p>
</li>
<li><p><strong>内存</strong><br>ColorOS桌面在一般情况内存在100M以上，增加多个专属空间空间可能会达到150M。正常情况下会在150M以下。<br>APEX桌面启动之后的内存占有在40M左右，正常使用情况下在60M左右。相比较一个hello world都可能分配10M的内存，这样的内存占用率已经很不错了。不过毕竟APEX桌面的动画和视图并不算复杂，这样的占有率也在情理之中。</p>
</li>
</ul>
<h2 id="四、反编译分析">四、反编译分析</h2><p>分析结果暂无。</p>
<h2 id="五、我的看法">五、我的看法</h2><p>ColorOS桌面和APEX桌面在产品思路上是完全不同的方向。一个在尽力讨好用户，尽力把特效和交互做炫，它尽力告诉用户什么样是比较好的，针对国内市场确实算很有特色也很有卖点。而对比其他优秀桌面产品在很多交互上也难免有很多相似之处，当然这并不可怕，可怕的是别人有的我也有，别人有的我没有。还好ColorOS迈过了这道坎，动态壁纸的效果也证明了ColorOS桌面足够优秀。那这么好的效果为什么没有引起别人跟风？（事实上也不是没有，TCL就跟过）。代码都没有加混淆，搞过来应该不难。但是伴随着酷炫的视觉效果背后，躲不开的就是内存和功耗问题，这个可想而知，在体验OPPO手机的过程中，最大的感受就是充电太慢了，电池太不够用。面对开放市场的桌面功耗和内存是必不可少的考核条件。（此处省略一万字）。<br>在另一方面，APEX桌面，尽量做的讨巧，本身原生Launcher的交互和稳定性并不差。国内桌面产品之所以拼的你死我活，无法就是避免同质化。避免和别人一样，保持自己的特点成了很大的一个因素。而APEX也同样懂得这个道理，但是它的方式不太一样，它在避免和别人相同的道路上把更多的选择权交给了用户，给用户提供了各式的设置接口，并且提供了设置备份的功能。也是用心良苦，但是在组织如此多设置接口的方式上也是让人很痛的，太累，我太懒，来不及去探索属于自己更多的可能。</p>
<h2 id="六、对于桌面产品的启发">六、对于桌面产品的启发</h2><ul>
<li><p><strong>做好第一感觉</strong><br>第一感觉，安装包的大小，默认桌面图标的设置。能否真正适配不同厂商手机，就拿Phone这个应用来说，不同厂商的包名可能千差万别，能否有合适的方法，让它在每一台手机上都放在正确的位置。从用户已有的桌面中获取用户已有的桌面配置是不是更好？如何做到？在用户第一次使用的时候是否应该给类似分类和相关冷启动的向导，这样会不会更好？还有很多未知！！</p>
</li>
<li><p><strong>流畅和性能永远是重点,轻</strong></p>
</li>
<li><p><strong>我们的亮点在哪？我们的痛点在哪？我们产品的设计原则是什么？</strong></p>
</li>
<li><p><strong>如果我们想要做一个优秀的产品，那请先说服自己，先让自己人都喜欢上我们的产品</strong></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、桌面基本操作&quot;&gt;一、桌面基本操作&lt;/h2&gt;&lt;h3 id=&quot;1-1_安装初体验&quot;&gt;1.1 安装初体验&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;安装包大小&lt;/strong&gt;&lt;br&gt;ColorOS桌面含有两个安装包，OppoLauncher.apk(2.8M)和OppoLauncherSystem.apk(8.5KB)&lt;br&gt;APEX桌面安装包大小4.36M，并且进行了代码混淆&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;默认桌面&lt;/strong&gt;&lt;br&gt;ColorOS桌面，前两个屏幕是系统应用，包含一个小工具的文件夹，其他所有应用平铺桌面，用户自己安装的应用从第三屏开始平铺。&lt;br&gt;APEX桌面，默认的应用排列就很随意，在不同的手机上的表现有差别，应该是不同手机的系统应用的包名不同，造成APEX的预制桌面并不是顺序紧密在桌面显示应用图标。&lt;/p&gt;
    
    </summary>
    
    
      <category term="产品分析" scheme="https://ivonhoe.github.io/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>基于贝塞尔曲线的Android动画差值器</title>
    <link href="https://ivonhoe.github.io/2015/04/17/%E5%9F%BA%E4%BA%8E%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E7%9A%84Android%E5%8A%A8%E7%94%BB%E5%B7%AE%E5%80%BC%E5%99%A8/"/>
    <id>https://ivonhoe.github.io/2015/04/17/基于贝塞尔曲线的Android动画差值器/</id>
    <published>2015-04-17T02:35:05.000Z</published>
    <updated>2016-12-16T05:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介">一、简介</h2><p>贝塞尔曲线于1962，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau算法开发，以稳定数值的方法求出贝兹曲线。贝塞尔曲线不仅仅可以应用到工业设计中，在计算机动画开发中同样占有一席之地，通过构造贝塞尔曲线模拟物体运动的轨迹、速度甚至加速度，来达到想要的动画效果。在CSS开发中使用‘cubic-bezier’方法，传递三次贝赛尔曲线的两个控制点P1和P2来生成一条平滑的曲线。甚至也有很多javaScript动画库使用贝赛尔曲线来实现完美的动画效果。</p>
<p><img src="/res/bezier/TimingFunction.png" alt="通过P1和P2控制曲线"></p>
<a id="more"></a>
<p>而我要做的通过贝塞尔曲线的原理生成Android动画插值器，在Android平台上实现基于贝赛尔曲线的动画效果。想要了解Android动画原理请先阅读<a href="https://ivonhoe.github.io/2015/02/09/Android%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/">这篇文章</a>。了解贝塞尔曲线绘制过程可以先阅读<a href="http://www.html-js.com/article/1628" target="_blank" rel="external">贝塞尔曲线扫盲</a>，写的很好。</p>
<h2 id="二、De_Casteljau算法">二、De Casteljau算法</h2><p><img src="/res/bezier/decu.png" alt="二次贝塞尔曲线"></p>
<p>贝塞尔曲线常见的算法是可以通过多项式、De Casteljau算法和递归算法来进行计算。针对De算法，设P0,P1,P2确定了一条二次贝塞尔曲线q，引入参数t，令<img src="/res/bezier/1.gif" alt="">即有：</p>
<p><img src="/res/bezier/2.gif" alt=" "></p>
<p>当t从0变到1，第一、二式是两条一次Bezier曲线。将一、二式代入第三式得到：</p>
<p><img src="/res/bezier/5.gif" alt=" "></p>
<p>当t从0变到1时，它表示了由P0、P1、P2三个控制点形成一条二次Bezier曲线。并且这个二次Bezier曲线可以分别由前两个顶点(P0,P1)和后两个顶点(P1,P2)决定的一次Bezier曲线的线性组合。以此类推，由四个控制点定义的三次Bezier曲线可被定义为分别由(P0,P1,P2)和(P1,P2,P3)确定的两条二次Bezier曲线的线性组合，由(n+1)个控制点定义的n次Bezier曲线可被定义为分别由前后n个控制点定义的两条(n-1)次Bezier曲线的线性组合：</p>
<p><img src="/res/bezier/3.gif" alt=" "></p>
<p>由此得到Bezier曲线的递推计算公式:</p>
<p><img src="/res/bezier/4.gif" alt=" "></p>
<p>这就是De Casteljau算法。使用这个递推公式，在给定参数下，求Bezier曲线上一点P(t)非常有效。</p>
<h2 id="三、Bezier动画插值器实现">三、Bezier动画插值器实现</h2><p>基于De Casteljau算法的递推公式求曲线上点的坐标：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">deCasteljau</span><span class="params">(Point[] points, <span class="keyword">float</span> t)</span> </span>{
    final <span class="keyword">int</span> n = points.length;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)
        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) {
            points[j].x = (<span class="number">1</span> - t) * points[j].x + t * points[j + <span class="number">1</span>].x;
            points[j].y = (<span class="number">1</span> - t) * points[j].y + t * points[j + <span class="number">1</span>].y;
        }

    <span class="keyword">return</span> points[<span class="number">0</span>];
}
</code></pre><p>De Casteljau算法目的是求得曲线上的每一个点，如何用这些采样点描述一条曲线插值器还需要进一步的处理。主要就是处理精度的问题，用距离很近的两个点连线的线段近似描述曲线，理论上采样点越密集描述的越准确，但是很明显在实际项目中不能选择太多的采样点，因为要考虑内存和效率的问题。所以用尽可能少的点尽可能精细的用直线段描述一条曲线，一个不错的做法就是在采样点的在横坐标方向上不要等距分布，而是在曲线变化较快的地方（即斜率较大）采样点尽可能的密集，而在曲线变化平缓的地方采样点选择稀疏。所以需要在通过De Casteljau算法获取初步的采样点后，再进一步获取非均匀分布的采样点，更加处理后的采样点再进行计算。</p>
<p>考虑到针对不同动画的编辑，可能不仅仅是动画进度的插值，还需要动画速度的插值和动画变化率的插值，针对不同曲线类型的变化，通过下面的方式进行扩展。详细代码可以查看<a href="https://github.com/Ivonhoe/BezierInterpolator" target="_blank" rel="external">这里</a></p>
<h2 id="四、使用范例">四、使用范例</h2><p>通过控制点构造贝塞尔曲线插值器，例如，可以通过构造一个特殊的插值器，控制drawable的重绘和每个小球的动画并重绘drawable就可以实现类似window phone上经典的Balls Line进度条效果，详细实现可以参考<a href="https://ivonhoe.github.io/2015/04/28/Drawable-%E4%BB%8E%E7%AE%80%E5%8C%96%E5%B8%83%E5%B1%80%E8%B0%88%E8%B5%B7/">这里</a>。</p>
<p><img src="/res/bezier/windows_balls_line.GIF" alt="window 进度条"></p>
<p>通过两个控制点构造三次贝赛尔插值器(默认会增加(0,0)和(1,1)作为控制点)。</p>
<pre><code><span class="keyword">if</span> (mBezierInterpolator == null) {
    <span class="comment">// 贝塞尔插值器</span>
    mBezierInterpolator = <span class="keyword">new</span> BezierInterpolator(<span class="number">0.03f</span>, <span class="number">0.615f</span>, <span class="number">0.995f</span>, <span class="number">0.415f</span>);
}
<span class="keyword">if</span> (mLinearInterpolator == null){
    <span class="comment">// 普通线性插值器</span>
    mLinearInterpolator = <span class="keyword">new</span> LinearInterpolator();
}
</code></pre><p>同样可以传递包含所有控制点的List构造插值器。</p>
<pre><code>mBezierInterpolator = new BezierInterpolator<span class="list">(<span class="keyword">new</span> ArrayList&lt;Point&gt;<span class="list">()</span>)</span><span class="comment">;</span>
</code></pre><p>针对BezierInterpolator的构造会有一定的耗时，所以并不建议在需要用到的时候才去构造，也不建议频繁的构造相同的插值器实例。</p>
<h2 id="五、参考文档">五、参考文档</h2><p><a href="http://baike.baidu.com/view/10167166.htm" target="_blank" rel="external">3D计算机图形学 Samuel R.Buss</a><br><a href="http://wenku.baidu.com/view/2beaa4bc960590c69ec376cd.html" target="_blank" rel="external">Bezier曲线的算法描述及其程序实现</a><br><a href="http://cubic-bezier.com/" target="_blank" rel="external">在线贝塞尔曲线编辑器</a><br><a href="http://thecodeplayer.com/walkthrough/windows-phone-loading-animation" target="_blank" rel="external">window phone loading animation</a></p>
<h2 id="六、Github">六、Github</h2><p><a href="https://github.com/Ivonhoe/BezierInterpolator" target="_blank" rel="external">https://github.com/Ivonhoe/BezierInterpolator</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、简介&quot;&gt;一、简介&lt;/h2&gt;&lt;p&gt;贝塞尔曲线于1962，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau算法开发，以稳定数值的方法求出贝兹曲线。贝塞尔曲线不仅仅可以应用到工业设计中，在计算机动画开发中同样占有一席之地，通过构造贝塞尔曲线模拟物体运动的轨迹、速度甚至加速度，来达到想要的动画效果。在CSS开发中使用‘cubic-bezier’方法，传递三次贝赛尔曲线的两个控制点P1和P2来生成一条平滑的曲线。甚至也有很多javaScript动画库使用贝赛尔曲线来实现完美的动画效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/res/bezier/TimingFunction.png&quot; alt=&quot;通过P1和P2控制曲线&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="动画" scheme="https://ivonhoe.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="贝塞尔曲线" scheme="https://ivonhoe.github.io/tags/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>[译]Context?什么是Context？</title>
    <link href="https://ivonhoe.github.io/2015/04/08/-%E7%BF%BB%E8%AF%91-Context-%E4%BB%80%E4%B9%88%E6%98%AFContext%EF%BC%9F/"/>
    <id>https://ivonhoe.github.io/2015/04/08/-翻译-Context-什么是Context？/</id>
    <published>2015-04-08T03:06:31.000Z</published>
    <updated>2016-03-06T13:33:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://possiblemobile.com/2013/06/context/" target="_blank" rel="external">http://possiblemobile.com/2013/06/context/</a></p>
<h2 id="Context可能是Android应用中最常用的元素也是最容易误用的元素">Context可能是Android应用中最常用的元素也是最容易误用的元素</h2><p>Context是经常被传递的对象，它可以很容易的构造一个你意想不到的情景，如加载资源，启动一个新的Activity，得到一个系统服务，得到内部文件路径和创建视图都需要一个Context去完成这个工作，我接下来为你在Context到底是如何工作的和为你能在你的应用中更好的运用Context提供建议。<br><a id="more"></a></p>
<h2 id="Context类型">Context类型</h2><p>并不是所有的Context实例都是相同的，对于不同的Android应用组件，Context会有一些差别。</p>
<h3 id="Application">Application</h3><p>Application 是应用进程中的一个单例，它可以通过Activity或者Service的getApplication()方法或者从Context派生出的其他对象调用getApplicationContext()方法得到，在同一个进程里任意时刻你得到的都是相同的Application实例。</p>
<h3 id="Activity和Service">Activity和Service</h3><p>Activity和Sevice继承ContextWrapper，而ContxtWrapper同样实现了Context的接口，但是ContextWrapper的所有的方法都是通过包装一个内部context对象实现的，也就是它的base context（注：看ContextWrapper源码，ContextWrapper顾名思义就是Context的包装，ContextWrapper的实际功能都是成员变量mBase完成的，ContextThemeWrapper集成ContextWrapper，增加了Theme和Configuration作为成员变量，Activity继承ContextThemeWrapper，所以说Activity才是唯一包含主题信息的context。详细见下文）。当framework创建一个新的Activity或者Service的实例时，也会创造一个新的ContextImpl实例去真正完成context的实际功能，每一个Activity或者服务，和他们相应的base context，都是不同的context实例。</p>
<h3 id="BroadcastReceiver">BroadcastReceiver</h3><p>BroadcastReceiver本身并不是Context，但是当广播事件传递的时候，framework都会在onReceive()方法中传递一个Context。这个Context是一个ReceiverRestrictedContext实例（注：看ContextImpl的getReceiverRestrictedContext()方法），它的registerReceiver()和bindService()方法是失效的，这两个功能是不允许通过onReceive()方法传递的Context调用的，（每次receiver处理一个广播，都会创建一个新的context实例。)</p>
<h3 id="ContentProvider">ContentProvider</h3><p>ContentProvider同样也不是Context，但是已被创建就可以活取getContext方法，如果ContentProvider和调用者在同一个进程，那会返回相同的Application实例，如果在两个单独的进程里，getContext()会返回一个新创建的Context，代表这个provider进程的Context。（注：可以阅读ActivityThread.java中的installProvider()和ContentProvider的attachInfo()方法，installProvider方法会根据provider的包名和当前进程名进行比较，如果是同一个进程那就使用当前的application context，如果在不同的进程中，就会调用createPackageContext创建一个provider相关的Context，并通过attachInfo绑定provider）。</p>
<h2 id="保存引用">保存引用</h2><p>我们首先关注的问题是，当我们在一个对象或者类里面保存一个context的引用，但是这个对象或者类的生命周期超过了你保存的context实例的生命周期。例如，创建需要一个Context对象去加载资源或者去调用CotentProvider，保存当前Activity或者Service的引用在这个单例中。</p>
<p>失败的单例：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomManager</span> {
    <span class="keyword">private</span> <span class="keyword">static</span> CustomManager sInstance;

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomManager <span class="title">getInstance</span>(<span class="params">Context context</span>) </span>{
        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) {
            sInstance = <span class="keyword">new</span> CustomManager(context);
        }

        <span class="keyword">return</span> sInstance;
    }

    <span class="keyword">private</span> Context mContext;

    <span class="function"><span class="keyword">private</span> <span class="title">CustomManager</span>(<span class="params">Context context</span>) </span>{
        mContext = context;
    }
}
</code></pre><p>这里的问题是我们并不知道这个Context从哪里来，当持有一个结束的Activity或者Service是不安全的，这是因为在这个类里的单例是一个静态引用。这意味着我们引用的对象包括所有被这个对象引用的对象都不会被垃圾回收。如果这个Context是一个Activity，那么就会造成这个Activity引用的所有视图和其他可能跟它关联的对象持续占有内存，造成内存泄露。</p>
<p>为了防止这种情况，我们把这个单例修改成引用appliction context。</p>
<p>修改后的单例：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomManager</span> {
    <span class="keyword">private</span> <span class="keyword">static</span> CustomManager sInstance;

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomManager <span class="title">getInstance</span>(<span class="params">Context context</span>) </span>{
        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) {
            <span class="comment">//Always pass in the Application Context</span>
            sInstance = <span class="keyword">new</span> CustomManager(context.getApplicationContext());
        }

        <span class="keyword">return</span> sInstance;
    }

    <span class="keyword">private</span> Context mContext;

    <span class="function"><span class="keyword">private</span> <span class="title">CustomManager</span>(<span class="params">Context context</span>) </span>{
        mContext = context;
    }
}
</code></pre><p>现在不用关心这个Context是什么，因为现在持有的引用是安全的。Application context本身就是一个单例，我们只是创建另一个静态引用并不会造成内存泄露。另一个类似例子就是在一个后台的线程或者等待的Handler里持有一个Context引用。<br>既然这样那我们为什么总是引用一个application context呢？我们就永远不用担心内存泄露的问题。答案当然是不可以，就想我在前面提到的那样，每种类型的Context类型都不相同。</p>
<h2 id="Context的功能">Context的功能</h2><p>我们安全的调用Context的方法取决于这个Context是如何创建的，下面的表是Context功能的使用情况：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">Application</th>
<th style="text-align:center">Activity</th>
<th style="text-align:center">Service</th>
<th style="text-align:center">ContentProvider</th>
<th style="text-align:center">BroadcastReceiver</th>
</tr>
</thead>
<tbody>
<tr>
<td>Show a Dialog</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>Start an Activity</td>
<td style="text-align:center">NO1</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO1</td>
<td style="text-align:center">NO1</td>
<td style="text-align:center">NO1</td>
</tr>
<tr>
<td>Layout Inflation</td>
<td style="text-align:center">NO2</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO2</td>
<td style="text-align:center">NO2</td>
<td style="text-align:center">NO2</td>
</tr>
<tr>
<td>Start a Service</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td>Bind to a Service</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>Send a Broadcast</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td>Register BroadcastReceiver</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO3</td>
</tr>
<tr>
<td>Load Resource Values</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<p>注：<br>1.一个application可以启动一个Activity，但是需要创建一个新的任务。这样做可能满足一些特定的需求，但是在应用中创建一个非标准的回退栈并不是一种经过深思熟虑的推荐做法。<br>2.这样是合法的，但是这样是加载出来的系统默认的主题布局，而并不是你在应用里定义的主题样式。<br>3.在receiver是null的情况下是允许的（注：看ContextImpl的内部类ReceiverRestrictedContext，ReceiverRestrictedContext进程ContentWrapper但是重写了注册广播和绑定服务的方法，会在这两个方法里抛出异常。为什么要这么做？），在4.2以上版本用来获取粘性广播。</p>
<h2 id="用户接口">用户接口</h2><p>从上个表格你可以看出，有很多和UI处理相关的Context的功能并不适合用application context去处理。事实上，实现了所有和所有UI相关的操作接口的是Activity，而其他的类别的功能都几乎相同。<br>幸运的是这三个操作（注：指Application context不具备的三个Context功能）是application在Activity范围之外根本不需要去做的，这好像就是framework故意设计如此，如果你尝试通过一个application context去创建一个对话框或者启动一个Activity会抛出异常并造成应用程序终止，会有明显的指示告诉你这样出错了。<br>另一个值得注意的问题是加载布局，如果你阅读过我的文章<a href="http://www.doubleencore.com/2013/05/layout-inflation-as-intended" target="_blank" rel="external">layout inflation</a>,你会觉得这个过程会是稍微难理解的过程，使用正确的context就算一个。当你使用通过application context构造的LayoutInflater去加载视图，当然framework同样会返回一个正确的视图树，但是你在应用中设置的主题和样式是被忽略的，这是因为Activity才是真正关联你在manifest中设置的主题的Context。其他类型的Context实例会使用系统默认的主题样式去构建视图。所以这样构建出的视图可能并不是像你预期的那样。</p>
<h2 id="交集">交集</h2><p>一定会有人得到这样的冲突的结论，在应用设计中会有一种情况，可能必须长期持有一个Activity Context引用，因为我想完成的任务包含UI的操作。如果是这样的话，那我只能强烈建议你重新考虑你的设计，因为那样的设计将是和Android应用架构背道而驰的过程。</p>
<h1 id="总结">总结</h1><p>在大多数情况下，使用你当前封闭的组件中直接使用Context就是可以了，只有你持有引用不超过这个组件的生命周期就不会有问题，只要你需要保存一个Context的引用超出Activity或者Service的生命周期，哪怕是暂时的引用，那就请转换成保存application context的引用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://possiblemobile.com/2013/06/context/&quot;&gt;http://possiblemobile.com/2013/06/context/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Context可能是Android应用中最常用的元素也是最容易误用的元素&quot;&gt;Context可能是Android应用中最常用的元素也是最容易误用的元素&lt;/h2&gt;&lt;p&gt;Context是经常被传递的对象，它可以很容易的构造一个你意想不到的情景，如加载资源，启动一个新的Activity，得到一个系统服务，得到内部文件路径和创建视图都需要一个Context去完成这个工作，我接下来为你在Context到底是如何工作的和为你能在你的应用中更好的运用Context提供建议。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="Context" scheme="https://ivonhoe.github.io/tags/Context/"/>
    
      <category term="翻译" scheme="https://ivonhoe.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Android动画总结</title>
    <link href="https://ivonhoe.github.io/2015/02/09/Android%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/"/>
    <id>https://ivonhoe.github.io/2015/02/09/Android动画总结/</id>
    <published>2015-02-09T11:40:53.000Z</published>
    <updated>2016-03-06T13:36:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说在开始">说在开始</h3><p>这篇文档记录了一下自己在实际工作中实现的一些Android动画效果时的开发思路，总结了我自己如何看待Android动画问题，希望能给大家的动画开发提供一些思路和帮助。</p>
<h3 id="一、Android动画基础">一、Android动画基础</h3><h4 id="1-1_动画类型">1.1 动画类型</h4><ul>
<li><strong>Frame Animation：</strong><br>帧动画，顺序播放事先做好的图像，是一种画面转换动画</li>
<li><strong>Tween Animation:</strong><br>补间动画（或者叫渐变动画），通过对场景里的对象不断做图像变换(平移、缩放、旋转)产生动画效果<a id="more"></a></li>
<li><strong>Property Animation:</strong><br>属性动画，通过动态地改变对象的属性从而达到动画效果，属性动画为API 11新特性</li>
</ul>
<h4 id="1-2_帧动画：">1.2 帧动画：</h4><p>是指顺序执行预先设置好的一组图片，类似电影胶片的形式，设置每一帧drawable，在java代码中加载资源生成一个AnimationDrawable对象。例如：在xml中配置spin_animation.xml在文件夹res/drawable/中：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> 
<span class="tag">&lt;<span class="title">animation-list</span>  
  <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>  
  <span class="attribute">android:oneshot</span>=<span class="value">"false"</span>  &gt;</span>  
       <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/p1"</span> <span class="attribute">android:duration</span>=<span class="value">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span>  
       <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/p2"</span> <span class="attribute">android:duration</span>=<span class="value">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span>  
       <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/p3"</span> <span class="attribute">android:duration</span>=<span class="value">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span>  
       <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/p4"</span> <span class="attribute">android:duration</span>=<span class="value">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="title">item</span>&gt;</span>  
<span class="tag">&lt;/<span class="title">animation-list</span>&gt;</span>
</code></pre><p>加载资源并应用：</p>
<pre><code>// <span class="operator"><span class="keyword">Load</span> the ImageView that will host the animation <span class="keyword">and</span>
// <span class="keyword">set</span> its background <span class="keyword">to</span> our AnimationDrawable <span class="keyword">XML</span> <span class="keyword">resource</span>.
ImageView img = (ImageView)findViewById(R.<span class="keyword">id</span>.spinning_wheel_image);</span>
img.setBackgroundResource(R.drawable.spin_animation);

// Get the background, which has been compiled to an AnimationDrawable object.
AnimationDrawable frameAnimation = (AnimationDrawable) img.getBackground();

// <span class="operator"><span class="keyword">Start</span> the animation (looped playback <span class="keyword">by</span> <span class="keyword">default</span>).
frameAnimation.<span class="keyword">start</span>();</span>
</code></pre><h4 id="1-3_补间动画：">1.3 补间动画：</h4><p>补间动画有四种动画形式，分别是:</p>
<ul>
<li>alpha 渐变透明度动画效果</li>
<li>scale 渐变尺寸伸缩动画效果</li>
<li>translate 画面位置移动动画效果</li>
<li>rotate 画面旋转动画效果</li>
</ul>
<p>可以和帧动画一样在xml中配置动画，例如旋转动画rotate.xml，设置起始和终止的角度，动画中心的相对位置，动画时长等。</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> 
<span class="tag">&lt;<span class="title">set</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>  
    <span class="attribute">android:fillAfter</span> = "<span class="attribute">false</span>"  
    <span class="attribute">android:zAdjustment</span>=<span class="value">"bottom"</span> &gt;</span>  
    <span class="tag">&lt;<span class="title">rotate</span>  
        <span class="attribute">android:fromDegrees</span>=<span class="value">"0"</span>  
        <span class="attribute">android:toDegrees</span>=<span class="value">"360"</span>  
        <span class="attribute">android:pivotX</span>=<span class="value">"50%"</span>  
        <span class="attribute">android:pivotY</span>=<span class="value">"50%"</span>  
        <span class="attribute">android:duration</span>=<span class="value">"4000"</span> /&gt;</span>  
<span class="tag">&lt;/<span class="title">set</span>&gt;</span>
</code></pre><p>使用AnimationUtils加载动画的xml文件生成Animation的实例，也可以在JAVA代码中构造补间动画</p>
<pre><code><span class="comment">// 加载xml构造Animation</span>
Animation anim = AnimationUtils.loadAnimation(mContext, R.anim.rotate);
<span class="comment">// 不通过xml构造</span>
Animation rotate = <span class="keyword">new</span> RotateAnimation(<span class="number">0.0f</span>, +<span class="number">360</span>,  Animation.RELATIVE_TO_SELF, <span class="number">0.5f</span>, 
                   Animation.RELATIVE_TO_SELF, <span class="number">0.5f</span>);
</code></pre><p><img src="/res/android_animation/android_animation_animation_class.png" alt="Animation类图"></p>
<h4 id="1-4_属性动画：">1.4 属性动画：</h4><p>补间动画只能应用于视图(View)对象，动画的方式也仅限于上面所说的四种方式，而属性动画可以应用于所有的Object对象，它通过改变对象的属性值完成动画效果，当然前提是需要有该属性的get和set方法，通过在动画的过程中调用get和set方法改变对象的属性值来完成动画效果。例如通过ObjectAnimator指定要改变的对象和属性名称：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofInt(testObject, <span class="string">"data"</span>, <span class="number">0</span>, <span class="number">10</span>);
animator.start();

<span class="keyword">private</span> <span class="keyword">class</span> TestObject {
    <span class="keyword">private</span> <span class="keyword">int</span> data;
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> data;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>{
        <span class="keyword">this</span>.data = data;
    }
}
</code></pre><p>当然也通过ValueAnimator，不需要指定属性名更灵活，设置AnimatorUpdateListener，在动画更新的回调中完成想要的动作，例如，在从0到10的变化过程中，去更新视图的位置？或者其他想要的任何可能操作。</p>
<pre><code>ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">10</span>);
animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() {
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>{
    <span class="keyword">int</span> factor = (Integer) animation.getAnimatedValue();
    }
});
</code></pre><h4 id="1-5_动画插值：">1.5 动画插值：</h4><p>插值器的作用是根据时间运行的百分比来计算出当前属性改变的百分比，反映的是时间和动画进度（或属性变化）的关系，通过动画当前运行的时间，计算出当前动画的变化量。例如系统预制的线性插值器（LinearInterpolator），时间和动画进度的函数关系是y = x的直线方程，就表示当前动画是均速变化的。而当时间和动画进度的函数关系式表达为y=x^2的时候，那表示动画的变化率随着时间的增加而增加的，在视觉上就表现为加速动画。在理论上就可以通过动画插值器实现不同快慢效果的动画。</p>
<p><img src="/res/android_animation/jiasu_jiansu.png" alt="加速减速插值器，曲线的斜率是先变大后变小，说明速度是先加速后减速的"></p>
<p>在系统预制的插值器有：AccelerateInterpolator（加速插值器），AccelerateDecelerateInterpolator（加速减速插值器）， LinearInterpolator（线性插值器），BounceInterpolator（弹跳插值器），AnticipateInterpolator（回荡秋千插值器），AnticipateOvershootInterpolator， CycleInterpolator（正弦周期变化插值器），OvershootInterpolator ，我们也可以通过实现TimeTimeInterpolator或者Interpolatorr接口实现自定义的插值器。</p>
<p><img src="/res/android_animation/android_animation_interpolator_class.png" alt="Interpolator类图"></p>
<h4 id="1-6_动画估值器">1.6 动画估值器</h4><p>估值器的作用是，根据插值器结果（当前属性变化的百分比）计算出当前属性的值，系统预置的有IntEvaluator（针对整型属性）、FloatEvaluator（针对浮点型属性）和ArgbEvaluator（针对Color属性）。满足的关系是：</p>
<h3 id="二、桌面文件夹伸缩动画">二、桌面文件夹伸缩动画</h3><h4 id="2-1_IOS文件夹动画原理">2.1 IOS文件夹动画原理</h4><p>类似IOS的文件夹视图展开动画，简单说就是针对文件夹视图的一个伸缩动画，而视觉效果上的动画目标就是如何让文件夹的桌面图标和文件夹打开后的视图看起来是一个进行放大缩小的整体，处理伸缩动画的关键：<br>1.伸缩的前后比例（多少）<br>2.伸缩视图的中心坐标（相对于哪一点做伸缩）<br>针对伸缩的比例，应该是文件夹展开前后文件夹内应用图标大小确定的。针对如何确定伸缩视图的中心坐标，就需要首先确定坐标系，就是中心点是相对哪个坐标系确定的！伸缩动画坐标系的的原点在哪里？</p>
<ul>
<li>伸缩动画的坐标系是由当前缩放视图确定的，当前视图的左上角为坐标系的原点，即（0，0）点。</li>
<li>原点的水平向右方向为横坐标的正方向，平行手机屏幕垂直向下方向未纵坐标的正方向。</li>
</ul>
<p>确定了伸缩的坐标系，现在的问题就是如何确定伸缩中心点的坐标，在我们学习数学的过程中，老师教我们如何把实际问题抽象成数学问题，就像小学时经典的船在顺流和逆流中航形的问题一样。面对视图的缩放，我们能够想到的应该就是多边形的相似问题，看待现在的文件夹视图，可以抽象成一个矩形，在以矩形的左上角确定的坐标系里，从一个Size放大（或缩小）到另一个Size，在矩形长和宽变化比例相同的情况下，变化前后的矩形就是两个相似矩形，这样就可以很容易的画出下图.</p>
<p><img src="/res/android_animation/xiangsi.jpg" alt="相似矩形"></p>
<p>针对相似多边形对应点连线或者反向延长线相交于一点的原理，我们很容易得出下面的关系，即伸缩前后大小、伸缩比例和伸缩点坐标的关系式：</p>
<pre><code>h2 = <span class="built_in">offset</span> / (<span class="number">1</span>-<span class="built_in">scale</span>)
</code></pre><p>通过上面的公式，就很容易计算出文件夹视图伸缩动画的pivotX和pivotY的值计算代码：</p>
<pre><code><span class="comment">// set scale pivotX and pivotY</span>
<span class="built_in">int</span> leftOffset = folderIconRect.left - folderViewLeft;
<span class="built_in">int</span> topOffset = folderIconRect.top - folderViewTop;
<span class="built_in">float</span> <span class="variable">height</span> = folderHeight * mFolderScale;
<span class="built_in">float</span> delta = ((<span class="built_in">float</span>) folderHeight) / (folderHeight - <span class="variable">height</span>);
<span class="built_in">float</span> folderPivotX = leftOffset * delta;
<span class="built_in">float</span> folderPivotY = topOffset * delta;
</code></pre><p>但是这对展开动画仅仅解决缩放动画的问题还原因不够，因为缩放动画只是针对文件夹的视图，而针对文件夹内每个应用图标视图也应该有相应的动画，为什么？因为按照文件夹的位置进行的缩放动画，无法保证文件夹内的应用图标和文件夹图标上应用的缩略图完全重合。联想到学习过的中学物理知识，这个场景就好像你一定能够想到了分运动和合运动，火车在轨道上行驶，人在火车内行走，问人相对与地面的运动是什么样子的？整体文件夹的视图相对于它的伸缩中心点进行伸缩，文件夹视图内的应用图标相对于文件夹视图进行位移，效果又会是什么样子的？想明白这个，相信你一定能感受到选择一个正确的坐标系是多么重要。</p>
<p><img src="/android_animation/tubiaodonghua.jpg" alt="文件夹内图标动画效果"></p>
<p>抽象出了运动的理论，那计算的思路就是计算出每个应用缩略图标相对于文件夹图标的位置，计算出文件夹展开后每个应用图标相对于文件夹视图的相对位置，接合每个应用图标的伸缩比例，就能得到每个应用图标在文件夹视图的缩放过程中需要完成的位移，简单来说就是Folder的视图在缩放，Folder里的App图标在Folder视图上做相应的位移，结果你会发现是这样：</p>
<p><img src="/android_animation/guangbixiaoguo.jpg" alt="关闭效果"></p>
<p>处理完文件夹视图的问题，相信这个问题已经解决大半了，剩下的就是桌面上其他图标的移动，简单来说还是缩放动画，只需要让每个图标的缩放点和Folder视图的缩放点相对于屏幕坐标系重合就可以了。</p>
<h4 id="2-2_总结">2.2 总结</h4><p>1.处理动画问题首先确定动画起始和终止的状态，根据状态确定动画类型。<br>2.确定动画坐标系。动画坐标系如何确定取决与动画改变的属性，对于缩放动画，缩放改变是视图本身，那缩放动画的坐标系一定是相对于视图自己建立的，左上角是原点。而对于位移动画，改变translationX和X的值都能实现位置上的改变，但是他们表示的含义不一样，translationX是相对于视图本身而言的，X是相对于父布局而言的，那他们建立的坐标系肯定也不一样。<br>3.根据建立坐标系完成动画，把复杂的合运动分解成在不同坐标系上的分运动简单求解。</p>
<h3 id="三、动画源码分析（基于Android_5-0）">三、动画源码分析（基于Android 5.0）</h3><h4 id="3-1_动画插值源码">3.1 动画插值源码</h4><p>想要实现动画无非想做一件事情，就是把动画的对象在合适的时间画出合适的状态，如何控制时间？就是通过补间动画或者属性动画设置动画的时长、起始时间、起始延迟这些属性来控制动画的时间。如何控制动画状态？就可以通过动画插值，插值方法getInterpolation(input),input就是当前动画运行时间的百分比，而函数返回值就是当前动画的进度百分比，通过动画进度和动画的起始状态和结束状态来控制动画对象的当前状态。无论是补间动画或者属性动画都是定义动画状态的起始状态、终止状态、动画多久、如何动画。</p>
<h4 id="3-2_补间动画源码">3.2 补间动画源码</h4><p>先找到动画执行的入口View.startAnimation(animation)，startAnimation执行了invalidate，触发了重绘刷新视图界面。</p>
<pre><code>public void <span class="function">startAnimation</span>(<span class="attribute">Animation</span> <span class="attribute">animation</span>) {
    <span class="attribute">animation</span><span class="class">.setStartTime</span>(<span class="attribute">Animation</span><span class="class">.START_ON_FIRST_FRAME</span>);
    <span class="function">setAnimation</span>(<span class="attribute">animation</span>);
    <span class="function">invalidateParentCaches</span>();
    <span class="function">invalidate</span>(true);
}
</code></pre><p>invalidate()触发执行View.draw(Canvas canvas, ViewGroup parent, long drawingTime)函数</p>
<ul>
<li>调用动画的 getTransformation 方法，得到当前时间点的矩阵</li>
<li>将该矩阵设置成 Canvas 的当前矩阵</li>
<li>调用 canvas 的 drawBitmap 方法，绘制屏幕</li>
<li>判断 getTransformation 的返回值，若为真，调用 invalidate 方法，刷新屏幕进入下一桢；若为假，说明动画完成。</li>
</ul>
<pre><code><span class="built_in">boolean</span> draw(Canvas canvas, ViewGroup <span class="keyword">parent</span>, long drawingTime) {
    <span class="attribute">...</span><span class="attribute">...</span>
    <span class="comment">// 如果有需要执行的动画</span>
    final Animation a = getAnimation();
    <span class="keyword">if</span> (a != <span class="built_in">null</span>) {
        <span class="comment">// 根据动画和当前时间计算Transformation，并返回是否需要再继续做动画</span>
        more = drawAnimation(<span class="keyword">parent</span>, drawingTime, a, scalingRequired);
        concatMatrix = a<span class="built_in">.</span>willChangeTransformationMatrix();
        <span class="keyword">if</span> (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        <span class="comment">// 得到动画的变换结果</span>
        transformToApply = <span class="keyword">parent</span><span class="built_in">.</span>mChildTransformation;
    } <span class="keyword">else</span> {
        <span class="attribute">...</span><span class="attribute">...</span>
    }

    <span class="attribute">...</span><span class="attribute">...</span>

    float alpha = useDisplayListProperties ? <span class="number">1</span> : getAlpha();
    <span class="keyword">if</span> (transformToApply != <span class="built_in">null</span> <span class="subst">||</span> alpha &lt; <span class="number">1</span> <span class="subst">||</span> <span class="subst">!</span>hasIdentityMatrix() <span class="subst">||</span>
            (mPrivateFlags3 <span class="subst">&amp;</span> PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
        <span class="attribute">...</span><span class="attribute">...</span>
            <span class="comment">// 根据Transformation值变换canvs</span>
            <span class="keyword">if</span> (transformToApply != <span class="built_in">null</span>) {
                <span class="keyword">if</span> (concatMatrix) {
                    <span class="keyword">if</span> (useDisplayListProperties) {
                        displayList<span class="built_in">.</span>setAnimationMatrix(transformToApply<span class="built_in">.</span>getMatrix());
                    } <span class="keyword">else</span> {
                        <span class="comment">// Undo the scroll translation, apply the transformation matrix,</span>
                        <span class="comment">// then redo the scroll translate to get the correct result.</span>
                        canvas<span class="built_in">.</span>translate(<span class="attribute">-transX</span>, <span class="attribute">-transY</span>);
                        canvas<span class="built_in">.</span>concat(transformToApply<span class="built_in">.</span>getMatrix());
                        canvas<span class="built_in">.</span>translate(transX, transY);
                    }
                    <span class="keyword">parent</span><span class="built_in">.</span>mGroupFlags |= ViewGroup<span class="built_in">.</span>FLAG_CLEAR_TRANSFORMATION;
                }

                float transformAlpha = transformToApply<span class="built_in">.</span>getAlpha();
                <span class="keyword">if</span> (transformAlpha &lt; <span class="number">1</span>) {
                    alpha *= transformAlpha;
                    <span class="keyword">parent</span><span class="built_in">.</span>mGroupFlags |= ViewGroup<span class="built_in">.</span>FLAG_CLEAR_TRANSFORMATION;
                }

            <span class="keyword">if</span> (<span class="subst">!</span>childHasIdentityMatrix <span class="subst">&amp;&amp;</span> <span class="subst">!</span>useDisplayListProperties) {
                canvas<span class="built_in">.</span>translate(<span class="attribute">-transX</span>, <span class="attribute">-transY</span>);
                canvas<span class="built_in">.</span>concat(getMatrix());
                canvas<span class="built_in">.</span>translate(transX, transY);
            }
        }
        <span class="attribute">...</span><span class="attribute">...</span>
    }

    <span class="keyword">if</span> (a != <span class="built_in">null</span> <span class="subst">&amp;&amp;</span> <span class="subst">!</span>more) {
        <span class="keyword">if</span> (<span class="subst">!</span>hardwareAccelerated <span class="subst">&amp;&amp;</span> <span class="subst">!</span>a<span class="built_in">.</span>getFillAfter()) {
            onSetAlpha(<span class="number">255</span>);
        }
        <span class="keyword">parent</span><span class="built_in">.</span>finishAnimatingView(this, a);
    }

    <span class="comment">// 根据动画进度判断是否需要继续重绘</span>
    <span class="keyword">if</span> (more <span class="subst">&amp;&amp;</span> hardwareAccelerated) {
        <span class="comment">// invalidation is the trigger to recreate display lists, so if we're using</span>
        <span class="comment">// display lists to render, force an invalidate to allow the animation to</span>
        <span class="comment">// continue drawing another frame</span>
        <span class="keyword">parent</span><span class="built_in">.</span>invalidate(<span class="literal">true</span>);
        <span class="keyword">if</span> (a<span class="built_in">.</span>hasAlpha() <span class="subst">&amp;&amp;</span> (mPrivateFlags <span class="subst">&amp;</span> PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            <span class="comment">// alpha animations should cause the child to recreate its display list</span>
            invalidate(<span class="literal">true</span>);
        }
    }

    mRecreateDisplayList = <span class="literal">false</span>;

    <span class="keyword">return</span> more;
}
</code></pre><p>时序图：</p>
<h4 id="3-2_属性动画源码">3.2 属性动画源码</h4><p>onsync时序图：<br><img src="/res/android_animation/choreographer_seq_diag.png" alt="choreographer onVsync时序图"></p>
<p>从ObjectAnimator的start()方法开始,跳转到父类ValueAnimator的start()方法，为了减少篇幅，这里的代码就不贴出来了，详细的代码可以查看从ObjectAnimator.java。</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{
    <span class="comment">// See if any of the current active/pending animators need to be canceled</span>
    <span class="comment">// 这里先判断当前的动画、等待的动画和延迟执行的动画和this去比较，如果动画的目标对象相同并且属性相同就取消相同的动画。</span>
    ......

    <span class="keyword">super</span>.start();
}
</code></pre><p>ValueAnimator的start(boolean)方法只是做了两件事：<br>1.把当前的animator加入等待队列中，<br>2.启动animationHandler。AnimationHandler并不是一个Handler，而是Runnable。</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> playBackwards)</span> </span>{
    <span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Animators may only be run on Looper threads"</span>);
    }

    ......

    AnimationHandler animationHandler = getOrCreateAnimationHandler();
    animationHandler.mPendingAnimations.add(<span class="keyword">this</span>);
    <span class="keyword">if</span> (mStartDelay == <span class="number">0</span>) {
        <span class="comment">// This sets the initial value of the animation, prior to actually starting it running</span>
        setCurrentPlayTime(<span class="number">0</span>);
        mPlayingState = STOPPED;
        mRunning = <span class="keyword">true</span>;
        notifyStartListeners();
    }
    animationHandler.start();
}
</code></pre><p>将AnimationHandler对象传递给Choreographer(编舞者)，Choreographer是和线程绑定的单例。告诉编舞者，我是一个CALLBACK_ANIMATION(动画类型)，你自己看着办吧。</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">scheduleAnimation</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (!mAnimationScheduled) {
        mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, <span class="keyword">this</span>, <span class="keyword">null</span>);
        mAnimationScheduled = <span class="keyword">true</span>;
    }
}
</code></pre><p>编舞者根据callbackType(就是上面的CALLBACK_ANIMATION类型)，把当前的action(就是animationHandler)加入相应类型的Callback队列等待被执行。并且安排下一帧的时间。</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> postCallbackDelayedInternal(<span class="built_in">int</span> callbackType,
        <span class="keyword">Object</span> action, <span class="keyword">Object</span> token, <span class="keyword">long</span> delayMillis) {

    <span class="keyword">synchronized</span> (mLock) {
        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();
        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;
        <span class="comment">// 加入相应类型的Callback队列等待被执行</span>
        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);

        <span class="keyword">if</span> (dueTime &lt;= now) {
            scheduleFrameLocked(now);
        } <span class="keyword">else</span> {
            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);
            msg.arg1 = callbackType;
            msg.setAsynchronous(<span class="keyword">true</span>);
            mHandler.sendMessageAtTime(msg, dueTime);
        }
    }
}
</code></pre><p>如果使用Vsync，通过FrameDisplayEventReceiver的scheduleVsync方法，申请一次VSYNC中断，这样就可以在中断处理的onVsync函数去进行绘制。如果不需要直接发送MSG_DO_FRAME消息。</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>{
    <span class="keyword">if</span> (!mFrameScheduled) {
        mFrameScheduled = <span class="keyword">true</span>;
        <span class="keyword">if</span> (USE_VSYNC) {
            <span class="comment">// If running on the Looper thread, then schedule the vsync immediately,</span>
            <span class="comment">// otherwise post a message to schedule the vsync from the UI thread</span>
            <span class="comment">// as soon as possible.</span>
            <span class="comment">// 如果使用VSYNC就申请一次中断请求</span>
            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) {
                scheduleVsyncLocked();
            } <span class="keyword">else</span> {
                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);
                msg.setAsynchronous(<span class="keyword">true</span>);
                mHandler.sendMessageAtFrontOfQueue(msg);
            }
        } <span class="keyword">else</span> {
            <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(
                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);
            <span class="comment">// 如果不是要VSYNC，就直接触发MSG_DO_FRAME</span>
            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
            msg.setAsynchronous(<span class="keyword">true</span>);
            mHandler.sendMessageAtTime(msg, nextFrameTime);
        }
    }
}
</code></pre><p>上面注册一个了reciver，在VSYNC发生的时候接受到消息，就会触发onVsync方法,执行当前的FrameDisplayEventReceiver Runnable。</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>{
    ......
    Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);
    msg.setAsynchronous(<span class="keyword">true</span>);
    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
    mHavePendingVsync = <span class="keyword">false</span>;
    doFrame(mTimestampNanos, mFrame);
}
</code></pre><p>我们看doFrame方法做了什么？调用doCallbacks方法，获取当前类型的等待序列中在当前时间的callback，得到action并执行run方法，在这里callback的action就是AnimationHandler。</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>{
    ......
    <span class="comment">// 优先级最高，和输入事件处理有关</span>
    doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);
    <span class="comment">// 优先级其次，和Animation的处理有关</span>
    doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
    <span class="comment">// 优先级最低，和UI等控件绘制有关</span>
    doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
}


<span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>{
    CallbackRecord callbacks;
    <span class="keyword">synchronized</span> (mLock) {
        <span class="comment">// We use "now" to determine when callbacks become due because it's possible</span>
        <span class="comment">// for earlier processing phases in a frame to post callbacks that should run</span>
        <span class="comment">// in a following phase, such as an input event that causes an animation to start.</span>
        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();
        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now);
        <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) {
            <span class="keyword">return</span>;
        }
        mCallbacksRunning = <span class="keyword">true</span>;
    }
    <span class="keyword">try</span> {
        <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) {
            <span class="comment">// 在这里回调callback的action</span>
            c.run(frameTimeNanos);
        }
    }
    ......
}
</code></pre><p>终于回调了AnimationHandler的run方法，代码很多，起始无非就是让应该启动的animation启动起来，该延迟的放在延迟队列，正在做动画的调用doAnimationFrame方法，动画播放结束的就结束动画。当然如果还需要继续动画那就继续调用scheduleAnimation方法，告诉编舞者，还有呢，继续在下个帧时间执行我。当然所有时间控制是根据VSYNC回调上来的时间和每个动画的时间信息共同控制的。</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>{
    ......
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) {
        ValueAnimator anim = mTmpAnimations.get(i);
        <span class="keyword">if</span> (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime)) {
            mEndingAnims.add(anim);
        }
    }
    ......
    <span class="comment">// If there are still active or delayed animations, schedule a future call to</span>
    <span class="comment">// onAnimate to process the next frame of the animations.</span>
    <span class="keyword">if</span> (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) {
        scheduleAnimation();
    }
}
</code></pre><h4 id="3-3_动画源码总结">3.3 动画源码总结</h4><p>1.针对视图来说，Animation和Scroller相似，都是如何控制视图的重绘，它们都指示定义了在某一个特定时刻我应该画成什么样子。<br>2.Choreographer实际上是视图所有重绘进度的实际控制者，因为它在控制着时间节奏，告诉应用们什么时间可以画，视图不需要自己控制刷新时间。<br>3.回头看Animation的源码分析，视图的重绘最终是触发ViewRootImpl的invalidate函数，该函数将最终调用ViewRootImpl的scheduleTraversals。同样是通过mChoreographer只是类型变成了CALLBACK_TRAVERSAL，代码如下所示：</p>
<pre><code>void scheduleTraversals<span class="literal">()</span> {
    <span class="keyword">if</span> (!mTraversalScheduled) {
        mTraversalScheduled = <span class="literal">true</span>;
        mTraversalBarrier = mHandler.getLooper<span class="literal">()</span>.postSyncBarrier<span class="literal">()</span>;
        mChoreographer.postCallback(
                <span class="type">Choreographer</span>.<span class="type">CALLBACK_TRAVERSAL</span>, mTraversalRunnable, null);
        <span class="keyword">if</span> (!mUnbufferedInputDispatch) {
            scheduleConsumeBatchedInput<span class="literal">()</span>;
        }
        notifyRendererOfFramePending<span class="literal">()</span>;
    }
}
</code></pre><p>4.Asynchronous Message和Synchronization Barrier我还没有理解，当你觉得自己明白了的时候，其实你还有很多不知道，当你觉得你不明白的时候，那是你真的不知道。不知道还是不知道！！</p>
<h3 id="四、参考文档">四、参考文档</h3><p><a href="http://blog.csdn.net/lmj623565791/article/details/38067475" target="_blank" rel="external">Android 属性动画（Property Animation） 完全解析 （上）</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/38092093" target="_blank" rel="external">Android 属性动画（Property Animation） 完全解析 （下）</a><br><a href="http://www.uml.org.cn/mobiledev/201301081.asp" target="_blank" rel="external">Android Project Butter分析</a><br><a href="http://developer.android.com/reference/android/view/Choreographer.html" target="_blank" rel="external">http://developer.android.com/reference/android/view/Choreographer.html</a><br><a href="http://developer.android.com/reference/android/view/Choreographer.FrameCallback.html" target="_blank" rel="external">http://developer.android.com/reference/android/view/Choreographer.FrameCallback.html</a><br><a href="https://github.com/samchen2009/android_uml" target="_blank" rel="external">https://github.com/samchen2009/android_uml</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;说在开始&quot;&gt;说在开始&lt;/h3&gt;&lt;p&gt;这篇文档记录了一下自己在实际工作中实现的一些Android动画效果时的开发思路，总结了我自己如何看待Android动画问题，希望能给大家的动画开发提供一些思路和帮助。&lt;/p&gt;
&lt;h3 id=&quot;一、Android动画基础&quot;&gt;一、Android动画基础&lt;/h3&gt;&lt;h4 id=&quot;1-1_动画类型&quot;&gt;1.1 动画类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Frame Animation：&lt;/strong&gt;&lt;br&gt;帧动画，顺序播放事先做好的图像，是一种画面转换动画&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tween Animation:&lt;/strong&gt;&lt;br&gt;补间动画（或者叫渐变动画），通过对场景里的对象不断做图像变换(平移、缩放、旋转)产生动画效果
    
    </summary>
    
    
      <category term="Android" scheme="https://ivonhoe.github.io/tags/Android/"/>
    
      <category term="动画" scheme="https://ivonhoe.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
</feed>
