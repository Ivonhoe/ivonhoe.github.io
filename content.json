{"meta":{"title":"病已的博客","subtitle":"枕上，马上，厕上","description":null,"author":"病已","url":"https://ivonhoe.github.io","root":"/"},"pages":[{"title":"关于","date":"2017-04-18T05:18:40.000Z","updated":"2022-03-26T14:15:43.711Z","comments":true,"path":"about/index.html","permalink":"https://ivonhoe.github.io/about/index.html","excerpt":"","text":"关于博客 博客定位：总结工作中遇到的问题和相应解决方案，记录下自身学习过程中的一点思考，希望当自己回首往事的时候不会因碌碌无为而悔恨。 关于笔名：病已，释义病已愈。希望每天都像大病初愈般焕然一新，珍惜当下。 联系方式 邮箱: &#121;&#x61;&#110;&#103;&#x66;&#x61;&#x6e;&#51;&#54;&#56;&#55;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#111;&#x6d; 微信: tykYang"},{"title":"标签","date":"2017-04-18T04:40:04.000Z","updated":"2017-04-18T05:20:07.000Z","comments":false,"path":"tags/index.html","permalink":"https://ivonhoe.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-04-18T05:18:52.000Z","updated":"2017-04-18T05:19:33.000Z","comments":false,"path":"categories/index.html","permalink":"https://ivonhoe.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"如何排查flutter性能问题","slug":"flutter-dev-tools","date":"2022-04-08T16:00:51.000Z","updated":"2022-05-25T16:54:31.519Z","comments":true,"path":"2022/04/09/flutter-dev-tools/","link":"","permalink":"https://ivonhoe.github.io/2022/04/09/flutter-dev-tools/","excerpt":"Flutter官方提供了Flutter DevTools和一些IDE Flutter plugin来辅助开发者进行性能评测，除了这些工具以外，还可以借助Dart和skia引擎提供的工具进行性能分析和调试。这里简单介绍下，Dart的Observatory和Skp Debugger的使用。","text":"Flutter官方提供了Flutter DevTools和一些IDE Flutter plugin来辅助开发者进行性能评测，除了这些工具以外，还可以借助Dart和skia引擎提供的工具进行性能分析和调试。这里简单介绍下，Dart的Observatory和Skp Debugger的使用。 0x01 ObservatoryObservatory是Dart VM的性能分析工具，可以借助Observatory对Dart VM进行内存，cpu，线程，渲染流程等方面的分析，在进行页面绘制性能分析时，可借助Observatory的timeline工具进行辅助分析。可以通过以下两种方式打开Observatory URL的Web页面。更详细信息可以查看官方文档：https://flutterchina.club/debugging/https://dart.cn/tools/dart-devtools 1.通过flutter run打开Observatory可以使用flutter run --profile | grep 127命令可以看到，在终端中包含了观测台的地址 2. 通过Android Studio打开Observatory1.通过点击Android studio底部的工具栏图标，打开Devtools 2.在截取浏览器中显示的uri参数 3.借助urldecode工具解码，两次decode后就是Observatory本地服务地址。 0x02. Observatory Timeline1. Flutter debug flagFlutter提供了很多debug flag用来帮助开发者跟踪不同处理流程的执行过程，需要注意的是，所有debug开头的flag只有在debug模式下才会生效，如 debugProfileBuildsEnable：向Timeline事件中添加每个widget的build信息 debugProfileLayoutEnabled：向Timeline事件中添加每个renderObject的layout信息 debugProfilePaintEnabled: 向Timeline事件中添加每个renderObject的paint信息 debugPaintLayerBoadersEnabled: 来用为每个layer的边界显示橙色边框 debugPrintRebuildDirtyWidgets：打印标记为dirty的widgets debugPrintBeginFrameBanner&#x2F;debugPrintEndFrameBanner：打印每帧开始和结束 最简单的方式是在程序顶部入口void main()中设置它，如下案例代码所示：这样我们就可以在Observatory的Timeline中查看widget build在每一帧中的调用和耗时情况 2. 自定义Timeline跟踪要执行自定义性能跟踪和测量Dart任意代码段的wall&#x2F;CPU时间（类似于在Android上使用systrace）。 使用dart:developer的Timeline工具来包含你想测试的代码块，例如： 123Timeline.startSync(&#x27;interesting function&#x27;);// iWonderHowLongThisTakes();Timeline.finishSync(); 这段代码等同于Android原生端的beginSection和endSection 123Trace.beginSection(&quot;&quot;);// xxxxxTrace.endSection(); 然后打开你应用程序的Observatory timeline页面，在”Recorded Streams”中选择’Dart’复选框，并执行你想测量的功能。刷新页面将在Chrome的跟踪工具中显示应用按时间顺序排列的timeline记录。 3. 使用Observatory查看skia绘图指令使用命令：flutter run --profile --trace-skia重点关注saveLayer和clipPath函数的调用 0x03. skpdebugger通过抓取skp，回放每条skia绘图指令的执行过程，可以在屏幕上直观的看到绘制流程的每个步骤，单步分析每一条绘图指令，从而定位在单帧绘制中影响绘制效率的问题。点击查看【bilibili】 使用步骤： 使用flutter screenshot --type=skia --observatory-uri=uri命令，抓取一帧skia绘图指令的执行过程，截取skp可以单步检测每条绘图指令 将生成的skp文件上传https://debugger.skia.org/注意：Android Studio4.1版本更改了插件的安装路径，在Flutter1.23以下，flutter doctor命令可能会找不到AS的flutter&amp;Dart plugin，导致flutter screenshot命令执行失败，这里可使用以下命令解决：ln -s ~/Library/Application\\ Support/Google/AndroidStudio4.1/plugins ~/Library/Application\\ Support/AndroidStudio4.1 0x04 总结 profile模式是最接近release的性能表现，当需要获取flutter app较为真实的性能评测数据时，要使用profile进行测试。而需要对具体的build paint流程进行详细分析时使用debug模式进行trace 使用真机，不要使用模拟器，尤其是不要使用iOS的模拟器，模拟器没有硬件加速，所以在模拟器的测试数据和真机的差别会很大 skpdebugger是神器，通过对单帧绘制指令的采集，可以很清晰的看到在绘制中不合理的部分。针对不合理的绘制进行单帧绘制优化 重点关注saveLayer和clipPath的调用 参考文档https://www.sunmoonblog.com/2020/01/10/flutter-performance-tools/https://cloud.tencent.com/developer/article/1591997https://flutterchina.club/debugging/https://flutter.cn/docs/testing/code-debugging","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"flutter","slug":"flutter","permalink":"https://ivonhoe.github.io/tags/flutter/"}]},{"title":"JDK ServiceLoader加载优化","slug":"java-spi","date":"2022-02-08T14:53:51.000Z","updated":"2022-05-25T16:54:41.175Z","comments":true,"path":"2022/02/08/java-spi/","link":"","permalink":"https://ivonhoe.github.io/2022/02/08/java-spi/","excerpt":"本文记录在启动优化项目中解决ServiceLoader加载长耗时问题的方案，介绍了JDK ServiceLoader在安卓平台中会带来哪些问题，方案执行过程中遇到的问题和相应的思考。特别是在一个负责的业务系统中，如何选择技改方案，保证方案的顺利落地。","text":"本文记录在启动优化项目中解决ServiceLoader加载长耗时问题的方案，介绍了JDK ServiceLoader在安卓平台中会带来哪些问题，方案执行过程中遇到的问题和相应的思考。特别是在一个负责的业务系统中，如何选择技改方案，保证方案的顺利落地。 0x01 什么是Java SPI？SPI，全称Service Provicer Interface。在JDK1.6内置的一套服务发现机制，主要用来服务架构扩展和替换组件。在面向对象设计中，最基本的原则就是面向接口编程，通过接口暴露模块的功能定义，将具体的接口实现隐藏在模块内部。而服务发现机制，提供了通过接口获取服务实现的能力，实现模块的可插拔、可拓展、可替换。保证了由调用方在调用时选择自己需要的外部实现。 简单来是在利用JDK提供的ServiceLoader机制可以通过以下几个步骤： 定义接口类 定义接口实现类 将实现类的类名保存在META-INFO/services目录中，文件名为接口类的类名 使用java.util.ServiceLoader.load方法加载接口类，获取到在META-INFO中定义的接口实现类 在META-INFO中的声明形式大致如下所示： 0x02 JDK ServiceLoader存在哪些问题？Autoservice组件解决了什么问题？我们经常使用的autoservice（https://github.com/google/auto）解决了什么问题呢？其实autoservice只是提供了注解和注解处理器的能力，通过自定义一个annotationprocessor将@AutoService注解标记的实现类信息，收集起来并保存到META-INFO/services目录中。通过注解的方式将上面的步骤3优化掉了，这样既提高了效率，又避免了方案变更时需要手动更新配置文件的问题。 Android中使用JDK ServiceLoader会带来什么问题？主要是类配置文件的加载耗时问题。在java项目中，java.util.ServiceLoader通过加载jar文件META-INFO&#x2F;services目录下的配置文件获取实现类信息，当在Android项目中，java.util.ServiceLoader时通过加载apk包目录下META-INFO&#x2F;services中的配置文件，这里都涉及到整个zip文件的遍历，加载效率是非常低的，一般情况下会导致几百毫秒的耗时。而如果在一些关键流程中触发了JDK ServiceLoader的加载，几百毫秒就会带来很差的用户体验。 0x03 如何解决JDK ServiceLoader带来的问题？先梳理现状： 项目中大量使用了多个改造自autoservice组件的注解处理器，在meta-info目录下生成了多个配置文件 耗时主要发生在启动流程业务初始化阶段，使用JDK serviceloader加载meta-info下的配置文件导致了长耗时 ServiceLoader加载耗时过长的主要原因是，需要从zip文件中检索出meta-info目录下的配置文件，想要提升配置加载的效率，解决方法也很简单，可以将配置文件保存到更容易加载的地方，这里可以选择将配置信息保存到安卓原生提供的资源路径下，也可以选择将配置信息保存到类文件中。当然想要在相对复杂的业务系统中解决一个问题，既包括解决技术问题本身，也需要考虑到方案落地的成本和影响面。特别是高业务价值低技术价值的遗产系统中做技术优化，首先保证的是兼容现有业务逻辑。这里优先选择将相关配置信息保存在类文件中，借助android编译插件技术，在编译期间做信息收集，在运行时通过类加载的方式将所需service信息加载出来。这里可以主要参考wmrouter的实现思路，但是又稍有差别。先对比wmrouter的实现方案，可以发现大致可以分为以下几个步骤： 开发编码流程，定义服务接口，通过注解标记服务实现类 组件aar发布流程，通过annotationprocessor生成.class的文件，将服务实现的类信息保存在自动生成的.class文件中 编译打包流程，通过gradle插件收集步骤2中新生成的所有类，因为服务实现可能分布在项目中的多个组件中，所以在apk整包的编译流程，需要将所有服务实现的类信息统一收集起来，并加入到初始化的代码中。 通过以上流程的说明，可以看到整个流程被分为两步： annotationprocessor通过将注解转换成jvm字节码 通过AGP transform生成初始化代码，将jvm的初始化调用收集起来在初始化时统一调用 前面也提到，在现有的遗产系统中，如果照搬wmrouter的方案会存在什么问呢？如果照搬上述的方案，在annotationprocessor处理阶段，需要将所有使用autoservice @AutoService的组件使用新的annotationprocessor重新发布一边。这个工作量和变更范围是巨大的。有没有更优化的方案呢？ 解决思路也很直接，将注解的收集和配置信息保存到类文件合并成一步。 通过在AGP transform流程中收集注解，同时使用ASM框架动态生成相关字节码，将相关的实现类信息保存到类文件中。就可以避免重新发布大量业务组件的问题，将变更范围控制到最小。 0x04 总结ServiceLoader带来的性能问题，一旦被发现，解决思路其实是很直接的，并没有太多拐弯的地方。但是在这个技术方案落地的过程中遇到的问题比技术方案本身多很多。特别是在已有大量业务系统在使用的组件中做技改，影响面的评估和回滚方案是要优先被考虑的，所以在运行时加载配置阶段，需要通过配置开关控制是优先加载类信息还是保持原加载流程不变，来做到技改方案可观测可回滚。同时在技术方案的选择上，应该选择影响面尽可能小，变更尽可能少的方案。尽可能避免业务方的更改。 参考文档https://zhuanlan.zhihu.com/p/28909673https://github.com/meituan/WMRouter","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"ASM","slug":"ASM","permalink":"https://ivonhoe.github.io/tags/ASM/"},{"name":"SPI","slug":"SPI","permalink":"https://ivonhoe.github.io/tags/SPI/"}]},{"title":"访问者模式","slug":"design-patterns-visitor","date":"2021-03-27T16:19:59.000Z","updated":"2022-05-25T16:55:11.943Z","comments":true,"path":"2021/03/28/design-patterns-visitor/","link":"","permalink":"https://ivonhoe.github.io/2021/03/28/design-patterns-visitor/","excerpt":"在实际工作中经常用到访问者模式，是比较常见的设计模式，本文主要通过以下几个方面来学习访问者模式： 什么是访问者模式，访问者模式想要解决的问题是什么？ 访问者模式的经典应用有哪些?","text":"在实际工作中经常用到访问者模式，是比较常见的设计模式，本文主要通过以下几个方面来学习访问者模式： 什么是访问者模式，访问者模式想要解决的问题是什么？ 访问者模式的经典应用有哪些? 0x01 单分派和双重分派在介绍设计模式之前，先了解几个基础的概念。了解概念的含义并不是为了咬文嚼字，而是希望能从原理上理解设计模式背后想要解决的问题 重写（override）和重载（overload） 重写，就是子类重写了父类的方法，返回值和形参都不能改变。当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。 重载，在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 单分派和双重分派 分派（Dispatch），在面向对象的语言中，可以把一次函数调动理解成一个消息事件的分发，如a.test(b)，a就是消息的接受者，这个函数的调用方就是消息的发送者。 单分派（Single Dispatch），这里的单（Single）指的是，哪个对象的方法会被执行，只跟这个对象的运行时类型有关。以a.test(b)为例，如在Java中，在被执行的test函数，只跟a对象的运行时类型有关。 双重分派(Double Dispatch)，这里的双（double）指的是，哪个对象的方法被执行，跟对象和方法参数的运行时类型都有关。还是以a.test(b)为例，哪个test函数被执行，不单单和a对象的类型有关还和b对象的类型有关。 可以看到所谓分派就是函数的调用，所谓单分派和双分派就是和语言的多态特性有关，在常见的Java，C++，C#语言中，在语言层面都是只支持单分派的。想要实现双重分派，就要借助设计模式，比如访问者模式。你肯定会问，双重分派的作用是什么？不解决双重分派的问题不行吗？其实这种问题在项目代码中一定俯拾皆是，类似下面的这种代码，我们想要针对不同类型的文件（pdf，ppt，word）执行不同的文件提取和文件压缩操作。试想下，可能是你来实现，你要怎么做？是不是很容易写出下面这样的代码 1234567891011121314151617181920212223class Extractor extends Processor &#123; void processFile(ResourceFile file) &#123; if (file instanceof PdfFile) &#123; processPrdFile((PdfFile)file); &#125; else if (file instanceof PowerPointFile) &#123; processPowerPointFile((PowerPointFile)e); &#125; else if (file instanceof WordFile) &#123; processWordFile((WordFile)e); &#125; &#125;&#125;class Compressor extends Processor &#123; void processFile(ResourceFile file) &#123; if (file instanceof PdfFile) &#123; processPrdFile((PdfFile)file); &#125; else if (file instanceof PowerPointFile) &#123; processPowerPointFile((PowerPointFile)e); &#125; else if (file instanceof WordFile) &#123; processWordFile((WordFile)e); &#125; &#125;&#125; 可以看到这段代码的逻辑执行，既要根据接收者的运行时类型来决定processXXXFile(file)的执行，这里的接收者可以理解成是当前方法所对应的Processor对象。又要根据ResourceFile file对象的运行时的实际类型来做类型的判断，这里就会有很多instanceof和else if,switch case的多重嵌套。这种设计的代码虽然可以实现功能，但是在面对需求变更和扩展时会非常不灵活，既要加很多else if，也不利于功能的内聚和复用。那么这些代码如果用访问者模式，应该怎么来实现呢？这里借用王争在&lt;&lt;设计模式之美&gt;&gt;中的实例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public abstract class ResourceFile &#123; protected String filePath; public ResourceFile(String filePath) &#123; this.filePath = filePath; &#125; abstract public void accept(Visitor vistor);&#125;public class PdfFile extends ResourceFile &#123; public PdfFile(String filePath) &#123; super(filePath); &#125; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; //...&#125;//...PPTFile、WordFile跟PdfFile类似，这里就省略了...public interface Visitor &#123; void visit(PdfFile pdfFile); void visit(PPTFile pdfFile); void visit(WordFile pdfFile);&#125;public class Extractor implements Visitor &#123; @Override public void visit(PPTFile pptFile) &#123; //... System.out.println(&quot;Extract PPT.&quot;); &#125; @Override public void visit(PdfFile pdfFile) &#123; //... System.out.println(&quot;Extract PDF.&quot;); &#125; @Override public void visit(WordFile wordFile) &#123; //... System.out.println(&quot;Extract WORD.&quot;); &#125;&#125;public class Compressor implements Visitor &#123; @Override public void visit(PPTFile pptFile) &#123; //... System.out.println(&quot;Compress PPT.&quot;); &#125; @Override public void visit(PdfFile pdfFile) &#123; //... System.out.println(&quot;Compress PDF.&quot;); &#125; @Override public void visit(WordFile wordFile) &#123; //... System.out.println(&quot;Compress WORD.&quot;); &#125;&#125;public class ToolApplication &#123; public static void main(String[] args) &#123; List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]); Extractor extractor = new Extractor(); for (ResourceFile resourceFile : resourceFiles) &#123; resourceFile.accept(extractor); &#125; Compressor compressor = new Compressor(); for(ResourceFile resourceFile : resourceFiles) &#123; resourceFile.accept(compressor); &#125; &#125; private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) &#123; List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;(); //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile) resourceFiles.add(new PdfFile(&quot;a.pdf&quot;)); resourceFiles.add(new WordFile(&quot;b.word&quot;)); resourceFiles.add(new PPTFile(&quot;c.ppt&quot;)); return resourceFiles; &#125;&#125; 0x02 ASM中的访问者模式上面介绍了访问者模式设计初衷和设计方法，这里再看下访问者模式在实际工程中的应用。访问者模式最常见的应用场景就是访问复杂的结构或者对象，在不改变数据结构的情况下，将数据访问和数据操作分离出来，用回调的方式在访问者中处理业务逻辑。在面对不同的访问处理时，只需要新定义一个访问者实现不同的访问处理逻辑就可以了。这样说可能也很抽象，可以在在ASM中，是如何利用访问者的设计模式，实现字节码文件的读取和修改的。ASM使用ClassReader遍历class文件结构获取文件中的类和对象信息，在其accept方法中接收ClassVisitor，在ClassVisitor的不同回调方法中完成不同的字节码操作。可以通过代码示例看到主要有以下几个类： 123456ClassReader cr = new ClassReader(inputStream);ClassWriter cw = new ClassWriter(cr, 0);ClassVisitor cv = new InjectCassVisitor(ASM6, cw, methodName);cr.accept(cv, 0);return cw.toByteArray(); ClassReader（Element）：将不同输入类型的字节码读取到内存中，通过accept方法接受ClassVisitor的访问。 ClassVisitor（Visitor）：完全由开发者自定义不同类型的Visitor，在Visitor的visitXXX回调中接收读取到的字节码信息并进行相应的处理。 0x03 总结利用访问者模式来解决这样的双重分派问题，如上面的类图所示，通过几个角色来做功能的区分，将文件的访问和处理分离成两个独立的接口。 访问者（Visitor），这里指不同类型的文件操作。用一个接口和一组不同类型的具体实现来定义不同的操作类型。 被访问者（Element），这里指不同类型的文件。定义了accept操作，以Visitor作为参数，来接受不同类型visitor的对象访问。在accept方法中将this传递给访问者，通过回调再回调的操作，实现了双重分派。 对象结构（ObjectStructure），访问的组织者，可以是组合也可以是集合；能够枚举它包含的元素；提供一个接口，允许Vistor访问它的元素。 理解访问者模式的设计，我觉得重点在理解所谓的回调再回调。这里有两次回调就意味着有两种类型接口，第一次回调是被访问者通过accept接受访问者，第二次回调是访问者通过visit方法访问被访问者，通过两次互相调换类型的调用，也就是通过两次单分派实现了双重分派。 参考文档王争&lt;&lt;设计模式之美&gt;&gt;https://www.jianshu.com/p/cd17bae4e949https://www.liaoxuefeng.com/wiki/1252599548343744/1281319659110433","categories":[{"name":"方案与设计","slug":"方案与设计","permalink":"https://ivonhoe.github.io/categories/%E6%96%B9%E6%A1%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://ivonhoe.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理模式","slug":"design-patterns-proxy","date":"2021-03-27T16:19:47.000Z","updated":"2022-05-25T16:55:00.230Z","comments":true,"path":"2021/03/28/design-patterns-proxy/","link":"","permalink":"https://ivonhoe.github.io/2021/03/28/design-patterns-proxy/","excerpt":"其实在日常生活中我们经常和代理模式打交道，比如当我们需要预定酒店时，我们（使用方）通常选择类似携程这样的平台来进行酒店和机票的预定，这里携程（代理）就代理了和酒店（服务提供方）之间的预订流程，使用方通过代理实现了和真实服务提供者之间的操作，那么为什么会使用代理而不是直接和服务提供方进行业务操作呢？可以通过以下两方面来考量： 代理降低了沟通成本，使用者不需要和服务提供方建立通讯，所有的通讯都通过代理商来完成，这样就将1对多的关系简化成1对1的关系，简化了业务流程，降低沟通成本。 隐藏了服务提供者之间的差异，拿订酒店这件事情为例，让用户只需要关注到订酒店这件事情，和订酒店无关的其他事情都由代理商来做了","text":"其实在日常生活中我们经常和代理模式打交道，比如当我们需要预定酒店时，我们（使用方）通常选择类似携程这样的平台来进行酒店和机票的预定，这里携程（代理）就代理了和酒店（服务提供方）之间的预订流程，使用方通过代理实现了和真实服务提供者之间的操作，那么为什么会使用代理而不是直接和服务提供方进行业务操作呢？可以通过以下两方面来考量： 代理降低了沟通成本，使用者不需要和服务提供方建立通讯，所有的通讯都通过代理商来完成，这样就将1对多的关系简化成1对1的关系，简化了业务流程，降低沟通成本。 隐藏了服务提供者之间的差异，拿订酒店这件事情为例，让用户只需要关注到订酒店这件事情，和订酒店无关的其他事情都由代理商来做了 什么是「代理模式」？代理控制了对象的真实访问。代理模式是指，在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。主要解决在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。这里直接访问对象时带来的问题，可以类比上面生活中的例子，车站买票太远（对象单次访问成本高）选择用代买点买票。直接去酒店订房间太麻烦（实现功能的对象太多无法直接选择出最佳的对象）而选择在酒店平台预定酒店。 0x01 Binder中的静态代理几乎所有安卓开发应该都应该知道，binder是android中实现进程间通信的方案，也都听说过所谓共享内存、Socket、管道、消息队列等等一系列其他的进程间通信（IPC）的方案，甚至听说过诸如dubbo，spring cloud之类的远程过程调用（RPC）。这里binder作为一个IPC方案同时在设计上又有很多RPC方案的影子，如果说想要理解RPC，这里一定绕不开代理模式。不管是Android的binder还是后端消息中间件dubbo都是使用代理模式来做设计的，在通讯的两端分别用代理隐藏实际的通信细节，让调用方像调用自己进程内对象方法一样实现对跨进程对象的调用。你比较熟悉组件化开发的话，也可以先从组件化的视角来类比binder通信，如果让你来实现一个进程间通信的架构方案，有哪些东西是必不可少的呢？ 先类比组件化 面向接口的设计，组件间通信，通过接口暴露组件能力 通过一个manager查询接口对应的服务实例，组件间相互调用，意味着组件间能够通过某种方式获取定义的组件接口所对应的实例对象，实现调用其他组件的方法就像调用自己内部方法一样 服务的注册和查询，想要获取响应的接口实现，意味着有一个类似路由和路由表的东西，通过一个路由服务查询到具体的接口实现对象 其他高性能、安全性、稳定性的设计 再看Binder IPC， 开发者使用AIDL实现进程间通信接口的定义 123interface IMyAidlInterface &#123; Response aidlGet(in Request request);&#125; 调用者client通过context bindService获取远程服务的代理对象，通过queryLocalInterface和Stub.DESCRIPTOR查询到远程服务在client的代理对象 12345678910public static com.android.aidldemo.IMyAidlInterface asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.android.aidldemo.IMyAidlInterface))) &#123; return ((com.android.aidldemo.IMyAidlInterface) iin); &#125; return new com.android.aidldemo.IMyAidlInterface.Stub.Proxy(obj);&#125; 对client来说，Binder代理对象Stub.proxy隐藏了和远程服务对象真实通信的细节，client不需要关心这个代理对象是不是真实的服务实现方，就像调用本地方法一样调用原生服务对象。而Stub.proxy实现了调用参数的序列化和响应结果的序列化，帮助client拿到了远程调用的结果。 可以对照下图理解代理过程： 同样的角色分布我们可以再看看系统的ActivityManagerService。IActivityManager是一个服务接口，代表了服务能力。ActivityManagerNative代表系统本地服务，ActivityManagerService是它的具体实现。而ActivityMangerProxy代表在app中的Binder代理对象，实现client到service调用的代理转发。 0x02 Retrofit中的动态代理相比较Binder的静态代理，retrofit使用了动态代理模式。所谓动态代理模式，是指并没有手动创建一个代理类，而是使用动态字节码的方式创建代理类（用class生成class），然后使用反射的方式创建代理类的对象，再使用反射方式调用被代理的方法。可以先看一个在java中最简单的动态代理写法： 123456789101112131415161718192021public class TestProxy &#123; public static void main(String args[]) &#123; Subject subject = new RealSubject(); InvocationHandler handler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; //在调用具体函数方法前，执行功能处理 result = method.invoke(subject, args); //在调用具体函数方法后，执行功能处理 return result; &#125; &#125;; Subject object = (Subject) Proxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(), handler); object.doSomething(); &#125;&#125; 我们使用Proxy.newProxyInstance和InvocationHandler动态构造代理对象，通过获取invoke method注解对请求的描述信息，生成ServiceMethod对象，并根据该对象执行相应的网络请求。 123456789101112131415161718192021222324public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;validateServiceInterface(service);return (T) Proxy.newProxyInstance( service.getClassLoader(), new Class&lt;?&gt;[] &#123;service&#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; args = args != null ? args : emptyArgs; return platform.isDefaultMethod(method) ? platform.invokeDefaultMethod(method, service, proxy, args) : loadServiceMethod(method).invoke(args); &#125; &#125;);&#125; 0x03 总结这里借用知乎大佬的一张图，同时对比下静态代理和动态代理的差异，主要在于代理类如何生成。 如果是编译或者编码过程中生成的代理类就是静态代理，所以静态代理的一个缺点就是会生成很多代理类。如果在运行时或者编译时动态生成的代理类，一般就是动态代理。可以通过接口的Class对象，创建一个代理Class，通过代理Class创建代理对象。也就是所谓的用Class造Class。 参考http://weishu.me/2016/01/12/binder-index-for-newer/https://zhuanlan.zhihu.com/p/35519585http://gityuan.com/2016/09/04/binder-start-service/https://www.zhihu.com/question/20794107","categories":[{"name":"方案与设计","slug":"方案与设计","permalink":"https://ivonhoe.github.io/categories/%E6%96%B9%E6%A1%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://ivonhoe.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"责任链模式","slug":"design-patterns-chain-of-responsibility","date":"2021-03-27T16:19:30.000Z","updated":"2022-05-25T16:55:22.600Z","comments":true,"path":"2021/03/28/design-patterns-chain-of-responsibility/","link":"","permalink":"https://ivonhoe.github.io/2021/03/28/design-patterns-chain-of-responsibility/","excerpt":"说到责任链模式一定会想到各种拦截器，在很多框架中都有拦截器的使用，如常见的okhttp中的请求处理拦截器，路由框架中的路由拦截器，作为框架的使用方你可能已经对拦截器司空见惯，但是不可否认的是一个好的设计经常会有让人有眼前一亮的感觉。本文尝试总结一下在安卓框架和源码中，责任链模式的使用场景和设计方法。","text":"说到责任链模式一定会想到各种拦截器，在很多框架中都有拦截器的使用，如常见的okhttp中的请求处理拦截器，路由框架中的路由拦截器，作为框架的使用方你可能已经对拦截器司空见惯，但是不可否认的是一个好的设计经常会有让人有眼前一亮的感觉。本文尝试总结一下在安卓框架和源码中，责任链模式的使用场景和设计方法。 0x01 什么是责任链模式从设计模式的角度，拦截器的设计常常称之为责任链模式（Chain of Responsibility）。责任链模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。 责任链模式的优点： 降低耦合，不需要知道整条处理链路的结构，发送者和接受者也无需知道对方的确切信息。 灵活，扩展性强，可根据需要灵活增加处理流程，可动态调整处理顺序 功能内聚，单一职责，每个类只需要关注自己处理的工作，不该处理的传递给下一个对象处理 责任链模式的缺点： 复杂度较高，性能可能受影响 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。0x02 okhttp中的阑尾式拦截器在RealCall.java中内置了5个拦截器。创建一个包含所有拦截器的拦截器链表。在RealInterceptorChain的proceed方法中根据index获取当前拦截器，在拦截器的intercept方法内部递归调用RealInterceptorChain的proceed方法并将index+1，更新到下一个拦截器。这里需要注意的是，最后一个拦截器的实现，在最后一个拦截器CallServerInterceptor中，并不会再调用Chain的proceed方法，而是直接根据网络结果返回response。这里可以看做整个拦截器的尽头，在胡同走到尽头后再根据原路逐级返回response。所以像是走进胡同的拦截器调用算不算半截阑尾？ 1234567891011121314151617181920/// 拦截器起点和终点 Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest); &#125; 12345678910111213/// 拦截器迭代 public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); return response; &#125; 1234567891011121314/// 单个拦截器递归回调到拦截器链public Response intercept(Chain chain) throws IOException &#123; Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; return response; &#125; 0x03 wmrouter中的洋葱式拦截器和okhttp的拦截器相比，wmrouter中的拦截器差异在于他并没有response返回值，拦截器之间通过callback的方式返回结果或中断拦截流程。个人理解主要有以下几点考虑。 并不需要像okhttp那样针对队尾的拦截器做特殊实现，所有拦截器的实现只要考虑是next还是complete即可。这样拦截器组合和嵌套更灵活。 支持异步拦截回调 wmrouter在查找路由的过程中，使用了多层UriHandler和Interceptor嵌套的拦截器，在UriHandler的handle方法中，通过shouldHandle是否被当前的Handler拦截，再通过是否包含拦截器来确定是handler拦截还是Interceptor拦截，如果是Interceptor拦截则进入下一层。所以相比较okhttp的拦截器，wmrouter的拦截器模式分层更明显，更像洋葱。 123456789101112131415161718192021public void handle(@NonNull final UriRequest request, @NonNull final UriCallback callback) &#123; if (shouldHandle(request)) &#123; if (mInterceptor != null &amp;&amp; !request.isSkipInterceptors()) &#123; mInterceptor.intercept(request, new UriCallback() &#123; @Override public void onNext() &#123; handleInternal(request, callback); &#125; @Override public void onComplete(int result) &#123; callback.onComplete(result); &#125; &#125;); &#125; else &#123; handleInternal(request, callback); &#125; &#125; else &#123; callback.onNext(); &#125;&#125; 在ChainedInterceptor中根据递归调用next方法更新拦截器迭代，通过Callback回溯到上一层，这里的上一层可能是Interceptor也可能是UriHandler。 12345678910111213141516171819private void next(@NonNull final Iterator&lt;UriInterceptor&gt; iterator, @NonNull final UriRequest request, @NonNull final UriCallback callback) &#123; if (iterator.hasNext()) &#123; UriInterceptor t = iterator.next(); t.intercept(request, new UriCallback() &#123; @Override public void onNext() &#123; next(iterator, request, callback); &#125; @Override public void onComplete(int resultCode) &#123; callback.onComplete(resultCode); &#125; &#125;); &#125; else &#123; callback.onNext(); &#125;&#125; 可以参照下图理解 可以参照wmrouter官方文档的流程图理解ChainedHandler和ChainedInterceptor的多层嵌套关系。 0x04 Touch事件分发的贪食蛇拦截你一定看过类似这样的事件分发流程图（出自https://www.gcssloop.com/customview/dispatch-touchevent-theory）： 在touch分发的流程中三个关键的方法，dispatchTouchEvent()，interceptTouchEvent(),touchEvent()分别代表事件分发，事件拦截，事件消费。你也一定听过所谓的U型事件传递路径，从Activity开始分发，到ViewGroup，再到View。根据方法返回值是true还是false来决定上述的三个方法是否分发、拦截或消费touch事件。参考如下伪代码理解 12345678910111213141516public boolean dispatchTouchEvent(MotionEvent ev) &#123; // 默认状态为没有消费过 boolean result = false; if (!onInterceptTouchEvent(ev)) &#123; // 如果没有拦截就直接分发给子View result = child.dispatchTouchEvent(ev); &#125; if (!result) &#123; // 如果事件没有子View消费或者是被自己拦截了,询问自身onTouchEvent result = onTouchEvent(ev); &#125; return result;&#125; 如果从责任链的角度来看，你是否想过在整个事件分发的流程中，整套机制的最终目标是什么？ 其实事件分发的目标，是为了找到负责消费整个touch流程的view。这里的touch流程包含了DOWN、MOVE和UP事件。而CANCEL事件可以理解成一个error信号，只有当子视图消费的前驱事件，但是又被拦截了当前的事件才会收到CANCEL类型的事件。 一次触摸流程中产生事件应被同一 View 消费，全部接收或者全部拒绝。 所以才有了所谓的只有消费了DOWN事件才会接受MOVE和UP事件这样的分发规则。可以想象成一条由DOWN、MOVE和UP事件组成的贪食蛇。蛇身和蛇尾的运动是根据蛇头来的。事件分发机制先找到DOWN事件的消费者，再根据DOWN事件的touchTarget，将MOVE和UP事件分发下去。 所谓的U型传递，从ViewGroup到View，再从View到ViewGroup的事件传递，只可能是DOWN类型的事件 当parent和child同时设置了click事件监听，为什么是child优先响应？因为click事件是在onTouchEvent中响应的，而onTouchEvent的消费顺序是先child后parent，当view设置了touchListener或者是clickListener，事件就会被view拦截 0x05 总结 责任链在设计实现上，往往通过链表或者递归调用的方式，将请求或事件依次从头结点向下传递，并回溯 在责任链的任意节点上，都可以根据情况决定是否终止在责任链上的事件传递，okhttp通过抛异常的方式终止，wmroutor通过callback依次退栈 参考http://c.biancheng.net/view/1383.htmlhttps://www.debug8.com/javascript/t_66952.htmlhttps://segmentfault.com/a/1190000012227736https://www.gcssloop.com/customview/dispatch-touchevent-theoryhttps://blog.csdn.net/lfdfhl/article/details/50707724","categories":[{"name":"方案与设计","slug":"方案与设计","permalink":"https://ivonhoe.github.io/categories/%E6%96%B9%E6%A1%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://ivonhoe.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"升级AndroidX遇到的问题","slug":"update-androidx-exception","date":"2020-05-16T18:44:51.000Z","updated":"2022-05-25T16:49:48.880Z","comments":true,"path":"2020/05/17/update-androidx-exception/","link":"","permalink":"https://ivonhoe.github.io/2020/05/17/update-androidx-exception/","excerpt":"记录在升级AndroidX时遇到的一个问题，仅供参考。","text":"记录在升级AndroidX时遇到的一个问题，仅供参考。 0x01 问题描述在项目中升级AndroidX时遇到一个运行时异常，查看日志可了解到是因为找不到方法addOnTabSelectedListener，异常堆栈如下： 12345678910111213141516171819202122232425262728293031E Caused by: java.lang.reflect.InvocationTargetExceptionE at java.lang.reflect.Constructor.newInstance0(Native Method)E at java.lang.reflect.Constructor.newInstance(Constructor.java:343)E at android.view.LayoutInflater.createView(LayoutInflater.java:658)E at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:801)E at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:741)E at android.view.LayoutInflater.rInflate(LayoutInflater.java:874)E at android.view.LayoutInflater.rInflateChildren(LayoutInflater.java:835)E at android.view.LayoutInflater.inflate(LayoutInflater.java:515)E at android.view.LayoutInflater.inflate(LayoutInflater.java:423)E at android.view.LayoutInflater.inflate(LayoutInflater.java:374)E at com.android.internal.policy.PhoneWindow.setContentView(PhoneWindow.java:498)E at com.android.internal.policy.HwPhoneWindow.setContentView(HwPhoneWindow.java:342)E at android.app.Activity.setContentView(Activity.java:2941)E at xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxE at android.app.Activity.performCreate(Activity.java:7458)E at android.app.Activity.performCreate(Activity.java:7448)E at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1286)E at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3409)E at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3614)E at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:86)E at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:108)E at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:68)E at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2199)E at android.os.Handler.dispatchMessage(Handler.java:112)E at android.os.Looper.loop(Looper.java:216)E at android.app.ActivityThread.main(ActivityThread.java:7625)E at java.lang.reflect.Method.invoke(Native Method)E at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:524)E at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:987)E Caused by: java.lang.NoSuchMethodError: No virtual method addOnTabSelectedListener(Lcom/google/android/material/tabs/TabLayout$OnTabSelectedListener;)V in class Lcom/google/android/material/tabs/TabLayout; or its super classes (declaration of &#x27;com.google.android.material.tabs.TabLayout&#x27; appears in /data/app/xxxxxx-WbxmUkjqMEjNknQppPqeWw==/base.apk!classes2.dex) 0x02 问题分析因为从support27到support28版本，TabLayout的API发生了变更，addOnTabSelectedListener方法入参发生了变化，可通过查看下图中的函数字节码可以看到，AndroidX中的该函数的入参为BaseOnTabSelectedListener，而support27中的该函数的入参为onTabSelectedListener。函数字节码如下： 发生改问题的原因是AndroidX是基于Support Library 28的重构。而在当前项目中依赖了27.0.2的TabLayout support包，并在依赖support27的基础上使用进行了AndroidX包名替换转换。所以在动手之前还是建议先把官方看清楚，在官方文档里说的很清楚了，要先把当前的 Support Library 依赖升级至版本28，然后再使用Android Studio的工具转换AndroidX。 0x03 函数签名3.1 先写个demodemo说明： 接口A声明接口方法methodA 接口B继承A methodTest声明的函数参数为接口A 12345678910111213141516171819202122class TestMethod &#123; void invokeTest() &#123; methodTest(new AbsClassB() &#123; @Override public void methodA() &#123; &#125; &#125;); &#125; void methodTest(AbsClassA a) &#123; System.out.print(&quot;-------&quot;); &#125;&#125;interface AbsClassB extends AbsClassA &#123;&#125;interface AbsClassA &#123; void methodA();&#125; 反编译以上Java代码： 1234567891011121314151617181920212223242526Compiled from &quot;TestMethod.java&quot;class TestMethod &#123; TestMethod(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return void invokeTest(); Code: 0: aload_0 1: new #2 // class TestMethod$1 4: dup 5: aload_0 6: invokespecial #3 // Method TestMethod$1.&quot;&lt;init&gt;&quot;:(LTestMethod;)V 9: invokevirtual #4 // Method methodTest:(LAbsClassA;)V 12: return void methodTest(AbsClassA); Code: 0: getstatic #5 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #6 // String ------- 5: invokevirtual #7 // Method java/io/PrintStream.print:(Ljava/lang/String;)V 8: return&#125; 由以上可知，所谓的方法签名至于函数定义时声明的参数类型有关，和调用时传递的参数类型无关。 3.2 什么是函数签名？方法签名为了唯一标识一个方法。如果你查询一些资料和文档可能会得到下面的说法：说法一：同一类中不能存在两个名字及描述符完全相同的方法。在Java中方法签名包括：方法名、形参参数列表、泛型方法类型参数列表。Java的方法签名并不包括返回值和访问修饰符。当类中存在签名相同的两个方法时编译会报错，当两个方法的其中一个签名是另一个方法的子签名时也会报错。自签名的定义是一个签名在类型擦除后与另一个签名相同，则称其为第二个签名的的子签名。 说法二：在同一class文件中，两个方法可以拥有同样的特征签名，前提是返回值不能相同。 这看起来是自相矛盾的啊，到底一个函数签名包不包含方法的返回值类型呢？ 如下面所示的代码，使用Java编译器编译一定是编译不通过的。 123456789101112131415public class TestMethodSameName &#123; public static void foo(int i) &#123; System.out.println(&quot;TestMethodSameName.foo:(I)V&quot;); &#125; public static int foo(int i) &#123; System.out.println(&quot;TestMethodSameName.foo:(I)I&quot;); return i; &#125; public static void main(String[] args) &#123; foo(123); // foo:(I)V foo(456); // foo:(I)I &#125; &#125; 但是如果你使用使用javac和javap命令查看方法签名时你会发现 12345678910111213javac TestMethodSameName.javajavap -s -p TestMethodSameName.class Compiled from &quot;TestMethodSameName.java&quot;public class TestMethodSameName &#123; public TestMethodSameName(); descriptor: ()V public static int foo(int); descriptor: (I)I public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V&#125; 可以看到所谓方法描述是包含函数参数类型和返回值类型的（descriptor: ([Ljava/lang/String;)V).所以是不是以上说法一和说法二都对呢？其实说法一针对的是Java编译器，说法二针对的是JVM的。在虚拟机的标准里是允许一个类中方法名和形参一样但是返回值不一样，因为这两个方法对应的方法描述不一样，针对字节码层面这种情况是存在的，JVM是也正常运行的。那么为什么JVM支持的东西，JAVA偏偏不支持呢？因为在方法调用的时候并不能保证指定了方法的返回信息，编译器并不知道你实际调用了哪个方法。还是以上面的代码为例，当忽略返回值的调用时就搞不清到底在调用哪个方法了。 1foo(1) 3.3 重载和重写重载：同一个类中方法相同方法参数不同的方法。不能通过返回类型是否相同来判断重载。重写：方法签名必定相同，返回值必定相同， 访问修饰符 子 &gt; 父， 异常类 子 &lt; 父 3.4 父类的private方法子类可以重写吗？JVM调用方法有五条指令，分别是 invokestatic,用来调用static方法（类方法) invokespecial,用来调用需要特殊处理的实例方法，私有方法，父类方法(super.)，初始化方法。在对象的创建过程中，new之后很多都会执行方法，就是依赖字节码中是否包含invokespecial指令。静态绑定 invokevirtual,用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）最常见的。动态绑定 多态例子 invokeinterface,调用接口方法，在运行时搜索一个实现了这个接口方法的对象，找出适当的方法进行调用。 invokedynamic。方法动态解析出调用点限定符所引用的方法 程序绑定： 指的是一个方法的调用与方法所在的类(方法主体)关联起来。对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。 静态绑定： 在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。例如：C。针对java简单的可以理解为程序编译期的绑定。invokespecial和invokestatic是采用静态绑定。 动态绑定： 在运行时根据具体对象的类型进行绑定。invokevirtual和invokeinterface是采用动态绑定。 可以看到，在调用private、super、方法时使用的invokespecial指令，而在实例对象的其他方法时使用的是invokevirtual指令。正是由于这两种绑定的不同，在子类覆盖超类的方法、并向上转型引用后，才产生了多态以及其他特殊的调用结果。运行时，invokespecial选择方法基于引用声明的类型，而不是对象实际的类型。但invokevirtual则选择当前引用的对象的类型。 回到问题，父类的private方法子类可以重写吗? 答案很明显，不能，从invoke指令的角度看，父类的private方法的程序绑定在编译期就已经确定了，跟Java的多态特性是无关的，所以不能被重写。 0x04 总结如果只是针对AndroidX的升级其实很简单，只要关注到一点，AndroidX的升级和转换要保证所有依赖的support包都升级到28.0.0以上。如果从JVM规范和指令角度看，一个很小的点还是有很多值得深挖的地方的。 参考文档https://mp.weixin.qq.com/s/fmnoKH-R9PCmg-3ATRMIbQhttp://wxweven.win/2017/09/15/JVM-invokespecial%E5%92%8Cinvokevirtual/https://hllvm-group.iteye.com/group/topic/27033https://www.iteye.com/blog/rednaxelafx-479301https://www.cnblogs.com/onlywujun/p/3523991.html","categories":[{"name":"学习总结","slug":"学习总结","permalink":"https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://ivonhoe.github.io/tags/JVM/"}]},{"title":"误用bitmap config导致的故障","slug":"bitmap-preconfig-bug","date":"2020-03-08T16:27:32.000Z","updated":"2022-05-25T16:57:39.889Z","comments":true,"path":"2020/03/09/bitmap-preconfig-bug/","link":"","permalink":"https://ivonhoe.github.io/2020/03/09/bitmap-preconfig-bug/","excerpt":"某周六线上运营报障，在部分用户的Android手机上个别地图图标未能正常显示，只有部分手机有问题(7.0及以下版本)有问题，诡异的是只有个别图标(1个)显示有问题，大部分图标显示并没有问题,开发介入验证后发现更诡异的是，只在release版本才有这个问题，开发debug版本上并没有问题。低版本显示有问题还好理解，这应该是一个版本兼容相关的问题。release和debug上个别图标有差别就有点匪夷所思了，写篇博客记录下。","text":"某周六线上运营报障，在部分用户的Android手机上个别地图图标未能正常显示，只有部分手机有问题(7.0及以下版本)有问题，诡异的是只有个别图标(1个)显示有问题，大部分图标显示并没有问题,开发介入验证后发现更诡异的是，只在release版本才有这个问题，开发debug版本上并没有问题。低版本显示有问题还好理解，这应该是一个版本兼容相关的问题。release和debug上个别图标有差别就有点匪夷所思了，写篇博客记录下。 0x01 问题说明问题日志： 1234java.lang.NullPointerException: Attempt to read from field &#x27;int android.graphics.Bitmap$Config.nativeInt&#x27; on a null object reference10-19 14:27:36.501 20394-20394/? W/System.err: at android.graphics.Bitmap.copy(Bitmap.java:557)10-19 14:27:36.501 20394-20394/? W/System.err: at com.amap.api.maps.model.BitmapDescriptor.&lt;init&gt;(BitmapDescriptor.java:28)10-19 14:27:36.501 20394-20394/? W/System.err: at com.amap.api.maps.model.BitmapDescriptorFactory.fromBitmap(BitmapDescriptorFactory.java:258) 问题代码： 123456val opts = BitmapFactory.Options()opts.inPreferredConfig = Bitmap.Config.RGB_565opts.inTargetDensity = displayMetrics.densityDpiopts.inScaled = trueopts.inDensity = DisplayMetrics.DENSITY_XXHIGH//typedValue.densityval var3 = BitmapFactory.decodeStream(var2, null, opts) 根据日志可以看出是Bitmap的config为null引起的空指针问题，在使用BitmapFactory.decodeStream时，正常解析到了Bitmap对象，但是该图片的Config获取为null，进而引发一个空指针异常，导致了后续图片加载的失败。该段代码也很简单，重新写了个demo应用单独运行这段代码，并特别使用了出现线上故障的资源图片，测试的结果依然是debug版本的demo Bitmap.getConfig获取正常，为ARGB.8888。release版本 Bitmap.getConfig获取为null。尝试修改inPreferredConfig为ARGB_8888或删除这个参数。demo运行正常，Bitmap和Bitmap.Config都能正常获取。这是一个和inPreferredConfig参数有关的问题？考虑到该段代码加载的图片资源可能是透明的png，首先需要承认的是使用565模式解析有alpha通道的图片资源是并不科学的，虽然565配置对非透明图片的加载可以省一般的内存空间。但文档不是这么说的呀？inPreferredConfig参数指定的配置并不是一个非强制的选项，而是建议选项，Android在实际解码时会参考此参数的配置，但如果此配置不满足，Android会重新选取一个合适的配置来对图片进行解码。 所以基于文档的说明，使用RGB_565的配置decode有alpha通道的图片并不会有什么问题，在正常情况下Android系统实际还是会选择ARGB_8888的配置进行加载。现在很明显这不是正常情况。不正常的点在哪里？看起来肯定和这张图片有关，换个图片就能解决这个问题了，不然换个图片？不用inPreferredConfig参数也行，但是为什么？问题到底出在哪里？一头扎进BitmapFactory.cpp中，然而并没有什么明显的线索，头大了~~ 0x03 线索分析看了大半天BitmapFactory的源码，对加载流程大致有了了解，但是对解决问题并没有什么思路，和大师交流这个问题时，他的一句话点醒了我。 最最诡异的其实是debug和release差异的问题啊。难道release打包时，资源打包对这个图片动了手脚？所有，手动将release版本的app解压出来，找到有问题的png。果然发现了不一样的地方，使用AS的图片查看器查看png图片，在右上角可以看到，原本在源码中32-bit color的图片在release包中变成了8-bit color。 原本2k的图片在从release包里解压出来后只有700B，aapt对资源做了压缩，难道是压缩引起的问题？在编译文件中配置cruncherEnabled false关闭对png的压缩操作。 123aaptOptins&#123; cruncherEnabled false&#125; 问题消失了，实锤！和资源打包时对png的压缩有关~ 什么是alpha通道？ 0x04 调色板模式将图像转换为调色板颜色模式时，会给每一个像素分配一个固定的颜色值，这些颜色值储存在简洁的颜色表中，或包含多达256种色的调色板中。因此，调色板颜色模式的图像包含的数据比24位颜色模式的图像小，对于颜色范围有限的图像，通过这个色彩转换模式效果更佳，用户可以设定转换颜色的调色板，从而得到指定颜色的阶数的位图。 调色板颜色模式也被称为是索引模式，调色板颜色模式只有在图像颜色小于等于256色的时候才有，16位高彩和24位32位真彩是没有调色板色的。它只支持单通道图像(8位&#x2F;像素)，因此，我们通过限制调色板、索引颜色减小文件大小，同时保持视觉上的品质不变——如用于多媒体动画的应用或网页。只有16位以下的才用调色板，真彩色不用调色板。 0x05 重新理一下问题5.1 问题原因 android aapt针对色值数量小于256个的资源图片，在 aaptOptins cruncherEnabled为true时进行了png压缩操作。将png图片的32位全彩色模式图片转换成了8bit位索引模式 android较低版本系统在使用PreConfig&#x3D;565模式下解析8bit索引模式图片时能够正常返回解析后的Bitmap，但Bitmap Config为空。导致后续的加载错误。 基于以上两点原因，才出现了在debug模式下打包正常，在release下正常，有的图标正常，个别图标显示不出来的诡异操作。出问题的图片都是被转换成索引模式的图片，理论上可能并不止一个，只是暂时只发现了一个。 5.2 解决方案选择使用ARGB8888或者不设置inPreferredConfig参数进行bitmap decode。其实默认inPreferredConfig值就是ARGB_8888。 1public Bitmap.Config inPreferredConfig = Bitmap.Config.ARGB_8888; 5.3 在使用inPreferredConfig的时候要注意什么？参数inpreferredconfig表示图片解码时使用的颜色模式，也就是图片中每个像素颜色的表示方式。参数inpreferredconfig的可选值有四个，分别为ALPHA_8，RGB_565，ARGB_4444，ARGB_8888。它们的含义列举如下。 ALPHA_8：图片中每个像素用一个字节（8位）存储，该字节存储的是图片8位的透明度值 RGB_565：图片中每个像素用两个字节（16位）存储，两个字节中高5位表示红色通道，中间6位表示绿色通道，低5位表示蓝色通道 ARGB_4444：图片中每个像素用两个字节（16位）存储，Alpha，R，G，B四个通道每个通道用4位表示 ARGB_8888：图片中每个像素用四个字节（32位）存储，Alpha，R，G，B四个通道每个通道用8位表示 根据Android官方文档的说明，如果inPreferredConfig不为null，解码器会尝试使用此参数指定的颜色模式来对图片进行解码，如果inPreferredConfig为null或者在解码时无法满足此参数指定的颜色模式，解码器会自动根据原始图片的特征以及当前设备的屏幕位深，选取合适的颜色模式来解码，例如，如果图片中包含透明度，那么对该图片解码时使用的配置就需要支持透明度，默认会使用ARGB_8888来解码。inPreferredConfig指定的配置并非是一个强制选项，而是建议的选项，Android在解码时会参考该配置，如果该配置不满足，Android会重新选取一个合适的配置来对图片进行解码。 详细的验证过程可参考https://blog.csdn.net/ccpat/article/details/46834089 0x06 为什么Bitmap.getConfig()返回null？从 getConfig 方法的文档可以看到这个描述： If the bitmap’s internal config is in one of the public formats, return that config, otherwise return null.如果位图的内部 config 是公开格式的其中之一就返回这个 config，否则返回 null。这里的内部格式，就是指 SkBitmap::Config 枚举值了，这里的公开格式指的是Java层Bitmap.Config的枚举值。如果这个值并未在 Java 层 Bitmap.Config 中公开，就返回 null，像索引颜色对应的 kIndex8_Config 就会导致 getConfig() 会返回 null。 可查看源码external/skia/include/core/SkBitmap.h，Skia的颜色配置，其中kIndex8_Config表示每像素8bits，使用 SkColorTable 来描述颜色，这个 SkColorTable 顾名思义就是颜色表了。 1234567891011enum Config &#123; kNo_Config, kA1_Config, kA8_Config, // !&lt; 8 -bits per pixel, using SkColorTable to specify the colors kIndex8_Config, kRGB_565_Config, kARGB_4444_Config, kARGB_8888_Config, kRLE_Index8_Config,&#125;; external/skia/src/images/SkImageDecoder_libpng.cpp的getBitmapConfig方法，如果当前图片是调色板模式，会执行canUpscalePaletteToConfig方法，该方法返回 false 则 configp 被设置为 kIndex8_Config。 1234567891011121314bool SkPNGImageDecoder::getBitmapConfig(png_structp png_ptr, png_infop info_ptr, SkBitmap::Config* configp, bool* hasAlphap, SkPMColor* theTranspColorp) &#123; png_uint_32 origWidth, origHeight; int bitDepth, colorType; png_get_IHDR(png_ptr, info_ptr, &amp;origWidth, &amp;origHeight, &amp;bitDepth, &amp;colorType, int_p_NULL, int_p_NULL, int_p_NULL); // ... if (colorType == PNG_COLOR_TYPE_PALETTE) &#123; bool paletteHasAlpha = hasTransparencyInPalette(png_ptr, info_ptr); *configp = this-&gt;getPrefConfig(kIndex_SrcDepth, paletteHasAlpha); // now see if we can upscale to their requested config if (!canUpscalePaletteToConfig(*configp, paletteHasAlpha)) &#123; *configp = SkBitmap::kIndex8_Config; // 注意这里 &#125; &#125; else &#123; // ... 当dstConfig为565_config并且图片包含alpha通道时，或者dstConfig不属于kARGB_8888_Config、kARGB_4444_Config 、kRGB_565_Config之一，则canUpscalePaletteToConfig如何才能令其返回false。 123456789101112static bool canUpscalePaletteToConfig(SkBitmap::Config dstConfig, bool srcHasAlpha) &#123; switch (dstConfig) &#123; case SkBitmap::kARGB_8888_Config: case SkBitmap::kARGB_4444_Config: return true; case SkBitmap::kRGB_565_Config: // only return true if the src is opaque (since 565 is opaque) return !srcHasAlpha; default: return false; &#125;&#125; 再看getPrefConfig的实现，getPrefConfig返回由java层设置的fDefaultPref，当config为kNo_Config时，返回GetDeviceConfig(),其实也是kNo_Config。那么config什么时候为SkBitmap::kNo_Config呢？当Java层设置的inPreferredConfig为null时，fDefaultPref会被赋值为kNo_Config。详情可查看getNativeBitmapConfig 方法。 12345678910111213141516SkBitmap::Config SkImageDecoder::getPrefConfig(SrcDepth srcDepth, bool srcHasAlpha) const &#123; SkBitmap::Config config = SkBitmap::kNo_Config; if (fUsePrefTable) &#123; // 普通图片解码不会进入这个分支 switch (srcDepth) &#123; // ... &#125; &#125; else &#123; config = fDefaultPref; // 注意这里 &#125; if (SkBitmap::kNo_Config == config) &#123; config = SkImageDecoder::GetDeviceConfig(); &#125; return config;&#125; 综上所述，只要PNG文件本身是索引颜色格式，且在调用BitmapFactory.decodeXXX方法族时，将传入的BitmapFactory.Options.inPreferredConfig置为null即可解码得到索引颜色格式的Bitmap对象，如果这张PNG是带有alpha通道的，inPreferredConfig设置为RGB_565也可以。此时该Bitmap的Config为null。 参考文档https://www.jianshu.com/p/ecacf2f60cb2https://www.jianshu.com/p/cc17d18c3447http://www.coreldrawchina.com/X7jiaocheng/cdr-tiaosebanyanse-moshi.htmlhttps://www.jianshu.com/p/f56292504ad3https://blog.csdn.net/ccpat/article/details/46834089https://android.googlesource.com/platform/frameworks/base/+/marshmallow-dev/tools/aapt2/Png.cpp","categories":[{"name":"学习总结","slug":"学习总结","permalink":"https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Bitmap","slug":"Bitmap","permalink":"https://ivonhoe.github.io/tags/Bitmap/"},{"name":"BitmapFactory","slug":"BitmapFactory","permalink":"https://ivonhoe.github.io/tags/BitmapFactory/"}]},{"title":"Flutter aspectd入门指引","slug":"hello-flutter-aspectd","date":"2019-11-08T15:16:38.000Z","updated":"2022-05-25T16:57:04.150Z","comments":true,"path":"2019/11/08/hello-flutter-aspectd/","link":"","permalink":"https://ivonhoe.github.io/2019/11/08/hello-flutter-aspectd/","excerpt":"什么是aspectd？aspectd是闲鱼针对dart的AOP开源框架。https://github.com/alibaba-flutter/aspectd.git阅读本文你将得到什么？ 掌握aspectd的环境搭建，并如何在本地成功运行aspectd的demo 掌握有关aop的基础概念 了解aspectd的基础用法和原理","text":"什么是aspectd？aspectd是闲鱼针对dart的AOP开源框架。https://github.com/alibaba-flutter/aspectd.git阅读本文你将得到什么？ 掌握aspectd的环境搭建，并如何在本地成功运行aspectd的demo 掌握有关aop的基础概念 了解aspectd的基础用法和原理 0x01 准备1.1 开发环境aspectd的环境搭建需要flutter源码、aspectd源码和dart源码，并需要在系统中设置相应的全局环境变量。 1.1.1 flutter环境下载flutter源码： 1git clone https://github.com/flutter/flutter.git 1.1.2 aspectd下载下载aspectd源码： 1git clone https://github.com/alibaba-flutter/aspectd.git 1.1.3 环境变量配置flutter镜像、本地flutter源码地址、flutter bin目录、dart bin目录： 12345export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cnexport PATH_TO_FLUTTER_GIT_DIRECTORY=/Users/Ivonhoe/Flutter/flutterexport PATH=$PATH_TO_FLUTTER_GIT_DIRECTORY/bin:$PATHexport PATH=$PATH_TO_FLUTTER_GIT_DIRECTORY/bin/cache/dart-sdk/bin:$PATH 1.2 安装aspectdaspectd需要1.切换到flutter的git目录:cd $&#123;path-for-git-flutter&#125;2.将aspectd源码中的git patch文件合并到flutter源码工程中，合并git patch:git apply --3way ~/Github/aspectd/0001-aspectd.patch3.删除原有的的flutter编译工具：rm bin/cache/flutter_tools.stamp4.重新构建新的flutter编译工具：flutter doctor -v 1.3 运行到aspectd源码目录的example目录下执行：flutter run --debug --verbose如果你能一次运行成功并aspectd生效，请直接跳转到第二章！ 1.4 aspectd编译不过或demo没有效果编译不过或运行demo没有打印出想要的日志是aspectd使用时最常见的问题。aspectd的基本原理实际上是使用了dart对虚拟语法树操作的api，通过对flutter dill文件进行虚拟语法树遍历，完成对dill文件的转换，进而实现对dart的切面操作。所以在aspectd的编译上需要依赖dart源码中的kernal和front_end，可通过查看aspectd源码根目录中的pubspec.yaml查看依赖库和对应的ref。 1234567891011dependency_overrides: kernel: git: url: https://github.com/dart-lang/sdk.git ref: 5e39817ec7ab7f56f381c244d105c7e40913a3e0 path: pkg/kernel front_end: git: url: https://github.com/dart-lang/sdk.git ref: 5e39817ec7ab7f56f381c244d105c7e40913a3e0 path: pkg/front_end 在1.2步骤中，使用git patch命令修改flutter源码引入了aspectd.dart文件，该文件做的核心操作就包括下载aspectd的依赖库、编译aspectd.dart.snapshot和根据注解内容使用aspect.dart.snapshot执行具体的dill transform操作。所以，aspectd是否生效的两个关键点是aspectd依赖库是否下载成功和aspectd.snapshot文件是否编译成功。因为aspect使用依赖github源码指定ref的方式依赖kenerl和front_end库，这个过程需要下载github上dart-lang的所有源码(约900M左右)，在国内的网络环境下很难做到一次成功，这里分享一个绕过因网络不稳定问题导致aspectd不生效的方法。 手动下载dart源码，git clone https://github.com/dart-lang/sdk.git 将dart源码切换到aspectd项目中pubspec.yaml指定的ref上，如上例中，可执行 git checkout 5e39817ec7ab7f56f381c244d105c7e40913a3e0 将aspect对github源码的依赖改成对本地源码的依赖 手动编译aspect.dart.snapshot(在aspectd根目录中)dart --snapshot=snapshot/aspectd.dart.snapshot tool/starter.dart 修改flutter源码中的aspectd.dart，强制指定aspect.dart.snapshot的目录。 删除flutter_tools.stamp重新编译运行flutter run --debug -v即可生效 1.5 常见问题解决 等待另一个flutter命令释放锁Waiting for another flutter command to release the startup lock...解决方法，将bin&#x2F;cache下的lockfile删除后重新执行命令rm $&#123;path-for-git-flutter&#125;/bin/cache/lockfile 如何使用命令行编译工程debug版本：flutter run --debug --verboserelease版本：flutter run --release --verbose pub命令是什么？flutter pub getpub是dart提供的包管理工具，在flutter源码中的flutter/bin/cache/dart-sdk/bin/pub目录下有pub可执行文件，想要单独执行pub命令可讲该目录加入到系统的环境变量中相当于android gradle的gradle sync相当于ios pod中的pod install相当于js npm中的npm install 0x02 aspectd的注解2.1 @pragma(‘vm:entry-point’)在AOT变一下，如果不能被应用主入口(main)最终可能调用到，那么将被视为无用代码而被丢弃掉。AOP代码因为其注入逻辑的无侵入性，所以不会被main调用，因为使用此注解告诉编译器不要丢弃这段逻辑。 2.2 @AspectAspect注解可以使得像asepctd源码example中aop_impl.dart这样的AOP实现类被方便的识别和提取，也可以起到方便开关的作用，如果想禁用掉这段AOP逻辑，移除@Aspect注解即可 2.3 @Call、@Execute、@Inject在介绍这几个注解之前需要理解关于AOP的几个概念，aspectd官方介绍文档对aspectd的说明引入了很对对aop设计的说明，比如什么是Advice？什么是Before\\Around\\After?如果对这些概念没有预先的概念，读aspectd的文档是一头雾水的，至少我是这样！ 2.3.1 什么是Joint Point（连接点）能够插入切面的一个点。这个点可以是类的某个方法调用前、调用后、方法抛出异常后等。切面代码可以利用这些点插入到应用的正常流程之中，并添加行为 2.3.2 什么是Pointcut（切点）指定一个通知将被引发的一系列连接点的集合。切点是连接点规则的描述。切点和连接点不是一对一的关系，一个切点匹配多个连接点 2.3.3 什么是Target Object（目标对象）包含连接点的对象 2.3.3 什么是Advice（通知）在特定的连接点，AOP框架执行的动作。通知有常见的几种类型： 前置通知Before：在目标方法被调用之前调用通知功能 后置通知After：目标方法完成之后调用通知，无论该方法是否发生异常 后置返回通知After-returning：在目标方法成功执行之后调用通知 后置异常通知After-throwing：在目标方法抛出异常后调用通知 环绕通知Around：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为 2.3.4 @Call、@Execute、@Injectaspectd只有一种统一的通知类型，就是Around。具体分为两种注解，分别是@Call和@Execute，这两种注解表达的PointCut都是通过包装原有方法实现的。差别是，@Call的PointCut是调用的地方，并不会修改原始方法的内部。@Execute会修改原有方法的内部。举个例子，分别使用@Call和@Execute对test方法执行切面操作 1234567void test()&#123; print(&quot;print hello world!&quot;)&#125;void main()&#123; test();&#125; @Call表达注解的实际代码会变成这样： 12345678910111213void test()&#123; print(&quot;print hello world!&quot;)&#125;void invokeCall()&#123; // to do somethings test(); // to do somethings&#125;void main()&#123; aop:invokeCall()&#125; @Execute表达注解的实际代码会变成这样： 123456789101112void invokeExecutor()&#123; // to do somethings print(&quot;print hello world!&quot;)&#125;void test()&#123; invokeExecutor();&#125;void main()&#123; test();&#125; 而@Inject相对于Call&#x2F;Executor而言，多了一个lineNum的参数，用于指定插入逻辑的具体行号。用于在具体方法中间插入处理逻辑。 0x03 参考文档https://github.com/alibaba-flutter/aspectd/issues/26","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ivonhoe.github.io/categories/Flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://ivonhoe.github.io/tags/flutter/"}]},{"title":"Android内存分析的一般方法","slug":"how-to-analyze-android-heap-1","date":"2019-07-08T15:04:56.000Z","updated":"2022-05-25T16:57:56.746Z","comments":true,"path":"2019/07/08/how-to-analyze-android-heap-1/","link":"","permalink":"https://ivonhoe.github.io/2019/07/08/how-to-analyze-android-heap-1/","excerpt":"对内存问题的分析中一个必不可少的环节应该就是对hprof的分析了，常见的MAT和Leakcanry都是针对hprof文件的分析工具。这篇文章就记录下做内存分析的一般工具和分析步骤。","text":"对内存问题的分析中一个必不可少的环节应该就是对hprof的分析了，常见的MAT和Leakcanry都是针对hprof文件的分析工具。这篇文章就记录下做内存分析的一般工具和分析步骤。 使用dumpsys分析内存adb shell dumpsys meminfo $applicationId [-d] 私有内存 Private (Clean and Dirty)这是仅属于你的进程的内存，这是你的进程被销毁时系统可以回收的RAM。通常情况下最重要的部分是Private Dirty RAM。 按比例分配占用内存 PSS这表示您的应用的 RAM 使用情况，考虑了在各进程之间共享 RAM 页的情况。您的进程独有的任何 RAM 页会直接影响其 PSS 值，而与其他进程共享的 RAM 页仅影响与共享量成比例的 PSS 值。例如，两个进程之间共享的 RAM 页会将其一半的大小贡献给每个进程的 PSS。 通常情况下，仅需关注 Pss Total 和 Private Dirty 列。一些情况下，Private Clean 和 Heap Alloc 列提供的数据也需要关注。 Dalvik Heap PSS Total: 包括所有 Zygote 按比例分配的内存。Private Dirty: 数值是仅分配到您应用的堆的实际 RAM，是由自己的分配和任何 Zygote 分配页组成，这些分配页自从 Zygote 派生应用进程以来已被修改(COW)。 .so mmap 和 .dex mmap Pss Total: 包括应用之间共享的平台代码Private Clean: 是应用自己的代码 .oat mmap 这是代码映像占用的 RAM 量，根据多个应用通常使用的预加载类计算。此映像在所有应用之间共享，不受特定应用影响 EGL mtrack 和 GL mtrack EGL mtrack: gralloc分配的内存，主要是窗口系统，SurfaceView&#x2F;TextureView和其他的由gralloc分配的GraphicBuffer总和GL mtrack: 驱动上报的GL内存使用情况。 主要是GL texture大小，GL command buffer，固定的全局驱动程序RAM开销等的总和 这里有一个小技巧，应用开发者调用startTrimMemory会帮助app或者系统更多的释放内存，减少内存压力，但是调用的位置和时机要慎重，因为清除了缓存，在下一次绘制（vsync的下一个信号到来）的时候绘制效率不会很高。详细原理可参考：https://cloud.tencent.com/developer/article/1070616 123456789101112131415161718192021/** * 清除GPU绘图缓存 */private void cleanGraphicsCache() &#123; Object instance = ReflectUtils.getStaticMethod(&quot;android.view.WindowManagerGlobal&quot;, &quot;getInstance&quot;, null, null); try &#123; Class threadClazz = Class.forName(&quot;android.view.WindowManagerGlobal&quot;); Method m1 = threadClazz.getDeclaredMethod(&quot;trimMemory&quot;, int.class); m1.invoke(instance, TRIM_MEMORY_COMPLETE); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125;&#125; TOATAL 进程占用的按比例分配占用内存 (PSS) 总量。等于上方所有 PSS 字段的总和。表示您的进程占用的内存量占整体内存的比重，可以直接与其他进程和可用总 RAM 比较。Private Dirty 和 Private Clean 是进程中的总分配，未与其他进程共享。它们（尤其是 Private Dirty）等于你的进程被破坏后将释放回系统中的 RAM 量。Dirty RAM 是因为已被修改而必须保持在 RAM 中的 RAM 页（因为没有交换）；Clean RAM 是已从某个持久性文件（例如正在执行的代码）映射的 RAM 页，如果一段时间不用，可以移出分页。 ViewRootImpl根视图数量，每一个根视图关联一个window，由此可确定涉及对话框或其他window的内存泄露。 AppContexts 和 ActivitiesContext和Activity对象数量，用于快速确定Activity的泄露情况。 0x03 使用堆转储工具将android app的内存信息转换成hprof格式的磁盘文件，这个过程就叫堆转储。堆转储的目标当然是为了获取当前Java虚拟机的内存信息以供排查内存问题。在android平台上常见的三种堆转储方法。 使用sdk自带的DDMS工具完成堆转储 使用Android Studio提供的Android Profiler工具完成堆转储 使用Android sdk提供的api堆转储，以下代码为api实例 123456789101112try &#123; String state = android.os.Environment.getExternalStorageState(); // 判断SdCard是否存在并且是可用的 if (android.os.Environment.MEDIA_MOUNTED.equals(state)) &#123; String dumpDir = Hprof.getDumpDir(context); android.os.Debug.dumpHprofData(dumpDir); Logger.d(String.format(&quot;create dumpfile %s done!&quot;, dumpDir)); return dumpDir; &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 0x04 使用hprof文件分析工具Memory Analyzer Tool（简称MAT） 使用方法可参考： Android内存优化之二：MAT使用进阶。这里补充的是，MAT支持使用OQL（对象查询语言）查询堆文件信息，你可以像类似使用SQL查询数据库一样查询堆文件上的内存对象的信息，举个例子，我想知道当前内存中有多少个Activity？ 1select * from instanceof android.app.Activity 查询大小大于100kb大小的Bitmap对象，图略 1select * from instanceof android.graphics.Bitmap s where s.@retainedHeapSize &gt;100000 关于OQL详情参考：http://help.eclipse.org/kepler/index.jsp，搜索OQL 0x05 使用Leakcanary监控泄露LeakCanary是内存泄露检测工具，LeakCanary 中文使用说明和LeakCanary的开源地址：https://github.com/square/leakcanary 如何监控内存泄露的发生？利用弱引用。当JVM进行垃圾回收时，无论内存是否充足，如果该对象只有弱引用存在，那么该对象会被垃圾回收器回收。所以Leakcanary在进行内存泄露的监控时，利用弱引用的上述特性，在对象生命周期结束后主动gc并检查该对象的弱引用是否被回收，如果弱引用没有被正常回收，说明在对象生命周期结束以后，该对象还被其他对象持有他的非弱引用。该对象还有到达GC ROOTS的可达路径。如果在对象生命周期结束后弱引用不存在了，说明该对象已经被JVM的垃圾回收器正常回收了，该对象的内存空间也被正常回收。所以Leakcanary设计成是对有明确生命周期的对象的自动监控，比如Activity对象，也可以是你想要跟踪的有明确生命周期的对象。 如何判断弱引用被回收？利用ReferenceQueue。当垃圾回收器准备回收一个被引用包装的对象时，该引用会被加入到关联的ReferenceQueue。程序可以通过判断引用队列中是否已经加入引用,来了解被引用的对象是否被GC回收。 12345678910111213141516171819202122232425262728293031323334353637383940Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) &#123; long gcStartNanoTime = System.nanoTime(); //计算watch方法到gc垃圾回收的时长 long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime); //尝试移除已经到达引用队列的弱引用 removeWeaklyReachableReferences(); //判断是否在debug if (debuggerControl.isDebuggerAttached()) &#123; // The debugger can create false leaks. (debug可以创造错误的内存泄露) return RETRY; &#125; if (gone(reference)) &#123;//若当前对象已经可达了，即不会造成你内存泄露 return DONE; &#125; //手动gc，确保引用对象是否真的被回收了。因为在dump内存信息之前提示内存泄露的时候，希望系统经过充分gc垃圾回收，而不存在任何的误判，对leakcanary容错性的考虑 gcTrigger.runGc(); //清除已经到达引用队列的弱引用 removeWeaklyReachableReferences(); if (!gone(reference)) &#123;//此时对象还没到达对列，代表已经内存泄露了 long startDumpHeap = System.nanoTime(); long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime); //dump出内存泄露的heap文件,这里可能触发GC File heapDumpFile = heapDumper.dumpHeap(); if (heapDumpFile == RETRY_LATER) &#123; // Could not dump the heap.(不能dump heap堆文件) return RETRY; &#125; //dump heap文件的时间计算 long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap); //真正分析内存泄露以及路径 HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key) .referenceName(reference.name) .watchDurationMs(watchDurationMs) .gcDurationMs(gcDurationMs) .heapDumpDurationMs(heapDumpDurationMs) .build(); heapdumpListener.analyze(heapDump); &#125; return DONE; &#125; 如何分析对象的被引用情况？遍历对象树。 0x06 使用三方库手动分析hprof文件可使用square提供的堆文件分析库(com.squareup.haha:haha:2.0.4)对hprof文件进行解析得到对象树。 12345678910111213private Snapshot getSnapShot(String hprofPath) &#123; File heapDumpFile = new File(hprofPath); HprofBuffer hprofBuffer = null; try &#123; hprofBuffer = new MemoryMappedFileBuffer(heapDumpFile); HprofParser parser = new HprofParser(hprofBuffer); return parser.parse(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null;&#125; 6.1 对象搜索可根据解析获得的Snapshot对象完成对特定类名对象的查找操作。进而批量分析出当前内存中执行类型对象的数量和对象引用情况。 12345678List&lt;ClassObj&gt; classObjList = snapshot.findAllDescendantClasses(filterKey());List&lt;Instance&gt; allInstance = new ArrayList&lt;&gt;();for (ClassObj classObj : classObjList) &#123; ClassObj instanceClass = snapshot.findClass(classObj.getClassName()); for (Instance instance : instanceClass.getInstancesList()) &#123; allInstance.add(instance); &#125;&#125; 6.2 对象树遍历可通过解析到的snapshot对象获取Root节点，自定义对象数爬虫，从Root节点遍历整个对象树，查找出异常对象的分布。如希望查找出当前对象树中，找到最大的组件类型有哪些： 1234mDistanceVisitor = new RetainedSizeVisitor();snapshot.computeDominators();// 找到最大的组件类型mDistanceVisitor.doVisit(snapshot.getGCRoots()); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @author Ivonhoe on 2018/9/26. */public class RetainedSizeVisitor extends NonRecursiveVisitor &#123; /** * App space中retained size最大的对象 */ private FixedSizePriorityQueue mMaxRetainedQueue; private List&lt;HeapInstanceEntry&gt; maxInstance; public RetainedSizeVisitor() &#123; mMaxRetainedQueue = new FixedSizePriorityQueue(30); maxInstance = new ArrayList&lt;&gt;(); &#125; @Override public void visitRootObj(RootObj root) &#123; super.visitRootObj(root); &#125; @Override protected void defaultAction(Instance instance) &#123; super.defaultAction(instance); findTopNRetainedSizeInstanceInAppSpace(instance); &#125; /** * 找到retained大小最大的n个对象 */ private void findTopNRetainedSizeInstanceInAppSpace(Instance child) &#123; if (child != null &amp;&amp; !(child instanceof ClassObj) &amp;&amp; child.getHeap().getId() == &#x27;A&#x27;) &#123; mMaxRetainedQueue.add(child); &#125; &#125; @Override public void doVisit(Iterable&lt;? extends Instance&gt; startNodes) &#123; super.doVisit(startNodes); &#125; private static class FixedSizePriorityQueue &#123; private PriorityQueue&lt;Instance&gt; queue; private int maxSize; //堆的最大容量 public FixedSizePriorityQueue(int maxSize) &#123; if (maxSize &lt;= 0) throw new IllegalArgumentException(); this.maxSize = maxSize; this.queue = new PriorityQueue(maxSize, new Comparator&lt;Instance&gt;() &#123; @Override public int compare(Instance o1, Instance o2) &#123; return ((Long) o1.getTotalRetainedSize()).compareTo(o2.getTotalRetainedSize()); &#125; &#125;); &#125; public void add(Instance e) &#123; if (queue.size() &lt; maxSize) &#123; //未达到最大容量，直接添加 queue.add(e); &#125; else &#123; //队列已满 Instance peek = queue.peek(); if (peek != null &amp;&amp; (e.getTotalRetainedSize() &gt; peek.getTotalRetainedSize())) &#123; queue.poll(); queue.add(e); &#125; &#125; &#125; &#125;&#125; 参考文档https://developer.android.com/studio/command-line/dumpsys#meminfohttps://cloud.tencent.com/developer/article/1070616https://cloud.tencent.com/developer/article/1070616http://gityuan.com/2016/01/02/memory-analysis-command/https://blog.csdn.net/msf568834002/article/details/78881341","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"Android虚拟机的几个问题探究","slug":"android-vm-1","date":"2019-06-27T14:17:52.000Z","updated":"2022-05-25T16:58:19.049Z","comments":true,"path":"2019/06/27/android-vm-1/","link":"","permalink":"https://ivonhoe.github.io/2019/06/27/android-vm-1/","excerpt":"这里说的Android虚拟机指运行在Android平台上的虚拟机，即日常遇到的Dalvik和ART虚拟机。这篇文章记录了自己对Android虚拟机几个问题的理解。只是个人学习和理解过程的记录，如有不当之处万望指正，邮箱&#x79;&#x61;&#x6e;&#103;&#x66;&#x61;&#110;&#51;&#54;&#56;&#55;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#x6d;。也希望在面对下面这些所谓JVM常见问题时能给你带来不一样的思考。 问题1：如何理解JVM内存模型？ 问题2：什么是GC ROOTS？ 问题3：Android虚拟机有没有分代回收？","text":"这里说的Android虚拟机指运行在Android平台上的虚拟机，即日常遇到的Dalvik和ART虚拟机。这篇文章记录了自己对Android虚拟机几个问题的理解。只是个人学习和理解过程的记录，如有不当之处万望指正，邮箱&#x79;&#x61;&#x6e;&#103;&#x66;&#x61;&#110;&#51;&#54;&#56;&#55;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#x6d;。也希望在面对下面这些所谓JVM常见问题时能给你带来不一样的思考。 问题1：如何理解JVM内存模型？ 问题2：什么是GC ROOTS？ 问题3：Android虚拟机有没有分代回收？ 0x02 堆转储HPROF协议在看JVM内存模型时，不妨先了解一下堆转储文件的协议。通过HPROF的问题格式可以大致了解JVM在内存中的划分情况。 2.1 HPROF文件格式总的来说，HPROF文件分为两个大的部分，分别是Hprof Header和Hprof Body。其中Header部分又包括以下几个部分： fixed header：包含文件描述以’&#x2F;0’结尾，id字段的长度信息等 string table：包含所有用到的字符串，包括类目、方法名、常量名等。 class table：包含所有的类信息 stack frame：包含所有线程的栈帧信息 stack trace：包含所有线程的虚拟机栈情况 Body部分就是完整的jvm堆信息，将堆上的对象引用状况表述到文件中。其中在表述类对象是静态方法和静态成员变量时稍复杂，详细格式请查看 3.2 ~ 3.4。以下是HPROF文件格式的详细说明： ||||||||||||| :——– | :——–:| :——: |:——: |:——: |:——: |:——: || “JAVA PROFILE 1.0.3&#x2F;0”(Magic Code) | 4byte mIdSize (储存id的字节长度) | 8byte (Time Stamp) || 0x01(string table) | 4 byte | 4 byte(字符串length) | mIdSize byte | strlen(length) byte|| …… | …… | …… | …… | …… || 0x02（class table) | 4 byte | 4 byte (length) | 4byte（class serial number） | mIdSize byte| 4 byte（Stack trace serial number）| 4 byte（class name string id）| …… | …… | …… | …… | …… || 0x04（stack frame) | 4 byte | 4 byte (length) | mIdSize byte | mIdSize byte (methodName string id) | mIdSize byte (methodSignature string id) | mIdSize byte (sourceFile string id ) | mIdSize byte (serial) | mIdSize byte (lineNumber )|| …… | …… | …… | …… | …… || 0x05（stack trace) | 4 byte | 4 byte (length) | 4 byte serialNumber | 4 byte threadSerialNumber | 4 byte numFrames | numFrames * mIdSize byte stack frame id|| …… | …… | …… | …… | …… || 0x0C（HEAP DUMP) | 4 byte | mIdSize byte (length) || 0xFF（ROOT_UNKNOWN) | mIdSize byte string id || 0x01（ROOT_JNI_GLOBAL) | mIdSize byte string id | mIdSize byte jni global id|| 0x02（ROOT_JNI_LOCAL) | mIdSize byte string id | 4 byte thread serial number | 4 byte stack frame number || 0x03（ROOT_JAVA_FRAME) | mIdSize byte string id | 4 byte thread serial number | 4 byte stack frame number || 0x04（ROOT_NATIVE_STACK) | mIdSize byte string id | 4 thread serial number|| 0x05（ROOT_STICKY_CLASS) | mIdSize byte string id || 0x06（ROOT_THREAD_BLOCK) | mIdSize byte string id | 4 thread serial number|| 0x07（ROOT_MONITOR_USED) | mIdSize byte string id || 0x08（ROOT_THREAD_OBJECT) | mIdSize byte string id | 4 byte thread serial number | 4 byte stackSerialNumber || 0x20（ROOT_CLASS_DUMP) | mIdSize byte string id || 0x21（ROOT_INSTANCE_DUMP) | mIdSize byte string id | mIdSize byte stackId | mIdSize byte class id | 4 byte remaining || 0x22(ROOT_OBJECT_ARRAY_DUMP)| mIdSize byte string id | mIdSize byte stack id | num elements | mIdSize byte class id| mIdSize * num elements(skip) || 0x23(ROOT_PRIMITIVE_ARRAY_DUMP)| mIdSize byte string id | mIdSize byte stack id | 4 byte num elements | 4 byte primitive type | mIdSize * num elements(skip) || 0xC3(ROOT_PRIMITIVE_ARRAY_NODATA)| mIdSize byte string id | mIdSize byte stack id | 4 byte num elements | 4 byte primitive type | 4 * num elements(skip) || 0xfe(ROOT_HEAP_DUMP_INFO) | mIdSize byte heap id | mIdSize byte heap name id(string id)| 0x89(ROOT_INTERNED_STRING)| mIdSize byte string id || 0x8a(ROOT_FINALIZING) | mIdSize byte string id || 0x8b(ROOT_DEBUGGER) | mIdSize byte string id || 0x8c(ROOT_REFERENCE_CLEANUP) | mIdSize byte string id || 0x8d(ROOT_VM_INTERNAL) | mIdSize byte string id || 0x8e(ROOT_JNI_MONITOR) | mIdSize byte string id | 4 byte thread serial number | 4 byte stack frame number || 0x90(ROOT_UNREACHABLE) | mIdSize byte string id|| 0x1C（HEAP DUMP SEGMENT) | 4 byte | mIdSize byte (length) | 2.2 ROOT_CLASS_DUMP的格式||||| :——– | :——–:|| 0x20(ROOT_CLASS_DUMP) | 1 || id| 4|| stack serial number| 4|| super class id| 4|| class loader id| 4|| signeres id| 4|| protection domain id| 4|| reserved| 4|| reserved| 4|| instance size | 4|| const pool num entries| 2|| 2 * num entries || static fields num entries | 2|| static fields | static fields num entries * (static fields)，下面会再单独列出来|| instance fields num entries| 2|| instance fields| instance fields num entries * (instance fields) 2.3 0x20(ROOT_CLASS_DUMP).Static Fields|||||| :——– | :——–:| :——: || 4 | 1 | 4|| static fields id| static fields type| type size| 2.4 0x20(ROOT_CLASS_DUMP).Instance Fields||||| :——– | :——–:|| 4 | 1|| instance id| instance type| 2.5 HEAP DUMP和HEAP DUMP SEGMENT的区别如果你仔细研究了上面的内容的话，可能你就会有这样一个问题，HEAP DUMP和HEAP DUMP SEGMENT有什么区别？为什么要有两个标记？其实堆转储的hprof文件格式中，原本是使用4字节32位存储堆对象的 “HEAP DUMP” (0x0C)的区块长度，但同时也就限制了HEAP DUMP的大小必须在4GB以内。在出现这个问题的情况下，在HPROF文件中新增了”HEAP DUMP SEGMENT” (0x1C)的格式，用来将超过4GB的JVM堆对象信息分别存储到文件的多个区块中。 Be Careful with HPROF Heapdumps Bigger than 4GB @2013-04-16 0x03 理解JVM内存模型 程序计数器在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域。 Java虚拟机栈线程私有，每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。 本地方法栈线程私有，本地方法栈的功能和特点类似于虚拟机栈，不同的是，本地方法栈服务的对象是JVM执行的native方法，而虚拟机栈服务的是JVM执行的java方法。我们常见的HotSpot虚拟机选择合并了虚拟机栈和本地方法栈。 Java堆所有线程共享的内存区域，所有对象实例及数组都要在堆上分配内存。 方法区所有线程共享的内存区域，为了区分堆，又被称为非堆。用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。 在谈到JVM内存结构时，从HPROF文件的header和body部分就有体现，从数据上划分结构就可以分为方法区（包括运行时常量池，也就是header中string table的部分）、java堆（body部分）、虚拟机栈、本地方法栈和程序计数器。其中方法区和java堆部分是所有线程共享的数据区，其他则为线程独有的数据区。为什么会有这样的结构划分和设计？先看设计内存的目的，是因为随着CPU运转速度越来越快，磁盘远远跟不上CPU的读写速度，才设计了内存。但是随着CPU的发展，内存的读写速度也远远跟不上CPU的读写速度，为了解决这一纠纷，CPU厂商在每颗CPU上加入了高速缓存来缓解这种症状。基于高速缓存的存储交互很好的解决了处理器与内存之间的矛盾，也引入了新的问题：缓存一致性问题。在多处理器系统中，每个处理器有自己的高速缓存，而他们又共享同一块内存。回到JVM的内存模型中， Java中通过多线程机制使得多个任务同时执行处理，所有的线程共享JVM内存区域main memory，而每个线程又单独的有自己的工作内存，当线程与内存区域进行交互时，数据从主存拷贝到工作内存，进而交由线程处理。这样也就说的通了，为啥在JVM中有的区域是线程共享的，有的区域是线程独享的。 0x04 什么是GC和GC_ROOTS？4.1 什么是GC垃圾回收(Garbage Collection，简称GC)，是垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。这种机制也不单单只有Java虚拟机才有，ObjectC和C#都有自己相应的垃圾回收机制，垃圾回收机制是帮助程序员自动管理对象内存空间的机制。 4.2 什么是GC ROOTS常见的垃圾回收方式，引用计数算法和根搜索算法。引用计数就像是每个对象有个账本，当一个对象被另一个对象引用时该对象的引用计数器+1，当引用失效时引用计数器-1，任何引用计数为0的对象可以被当作垃圾收集。引用计数有一个先天的缺陷，那就是多个对象相互持有引用形成一个引用环是，那么环中的所有对象引用计数都不为0，这时这些对象都不能被垃圾回收器回收。根节点搜索指的是从根节点集合出发找到所有引用链可达对象，当一个对象到根节点集合（GC ROOTS）没有任何引用链存在时就证明此对象是不可用的。从对比JVM规范的垃圾回收根节点(来自：Garbage Collection Roots)、HPROF文件协议中的GC ROOTS tag类型和square haha库源码中对GC ROOTS的类型定义，参照下表。 |JVM规范名称| HPROF中的TAG | haha库中的RootType枚举类型 | 描述 || :——– | :——–:| :——: |:——: |:——: |:——: |:——: || System Class | 0x05 | RootType.SYSTEM_CLASS | 被bootstrap&#x2F;system class加载器加载的类，例如所有rt.jar中包名为 java.util.*的类 || JNI Local | 0x02 | RootType.NATIVE_LOCAL | native代码中的本地变量，例如user defined JNI code or JVM internal code || JNI Global | 0x01 | RootType.NATIVE_STATIC | native中的全局变量，例如user defined JNI code or JVM internal code || Thread Block | 0x06 | RootType.THREAD_BLOCK | || Thread | | | || Busy Monitor | 0x07 | RootType.BUSY_MONITOR | 所有调用 wait()、 notify()方法的， 或者同步的。For example, by calling synchronized(Object) or by entering a synchronized method. Static method means class, non-static method means object. || Java Local | 0x03 | RootType.JAVA_LOCAL | 本地变量，例如线程栈帧中的参数和方法 || Native Stack | 0x04 | RootType.NATIVE_STACK | In or out parameters in native code, such as user defined JNI code or JVM internal code. This is often the case as many methods have native parts and the objects handled as method parameters become GC roots. For example, parameters used for file&#x2F;network I&#x2F;O methods or reflection || Finalizable | 0x8a | RootType.FINALIZING | 在finalizer等待队列里的对象 || Unfinalized | | | || Unreachable | 0x90 | RootType.UNREACHABLE | 从其他根节点都无法到达的对象 || Java Stack Frame | 0x03 | RootType.JAVA_LOCAL | A Java stack frame, holding local variables. Only generated when the dump is parsed with the preference set to treat Java stack frames as objects. || Unknown | 0xff | RootType.UNKNOWN | || | 0x89 | RootType.INTERNED_STRING | || | 0x8b | RootType.DEBUGGER | || | 0x8c | RootType.REFERENCE_CLEANUP | || | 0x8d | RootType.VM_INTERNAL | || | 0x8e | RootType.NATIVE_MONITOR | | 对照上面这个表总结起来，所谓JVM GC Roots是进行垃圾回收时根节点的集合。大致包含以下几个方面： 所有Java线程当前活跃的栈帧所指向GC堆里的对象的引用，换句话说，当前所有正在被调用的方法的引用类型的参数&#x2F;局部变量&#x2F;临时值。 VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。 所有当前被加载的Java类 JNI handles，包括global handles和local handles Java类的引用类型静态变量 Java类的运行时常量池里的引用类型常量（String或Class类型） String常量池（StringTable）里的引用 按照根搜索GC的思想，从根节点出发的找到的对象就被认定为存活的，其他的对象都是“无用的”，但是GC ROOTS的集合不应该是一成不变的，特别是面对分代GC时。为啥这样说呢？分代GC是一种部分收集（partial collection）的做法。在执行部分收集时，从GC堆的非收集部分指向收集部分的引用，也必须作为GC roots的一部分。具体到分两代的分代式GC来说，如果第0代叫做young gen，第1代叫做old gen，那么如果有minor GC &#x2F; young GC只收集young gen里的垃圾，则young gen属于“收集部分”，而old gen属于“非收集部分”，那么从old gen指向young gen的引用就必须作为minor GC &#x2F; young GC的GC ROOTS的一部分。所以针对一次GC来说，GC ROOTS的类型类型范围未必只有jvm规范定义中所列举的那几种情况。 0x05 Android虚拟机有分代GC吗？Android Q开始google才为ART虚拟机添加分代收集机制。 参考文档JVM内存模型与GC算法Android Hprof 协议java的gc为什么要分代？RednaxelaFX的回答Android Q Beta 正式发布 | 精于形，安于内https://www.cnblogs.com/dingyingsi/p/3760447.html","categories":[{"name":"学习总结","slug":"学习总结","permalink":"https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"Android系统上绘制圆角和阴影的几种姿势","slug":"android-corner-shadow","date":"2019-01-29T03:41:57.000Z","updated":"2022-05-25T16:53:15.821Z","comments":true,"path":"2019/01/29/android-corner-shadow/","link":"","permalink":"https://ivonhoe.github.io/2019/01/29/android-corner-shadow/","excerpt":"在实际的开发工程中，对视图增加圆角和阴影效果的绘制是比较常见的需求，Android系统提供了一系列的方法以帮助开发者实现基础的视图圆角和阴影效果，但在面对实际的视觉需求时，想要完美达到视觉设计师的设计要求就难免需要了解一些基础的绘图原理和绘图方法才能达到特殊的设计需求，这里就简单对比和总结了常见的圆角和阴影的绘图方法。","text":"在实际的开发工程中，对视图增加圆角和阴影效果的绘制是比较常见的需求，Android系统提供了一系列的方法以帮助开发者实现基础的视图圆角和阴影效果，但在面对实际的视觉需求时，想要完美达到视觉设计师的设计要求就难免需要了解一些基础的绘图原理和绘图方法才能达到特殊的设计需求，这里就简单对比和总结了常见的圆角和阴影的绘图方法。 圆角View的圆角背景实现圆角效果使用原生提供的ShapeDrawable实现背景。 1234567&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;#ff0000&quot; /&gt; &lt;corners android:topLeftRadius=&quot;10dp&quot; android:topRightRadius=&quot;10dp&quot; android:bottomRightRadius=&quot;10dp&quot; android:bottomLeftRadius=&quot;10dp&quot;/&gt;&lt;/shape&gt; 使用圆角贴图实现圆角效果在介绍“贴图”之前先说明在Android绘图相关的两个必备知识，分布是Paint Style和Path。 Paint Style在用画笔（Paint）的时候有三种Style，选择不同的画笔样式时就可达到不同的画笔效果，分别是 Paint.Style.STROKE 只绘制图形轮廓(描边) Paint.Style.FILL 只绘制图形内容 Paint.Style.FILL_AND_STROKE 既绘制轮廓也绘制内容 Path当我们在想要绘制一些形状时，Canvas提供了一些基础形状的绘制方法，如圆形、矩形、椭圆等。你只需要选择相应的绘制方法并设置你想要的绘制参数就能绘制出你想要的简单图形效果。但对于那些复杂一点的图形则没法去绘制，如一个心形、正多边形、五角星等，使用Path不仅能够绘制简单图形，也可以绘制这些比较复杂的图形。Path封装了由直线和曲线(二次，三次贝塞尔曲线等)构成的几何路径。你能用Canvas中的drawPath来把这条路径画出来(同样支持Paint的不同绘制模式)，也可以用于剪裁画布和根据路径绘制文字。 如何制作圆角贴图以左上角贴图实现为例，使用Path约束绘图范围 123456789101112RectF fakeCornerRectF = sRectF;fakeCornerRectF.set(0, 0, mCornerRoundRadius * 2, mCornerRoundRadius * 2);// 绘制左上圆角背景if (mTopLeftCorner) &#123; fakeCornerRectF.offsetTo(left - mCornerOffset, top - mCornerOffset); mCompatibilityModePath.rewind(); mCompatibilityModePath.moveTo(left - mCornerOffset, top - mCornerOffset); mCompatibilityModePath.lineTo(left + mCornerRoundRadius, top - mCornerOffset); mCompatibilityModePath.arcTo(fakeCornerRectF, START_TOP, -QUARTER_CIRCLE); mCompatibilityModePath.close(); canvas.drawPath(mCompatibilityModePath, mBackgroundPaint);&#125; 使用Paint.Style.FILL画笔绘制，将贴图效果绘制在ImageView容器的（0，0）坐标上。即可达到想要的圆角效果 对Bitmap的裁剪实现圆角效果例如使用android support包里的RoundedBitmapDrawable，创建一个被裁剪圆角的BitmapDrawable。 12RoundedBitmapDrawable drawable = RoundedBitmapDrawableFactory.create(mContext.getResources(), bitmap);drawable.setCornerRadius(40); 对Canvas画板做裁剪实现圆角效果12345678910111213@Overrideprotected void onDraw(Canvas canvas) &#123; int left = getPaddingLeft(); int top = getPaddingTop(); int right = canvas.getWidth() - getPaddingRight(); int bottom = getHeight() - getPaddingBottom(); mCanvasRect.set(left, top, right, bottom); mCanvasPath.reset(); mCanvasPath.addRoundRect(mCanvasRect, mRx, mRy, Path.Direction.CW); canvas.clipPath(mCanvasPath); super.onDraw(canvas);&#125; 阴影elevation属性和translationZ属性UI 控件的elevation属性可以设置其高度，呈现在界面中的直观效果就是阴影效果，在 xml 布局文件中，通过 android:elevation 属性设置，在 java 代码中通过 View 类提供的setElevation()方法设置。但是这个属性存在版本兼容问题，是 Android 5.0 引进的 API。所以，当 minSdkVersion 值小于21时，系统会在 xml 的对应使用地方给出一个 lint 提示： Attribute elevation is only used in API level 21 and higher 当然你也可以选择忽略这个提示，或者使用tools:targetApi属性消除这个提示，这样做的话，在低于5.0版本的系统中将不会出现阴影效果。然而，有一个更好的办法做到兼容，那就是借助ViewCompat这个万能的兼容类,使View 的 elevation 属性兼容至低版本中： ViewCompat.setElevation(View view, float elevation) 注意：尤其要注意，视图的阴影一定是由有轮廓的视图投射出来的。简单来说，就是需要设置控件的背景，即 android:background 属性。我们可以选择图片作为背景，也可以使用 标签定义一个 drawable 形状。 使用.9图实现阴影效果说到阴影效果最简单最省力的方法莫过于设置一个.9的背景图啦！这里推荐一个站点，可以在线制作.9阴影图。http://inloop.github.io/shadow4android/ 使用模糊画笔绘制阴影效果 先看想要做到的阴影效果，想要在红色的轮播banner下方显示一条红色的阴影效果。用已知的阴影方案比如设置视图的Z轴高度或者设置.9阴影背景都无法实现这种效果。 可以将实现上图的局部阴影效果的绘制步骤分解成两层： 自定义一个ShadowLayout容器，在onDraw方法中重写绘制步骤 如何绘制阴影效果？使用带有BlurMaskFilter效果的画笔在合适的地方绘制一个椭圆阴影。可以理解成先用一个模糊画笔先画眉，再在合适的位置上绘制想要的图片。画眉效果如下图： 这里有个前提，需要关闭当前View的硬件加速功能。setLayerType(LAYER_TYPE_SOFTWARE, null)。具体的实现代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Overrideprotected void onDraw(Canvas canvas) &#123; drawShadow(canvas); super.onDraw(canvas);&#125;private void drawShadow(Canvas canvas) &#123; if (shadowView != null &amp;&amp; shadowOn) &#123; canvas.drawOval(getDrawOvalRect(), getShadowPaint()); &#125;&#125;private int getShadowColor() &#123; if (!runPalette) &#123; return shadowColor; &#125; runPalette = false; if (shadowView instanceof ImageView) &#123; if (((ImageView) shadowView).getDrawable() instanceof ColorDrawable) &#123; shadowColor = getDarkerColor(((ColorDrawable) ((ImageView) shadowView).getDrawable()).getColor()); &#125; else if (((ImageView) shadowView).getDrawable() instanceof BitmapDrawable) &#123; Bitmap bitmap = ((BitmapDrawable) ((ImageView) shadowView).getDrawable()).getBitmap(); Palette.Swatch mSwatch = Palette.from(bitmap).generate().getDominantSwatch(); if (null != mSwatch) &#123; int rgb = mSwatch.getRgb(); shadowColor = 0x4C000000 | (Color.red(rgb) &lt;&lt; 16) | (Color.green(rgb) &lt;&lt; 8) | Color.blue(rgb); &#125; &#125; else &#123; shadowColor = Color.TRANSPARENT; &#125; &#125; return shadowColor;&#125;private Paint getShadowPaint() &#123; if (shadowView != null) &#123; int rgb = getShadowColor(); shadowPaint.setColor(rgb); shadowPaint.setMaskFilter(new BlurMaskFilter(paddingBottom, BlurMaskFilter.Blur.NORMAL));// shadowPaint.setShadowLayer(radius, 0, shadowDimen, rgb); &#125; return shadowPaint;&#125; 参考文档https://yifeng.studio/2017/02/26/android-elevation-and-shadow/","categories":[{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/categories/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/tags/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"}]},{"title":"ANR分析记录(一)","slug":"android-anr-1","date":"2018-10-14T13:09:15.000Z","updated":"2022-05-25T16:51:36.367Z","comments":true,"path":"2018/10/14/android-anr-1/","link":"","permalink":"https://ivonhoe.github.io/2018/10/14/android-anr-1/","excerpt":"Application Not Responding（简称:ANR）指应用中一些特定的事件（如用户触摸事件、广播等）在应用的主线程没有在规定的时间内处理完，系统自动做出终止应用运行的响应。问题出现的原因主要是两个方面： 应用进程自身引起的，例如：主线程阻塞、挂起、死循环 应用进程的其他线程的CPU占用率高，使得主线程无法抢占到CPU时间片 常见的三种ANR类型： KeyDispatchTimeout(谷歌默认5s，MTK平台上是8s): 主要类型按键或触摸事件在特定时间内无响应 BroadcastTimeout(10s): 主要是BroadcastRecevier在规定时间无法处理完成。前台广播超时时间是10s,后台广播超时是60s,这类超时没有提示框弹出。代码见AMS的BROADCAST_FG_TIMEOUT和BROADCAST_BG_TIMEOUT。 ServiceTimeout(20s): Service在规定时间内无法处理完成操作，即会报出服务超时，这类ANR同样没有提示框出现。超时时间，前台Service是20s，后台Service是200s。代码见ActivityServices的SERVICE_TIMEOUT和SERVICE_BACKGROUND_TIMEOUT。","text":"Application Not Responding（简称:ANR）指应用中一些特定的事件（如用户触摸事件、广播等）在应用的主线程没有在规定的时间内处理完，系统自动做出终止应用运行的响应。问题出现的原因主要是两个方面： 应用进程自身引起的，例如：主线程阻塞、挂起、死循环 应用进程的其他线程的CPU占用率高，使得主线程无法抢占到CPU时间片 常见的三种ANR类型： KeyDispatchTimeout(谷歌默认5s，MTK平台上是8s): 主要类型按键或触摸事件在特定时间内无响应 BroadcastTimeout(10s): 主要是BroadcastRecevier在规定时间无法处理完成。前台广播超时时间是10s,后台广播超时是60s,这类超时没有提示框弹出。代码见AMS的BROADCAST_FG_TIMEOUT和BROADCAST_BG_TIMEOUT。 ServiceTimeout(20s): Service在规定时间内无法处理完成操作，即会报出服务超时，这类ANR同样没有提示框出现。超时时间，前台Service是20s，后台Service是200s。代码见ActivityServices的SERVICE_TIMEOUT和SERVICE_BACKGROUND_TIMEOUT。 0x01 KeyDispatchingTimedOut1.1 错误实例先看下面的错误实例： 1234567891011121314151617181920212223242526272829303132333435@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 异步操作数组 saveListToDb(); traverseList();&#125;public void traverseList() &#123; Handler handler = new Handler(); handler.post(new Runnable()&#123; synchronized (mList) &#123; // todo something &#125; &#125;);&#125;public void saveListToDb() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (mList) &#123; try &#123; // todo save list Thread.sleep(50000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start();&#125; 1.2 adb日志和traces分析在子线程保存数据到文件或数据库(这里用sleep操作模拟耗时io操作)，如果同时可能涉及到在主线程操作同一个锁对象的情况在，这时你是否会习惯的使用synchronized关键词保证list的同步呢？当在主线程和异步线程产生了对相同对象的竞争关系，那这时就很容易出现主线程的阻塞，而阻塞的时间长短就取决于主线程啥时候获取到竞争对象。而此时反馈在系统层面当用户操作不会得到响应，最终应用以ANR的形式退出。运行上面的错误代码你会获取类似下面的ANR日志信息Input dispatching timed out (Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.)查看虚拟机trace文件输出目录adb shell getprop dalvik.vm.stack-trace-file，再查看手机目录下/data/anr/traces.txt的文件内容，会发现main线程在等待释放锁&lt;0x0af98db2&gt;,而这个锁正在被thread 10所持有 再查看tid&#x3D;10的线程的线程状态，该线程正在sleeping，这也印证了上面实例的代码，主线程在等待一个sleep线程释放锁而导致了ANR。当然在实际项目中的日志和原因未必会这么明显，但形如实例的错误代码确实是很常见的场景。 1.3 traces.txt关键信息注 pid为进程id，sysTid&#x3D;pid，这里主线程的线程号&#x3D;进程号，prio&#x3D;5为线程优先级 当一个线程占有一个锁的时候，会打印-locked&lt;0xxxxxxx&gt; 当该线程正在等待别的线程释放该锁，会打印waiting to lock &lt;0xxxxxx&gt; 如果代码中有wait()调用的话，首先是locked，然后会打印waiting on &lt;0xxxxxx&gt; 1.4 ANR Input event dispatching timed out Reason参考http://gityuan.com/2017/01/01/input-anr/的input-anr异常原因的总结，input anr主要分为以下几类。 无窗口, 有应用：Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up. 窗口暂停: Waiting because the [targetType] window is paused. 窗口未连接: Waiting because the [targetType] window’s input channel is not registered with the input dispatcher. The window may be in the process of being removed. 窗口连接已死亡：Waiting because the [targetType] window’s input connection is [Connection.Status]. The window may be in the process of being removed. 窗口连接已满：Waiting because the [targetType] window’s input channel is full. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度]. 按键事件，输出队列或事件等待队列不为空：Waiting to send key event because the [targetType] window has not finished processing all of the input events that were previously delivered to it. Outbound queue length: [outboundQueue长度]. Wait queue length: [waitQueue长度]. 非按键事件，事件等待队列不为空且头事件分发超时500ms：Waiting to send non-key event because the [targetType] window has not finished processing certain input events that were delivered to it over 500ms ago. Wait queue length: [waitQueue长度]. Wait queue head age: [等待时长]. targetType: 取值为”focused”或者”touched” Connection.Status: 取值为”NORMAL”，”BROKEN”，”ZOMBIE” 所以如2.1中实例代码，当ANR发生在Activity的onCreate流程中时，你讲看到无窗口, 有应用的日志信息，当ANR发生在对某个View的OnClickListener中时，你将从日志中获取事件等待队列不为空且头事件分发超时500ms的信息，这样通过不同的日志信息就可大致定位ANR出现的用户场景，进而方便定位出问题代码。 参考文档http://yuanfentiank789.github.io/2017/09/05/ANR%E5%88%86%E6%9E%90/http://gityuan.com/2017/01/01/input-anr/https://maoao530.github.io/2017/02/21/anr-analyse/http://rayleeya.iteye.com/blog/1955657","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"anr","slug":"anr","permalink":"https://ivonhoe.github.io/tags/anr/"}]},{"title":"移动端无痕埋点实践详解(二)","slug":"how-to-track-users-2","date":"2018-09-11T13:07:24.000Z","updated":"2022-05-25T16:58:48.488Z","comments":true,"path":"2018/09/11/how-to-track-users-2/","link":"","permalink":"https://ivonhoe.github.io/2018/09/11/how-to-track-users-2/","excerpt":"在移动端无痕埋点实践详解（一）这篇文章大致总结了移动端无痕埋点的基本原理。主要介绍了什么是无痕埋点，无痕埋点的基础数据流程以及在Android系统上总体思路。这篇文章着重总结下无痕埋点方案的实施过程中在Android和iOS系统上几个细节的解决方案。","text":"在移动端无痕埋点实践详解（一）这篇文章大致总结了移动端无痕埋点的基本原理。主要介绍了什么是无痕埋点，无痕埋点的基础数据流程以及在Android系统上总体思路。这篇文章着重总结下无痕埋点方案的实施过程中在Android和iOS系统上几个细节的解决方案。 0x02 xpath2.1 什么是xpathxpath是移动端定义可操作区域的数字标识，是用来标识可操作的控件的。既然想要通过一串字符标识在移动端app中的可操作控件，那么xpath的生成规则需要满足以下几个原则： 唯一性: 在当前app中不存在不同控件对应相同Xpath 稳定性: 不同版本app中，在没有页面结构变更的情况下，不同版本中相同页面中相同控件的Xpath要保持不变 2.1 Android中如何生成xpath在满足上述xpath原则的基础上，可通过以下几个参数作为组成XPath的生成参数： 页面：标记当前控件所在的页面url，Webview页面为其html的url，native页面url可定义该页面的virtual url 页面中位置：如何描述一个控件在该页面的位置，在Android系统中很容易想到DecorView和页面子view的关系。使用View到DecorView的位置关系来描述视图控件在该页面中的相对位置。 控件标记：这里的控件标记指的是相对于相同父容器的兄弟视图来说，如何更好的区别彼此。这里很容易能够想到view id。但是这里并不推荐使用view id作为标记。因为id是在版本迭代过程中很容易因为资源数量的变化而发生变化。并不能满足标记稳定性的原则，目前在Android上我选择resource name作为视图控件的标记。在ios上 综上所述就可以得到以下的XPath生成方式。 $ xpath &#x3D; Md5(url+root path + resource name)$ 2.2 iOS系统中如何生成xpath参考 https://www.jianshu.com/p/69ce01e15042 2.3 如何识别xpath在用户产生用户点击数据的过程中，埋点系统上报控件xpath给埋点后台，但是在实际的数据分析过程中需要知道每个xpath对应的控件和区块名称具体是什么。在每个电商系统中针对埋点都会有一套自己的位置模型规范，简称SPM（super position model）。所以针对最终的数据分析和统计需要一个xpath到spm的映射关系，将实际产生的xpath埋点数据转换成业务中的SPM。实现方式也很简单，只需要在开发版本中提供一个编辑模式，将移动端本地生成的xpath通过一个编辑工具转换成SPM数据就可以了，简单的效果图如下所示： 0x03 Android如何记录页面跳转在考虑记录页面跳转的方案时，可能最先想到的是在通过统一路由跳转的方式跟踪所有页面跳转，但是实际的项目中首先你得有个统一的路由不是？在面对已有的项目代码从工作量和效果上来说这种方式都不是最佳方案。即便是已有统一的路由方案也很难保证没有错埋漏埋的情况存在。别忘记 ActivityLifecycleCallbacks 123456789101112131415161718192021222324252627282930313233343536373839public class RuntimeActivityCallbacks implements Application.ActivityLifecycleCallbacks &#123; private Map&lt;String, Long&gt; mPageResumeTime = new HashMap&lt;&gt;(); /** * 页面对应的referrerId，一个activity可能有多个子页面，一个activity的referrerId为当前显示的子页面的referrerId */ private Map&lt;Integer, String&gt; mPageReferrerMap = new HashMap&lt;&gt;(); @Override public void onActivityResumed(Activity activity) &#123; // 针对页面的跟踪 if (activity instanceof IPageTracker) &#123; IPageTracker pageTracker = (IPageTracker) activity; String url = pageTracker.getReferrerId(); mPageResumeTime.put(url, System.currentTimeMillis()); mPageReferrerMap.put(activity.hashCode(), url); AppTraceTool.traceOpenPage(url, ModuleManager.getTopPageUrl()); // 保存当前页面为top ModuleManager.setTopPageUrl(url); &#125; else &#123; ModuleManager.setTopPageUrl(&quot;unknown&quot;); &#125; &#125; @Override public void onActivityStopped(Activity activity) // 针对页面的跟踪 if (activity instanceof IPageTracker) &#123; IPageTracker pageTracker = (IPageTracker) activity; String url = pageTracker.getReferrerId(); mPageResumeTime.remove(url); mPageReferrerMap.remove(activity.hashCode()); AppTraceTool.traceLeavePage(url, second); &#125; &#125;&#125; 0x04 如何使用无痕埋点方案记录业务数据转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"方案与设计","slug":"方案与设计","permalink":"https://ivonhoe.github.io/categories/%E6%96%B9%E6%A1%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"无痕埋点","slug":"无痕埋点","permalink":"https://ivonhoe.github.io/tags/%E6%97%A0%E7%97%95%E5%9F%8B%E7%82%B9/"}]},{"title":"Android插件化之从入门到放弃","slug":"abandon-the-plugin-framework","date":"2018-07-18T12:45:30.000Z","updated":"2022-05-25T16:50:19.378Z","comments":true,"path":"2018/07/18/abandon-the-plugin-framework/","link":"","permalink":"https://ivonhoe.github.io/2018/07/18/abandon-the-plugin-framework/","excerpt":"Android插件化框架一直以来就是安卓平台上的一个重要技术方向，从携程的DynamicAPK到360RePlugin再到阿里巴巴的Atlas，甚至美团和滴滴的安卓团队都有自己的一套安卓插件化解决方案。面对业界如此热门的技术方向，在对比业界开源的插件化方案后，团队内部于去年10月份开始(2017.10)在项目中选择开源的Small插件化框架进行了尝试。鞋是否合适需要穿上脚才能知道。这篇文章总结了我在使用Small插件化框架后，自己对插件化的理解和思考。","text":"Android插件化框架一直以来就是安卓平台上的一个重要技术方向，从携程的DynamicAPK到360RePlugin再到阿里巴巴的Atlas，甚至美团和滴滴的安卓团队都有自己的一套安卓插件化解决方案。面对业界如此热门的技术方向，在对比业界开源的插件化方案后，团队内部于去年10月份开始(2017.10)在项目中选择开源的Small插件化框架进行了尝试。鞋是否合适需要穿上脚才能知道。这篇文章总结了我在使用Small插件化框架后，自己对插件化的理解和思考。 关于Small插件化的其他文档《Android插件化之Small框架实践总结》《Android插件化之Small框架原理》《Android插件化之资源加载机制》 0x02 重新审视插件化框架的利弊2.1 插件化方案想要解决的核心问题 安卓的动态化发布 动态化就像是天赋，有些人天生就有的能力却是需要你花非常大精力也未必能获取到的。前端的开发应该从来不需要动态化的方案吧！插件化方案的一个最大作用应该就是绕开应用市场的审核周期，尽可能的像后端Java或者前端JS一样，随时发布随时生效。 真正意义上的模块解耦 插件化的方式让模块与模块之间在开发方式上真正的隔离，达到了解耦的目标。而这在之前android原生的开发方式上是很难达到的。 dex 65535问题 插件化的方案也可以看做一个dex分包和资源分包的方案。 2.2 Small插件化方案带来的新问题在《Android插件化之Small框架实践总结》 中对比了Small插件化框架的优缺点，选择Small最重要的原因还是轻量化，当然很多问题也是轻量化带来的。 兼容性问题 兼容性问题大致分布在以下几个方面： 与google最新系统和编译工具的兼容。18年第三季度最新版本Android P系统的新手机会陆续上市，插件化架构对新系统的兼容性问题会变的急切。并且插件化框架针对安卓系统的黑科技也越来越不被新版本系统接受。Android Studio 3.1最新新编译工具的兼容问题。 业界移动安全方案的兼容。常见的三方dex加壳方案无法在插件化框架上顺利运用。 第三方框架的兼容，常见涉及AOP的第三方框架，如AAC和Small框架不兼容。甚至React Native方案都需要花很多时间和精力去适配。 插件化框架带来的稳定性问题 资源查找失败的bug，虽然已经接近了在个别国产手机上的资源查找失败问题，详情见《Android插件化之资源加载》。但是在Android 7.1以上的系统上依然出现偶现的资源查找失败问题。并且崩溃率（错误数&#x2F;启动次数）在0.3%左右。这个比例其实不算低了。这个bug暂时只能通过将插件资源转移到宿主分身中绕过。但是如果把所有插件资源都放到宿主中以规避这个问题，那插件化就没有任何意义了。 2.3 重新思考插件化框架给安卓app的收益在团队技术选型上优先考虑的应该是和现有业务适配吧。如果你所面对的业务不存在快速迭代频繁发布的需求，插件化框架的威力可能就要减小一半了。同时在选择个人开发者维护的开源项目时，依然是要考虑到其架构的稳定性和bug的修复时效。因为一旦在一个商业化的项目中使用开源框架，稳定性和兼容性一定会放在首要位置的。在这一点上，可能从大公司孵化出的开源项目会更有优势。 在回看插件化框架对android应用中模块解耦的贡献，对比android应用的原生的开发方式。能够从插件化框架吸收的模块解耦方法上可以看到大致这几个方面。 模块间的解耦要依赖工具而不是约定开发规范 以2个业务app模块为例，应该有一个工具存在避免这两个模块产生耦合关系，如果一旦存在耦合关系就可能编译报错。而不是靠开发者约定的开发规范。因为规范是可以不遵守的。这是同层级间的耦合管理。 避免依赖传递 这是不同层级的模块间耦合问题。implementation关键词就可以解决这个问题。 路由 相比较插件化框架你可能更需要一个页面路由工具，业界有很多业界路由框架，比如阿里的ARouter，路由用来解决模块解耦带来的页面跳转问题，所以自己动手实现一个简单的路由工具也不是很难。 2.3 implementation、api和compile的差异可以查看google文档上对Android Studio 3.0后新引入的依赖配置的差异说明。https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration 简单来说google将compile配置拆成了两个关键词，分别是api和implementation。api和implementation的差异不单单是编译效率的差异，我觉得更重要的是，implementation避免了依赖的传递。以下图对比api和implementation的差异可以发现，当使用implementation配置依赖时，app模块将不会直接依赖D模块。在使用老的依赖配置compile时，实际上并没有做到模块的分层，最底下的模块依然可以被最上层的模块依赖，实际的依赖规则在开发者的规范里，而不存在项目模块的管理中。 0x04 总结以上就是我对插件化框架的看法，如果你的业务存在开始迭代频繁发布的情况存在，那么你可能就很需要一个插件化框架来带来开发方式上的改变，核心在于提高了研发效率。但是在使用插件化项目之前你需要对插件化框架的边界和扩展边界的成本有一个清晰的认识。实际上上面所说的所有插件化框架带来的问题都是可以解决的。问题的关键在于在你的团队这样的付出和产出是否值得呢？相信每个人都可能会有不同的看法。 当然开源的插件化框架依然是重点学习的方向，理解不同插件化方案的实现原理是深入理解安卓系统很好的切入点。接下来我还会花更多的时间深入的学习360和阿里巴巴的插件化方案。 最近在读《邓小平改变中国》这本书，让我对从文革结束到改革开放前那段对大多数中国人讳莫如深的历史有了大致的了解。“实践是检验真理的唯一标准”，这句很多80后90后耳熟能详的口号背后，原来发生了这么多的波折，冲破了如此多的障碍。理论与实践的统一是马克思主义的一个最基本的原则。实事求是是毛泽东思想的精髓。听起来虚头巴脑，但确实应该是解决问题和对待未知事物的核心方法论。对！这是一篇技术总结。 0x05 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"Android插件化","slug":"Android插件化","permalink":"https://ivonhoe.github.io/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96/"}],"tags":[{"name":"插件化","slug":"插件化","permalink":"https://ivonhoe.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"}]},{"title":"Android客户端HTTP网络框架设计与实践","slug":"network-architecture-design","date":"2018-07-08T13:30:33.000Z","updated":"2022-05-25T16:59:30.843Z","comments":true,"path":"2018/07/08/network-architecture-design/","link":"","permalink":"https://ivonhoe.github.io/2018/07/08/network-architecture-design/","excerpt":"不管是android、ios还是浏览器端的开发，在正常的产品迭代过程中HTTP网络请求都是高频使用的功能。以android端为例，在使用常见的http网络框架时，如HttpUrlConnection,HttpClient或者okHttp ，开发者都必须在此自身业务场景的基础上进行api的二次封装。一个功能强大且易用的网络框架不仅仅能够提高开发效率，起到事半功倍的效果，还能起到规范业务开发结果的作用。希望通过这篇文章，总结下自己在设计和实现一个网络框架时的思考过程，也帮助团队同学了解现有网络框架的能力和不足。","text":"不管是android、ios还是浏览器端的开发，在正常的产品迭代过程中HTTP网络请求都是高频使用的功能。以android端为例，在使用常见的http网络框架时，如HttpUrlConnection,HttpClient或者okHttp ，开发者都必须在此自身业务场景的基础上进行api的二次封装。一个功能强大且易用的网络框架不仅仅能够提高开发效率，起到事半功倍的效果，还能起到规范业务开发结果的作用。希望通过这篇文章，总结下自己在设计和实现一个网络框架时的思考过程，也帮助团队同学了解现有网络框架的能力和不足。 0x02 使用者的视角2.1 使用volley发送Http get请求的示例代码： 123456789101112131415161718192021// Instantiate the RequestQueue.RequestQueue queue = Volley.newRequestQueue(this);String url =&quot;http://www.google.com&quot;;// Request a string response from the provided URL.StringRequest stringRequest = new StringRequest(Request.Method.GET, url, new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String response) &#123; // Display the first 500 characters of the response string. mTextView.setText(&quot;Response is: &quot;+ response.substring(0,500)); &#125;&#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; mTextView.setText(&quot;That didn&#x27;t work!&quot;); &#125;&#125;);// Add the request to the RequestQueue.queue.add(stringRequest); 查看以上Volley使用的官方示例，可以将其划分为以下几个使用步骤： 构建一个请求队列 构造一个请求Request对象和接收请求结果的Response.Listener 将请求Request添加到请求队列中 通过volley的使用方法你就可以大致猜测volley在完成一个网络请求的大致过程。开发者使用请求相关信息和接收返回结果的Callback封装成一个Request,并将其放在请求队列中，在请求队列的背后一定有负责真正网络请求任务的线程从队列中消费网络请求的Request，在获取网络请求结果后通过线程间消息机制将网络请求的结果在主线程返回给接受消息的Response.Listener。当然真正的过程肯定会更复杂。但是不管怎样，volley的设计思路是一个经典的生产者消费者模式。从一个Volley api使用者的视角回头再看一下volley，你是否有这些疑问？ 在一个开发者的使用过程，他需要知道请求队列的存在吗？除非他想要改变请求的优先级规则或者有其他想要改变请求在请求队列中顺序的需求。 构造Request的方式不友好。以Get请求为例，需要自己手动将请求参数拼接到请求url中。如果是POST请求情况还会更复杂。 接受请求结果的方式不友好，指定Response.Listener对象接收请求让代码不够美观不说，更建立了请求者和请求框架之间的强耦合关系。以上面的示例代码为例，如果这段代码写在Activity中，构造的Response.Listener的匿名内部类存在当前Activity的隐式引用，很容易引起不必要的内存泄露。如果这段代码不在Activity中，那还要多一层数据的轮转机制。简直是开发者的噩梦。 针对失败的回调处理并不科学。在实际的业务开发中，你可能需要针对某几类返回数据做异常处理，虽然他们整个Http请求的网络过程是正常的，但是针对这些返回的结果把它看成异常流。如果希望Volley在这一点达到你的要求你还需要多一层封装。 2.2 使用okhttp发送Http post请求的示例代码： 123456789101112131415161718192021222324252627282930//创建网络处理的对象OkHttpClient client = new OkHttpClient.Builder() .readTimeout(5, TimeUnit.SECONDS) .build();//post请求来获得数据//创建一个RequestBody，存放重要数据的键值对RequestBody body = new FormBody.Builder() .add(&quot;showapi_appid&quot;, &quot;13074&quot;) .add(&quot;showapi_sign&quot;, &quot;ea5b4bf2e140498bb772d1bf2a51a7a0&quot;).build();//创建一个请求对象，传入URL地址和相关数据的键值对的对象Request request = new Request.Builder() .url(&quot;http://route.showapi.com/341-3&quot;) .post(body).build();//创建一个能处理请求数据的操作类Call call = client.newCall(request);//使用异步任务的模式请求数据call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.e(“TAG”,&quot;错误信息：&quot; + e.toString()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.e(“TAG”,response.body().string()); &#125;&#125;); 相比较volley，okhttp在请求api的设计上更合理些。okhttp使用RequestBuilder和BodyBuilder构造网络请求，并且隐藏了网络框架的内部实现，让请求的过程更简单优雅。但在接收请求结果上依然选择Callback监听的方式。 0x03 设计者如何面对3.1 请求需求与请求协议目前android平台上主流的网络请求都是基于OkHttp框架的，okhttp框架针对http协议进行了封装和优化，支持http&#x2F;2协议，共享连接池的设计有利于提高请求效率，拦截器的设计支持监视、重写、和重试等特殊业务场景的需求。极大地降低了开发者的使用成本，同时兼备稳定性和可扩展性。所以我们在分析volley和okhttp在实际业务中的不足和优势，选择使用okhttp进行网络请求和连接，在其基础上进行业务封装，力求设计出尽可能的符合自身业务需求和场景的网络框架。具体使用设计需求如下： 尽可能优雅的方式构造一个网络请求，不管他是get、post还是其他请求方法，也不管请求参数格式是form还是json。在构造Request方式上力求简单统一。 尽可能简单的方式获取请求结果，最好不要再用Callback的方式接收回调数据。 支持多种不同的请求结果类型，不管是String还是JSON，不管是Java对象还是文件，都能简单的获取。 对失败的异常处理要更符合自身业务场景，并不是网络连接错误才会触发请求失败的接口 结合以上几点对网络框架的期望，所以诞生了以下实例的API： 1234567891011121314151617181920212223242526@Testpublic void getMethodTest() &#123; TestLog.d(&quot;get url:&quot; + getUrl(PATH_GET)); BasicRequest request = RequestBuilder.obtain().get() .setUrl(getUrl(PATH_GET)) .addParam(&quot;shopIds&quot;, 123445) .into(this, &quot;getMethod&quot;, 1, 1L, (short) 1, false, 1D, 1f) .buildJsonRequest(ShopInfo.class); request.send();&#125;@Keep@NetworkCallback(name = &quot;getMethod;getMethod2&quot;, type = ResponseType.SUCCESS)private void onGetMethodSuccess(ShopInfo info, int h, long h1, short h2, boolean h3, double h4 , float h5) &#123; TestLog.d(&quot;++++++++get method success:&quot; + info.toString());&#125;@Keep@NetworkCallback(name = &quot;getMethod&quot;, type = ResponseType.FAILED)private void onGetMethodFailed(CommonError error, int h, long h1, short h2, boolean h3, double h4, float h5) &#123; TestLog.d(&quot;++++++++get method failed:&quot; + error.toString());&#125; API说明： RequestBuilder.obtain从对象池中返回复用的Request对象 .get() .postJson() .postFormEncode() postStream(Binary binary)等方法封装了常见的get与post请求并指定了不同的body格式 使用addParam(key, value)方法添加请求参数，这里并不因为请求方法的不同而存在api上的差异 使用注解标记接收网络请求结果回调的方法。如上例中，onGetMethodSuccess()和 onGetMethodFailed()方便被NetworkCallback注解标记，并且通过BasicRequest.into(this, &quot;getMethod&quot;, 1, 1L, (short) 1, false, 1D, 1f)绑定了请求与回调方法之间的关系。其中into的方法参数一次为：包含改回调方法的对象，注解的名称，以及Callback方法需要的其他额外参数。 buildJsonRequest将返回结果自动转换成ShopInfo对象。 3.2 缓存Http缓存策略是一个相对复杂的问题，大致分为以下三个方面： 3.2.1 缓存存储策略决定Http的相应内容是否可缓存在客户端。Http响应头中的Cache-Control字段，分为Public、Private、no-cache、max-age 、no-store5种类型。其中前4个都会缓存文件数据（关于 no-cache 应理解为“不建议使用本地缓存”，其仍然会缓存数据到本地），后者 no-store 则不会在客户端缓存任何响应数据。 3.2.2 缓存过期策略决定客户端是否可直接从本地缓存数据中加载数据并展示，否则就发请求到服务端获取。Http响应头中的Expires字段指明了缓存数据有效的绝对时间，告诉客户端到了这个时间点后该本地缓存就该作废了。这里的作废是指客户端不能直接再从本地读取缓存，需要再发一次请求到服务端去确认。确认下这个缓存还有没有用。这个过程就要说到下面的缓存对比策略。 3.2.3 缓存对比策略决定客户端本地的缓存数据是否仍然有效。客户端检测到数据过期或浏览器刷新后，往往会重新发起一个 http 请求到服务器，服务器此时并不急于返回数据，而是看请求头有没有带标识（ If-Modified-Since、If-None-Match）过来，如果判断标识仍然有效，则返回304告诉客户端取本地缓存数据来用即可（这里要注意的是你必须要在首次响应时输出相应的头信息（Last-Modified、ETags）到客户端）。 根据上述的三种缓存策略，这里贴出客户端对http缓存控制的关键代码: 12345678910111213141516171819202122232425262728293031323334/** * 先检查是否有未过期缓存 */CacheControl cacheControl = cacheKey.getCacheControl();if (cacheControl != null &amp;&amp; cacheControl.shouldCache()) &#123; cacheEntry = mCacheManager.get(cacheKey); // TestLog.d(&quot;缓存=====cache entry:&quot; + cacheEntry);&#125;/** * 如果存在缓存数据，检查是否过期 */if (cacheEntry != null) &#123; boolean isExpired = cacheEntry.isExpired(); if (!isExpired) &#123; // 没有过期，delivery缓存信息 Headers headers = CacheExecutor.getResponseHeaders(cacheEntry); byte[] body = CacheExecutor.getResponseBody(cacheEntry); Object result = performParseResponse(requestEvent, headers, body); response = BasicResponse.success(result); return; &#125; else &#123; // 过期，检查是否有Etag和Last-Modified信息 if (!TextUtils.isEmpty(cacheEntry.etag)) &#123; requestHeaders.set(&quot;If-None-Match&quot;, cacheEntry.etag); &#125; if (cacheEntry.lastModified &gt; 0) &#123; requestHeaders.set(&quot;If-Modified-Since&quot;, DateUtils.formatMillisToGMT(cacheEntry.lastModified)); &#125; &#125;&#125; 如何确定缓存时间的关键流程： 3.3 JSON转换与错误处理首先需要定义一个CommonResponse，所有的JSON格式的Response都继承它。按照服务端低响应状态的约定，当status为false时表示请求结果失败，这里说的失败指的是无法返回客户端预期的正确业务结果。 1234567891011121314public class CommonResponse implements Serializable &#123; /** * 状态码 */ private boolean status; /** * 描述 */ private String message; /** * 响应码 */ private String responseCode;&#125; 当网络出现异常导致的连接失败时，或者当服务端返回的数据无法正常序列化为指定的类的实例时，或者CommonResponse的status变量为false时，网络框架都会抛出一个可被自动捕获的Throwable，并将返回值和错误类型回调到标记为@NetworkCallback(type = ResponseType.FAILED)的对应方法中。 0x04 总结因为篇幅的原因，暂时只针对上述的几个方面较的阐述了一个网络框架的设计思路，还包括但不仅限于下面的这些讨论方向，有机会再详聊！如： 线程的切换对响应数据完整性的校验Zip文件的请求与自动解压缩，bspatch算法的增量文件请求并根据增量文件自动生成全量文件等网络模块与缓存模块的解耦设计网络性能的监控httpDNS方案的应用cookie的管理(可参考github开源项目nohttp项目的设计) 在实际的业务开发过程中，针对上述问题的设计和封装已经能够覆盖大部分复杂的业务场景。相信一定能让一个开发人员写出赏心悦目自嗨的代码了。 0x05 参考文档https://tech.youzan.com/android_http/ https://mp.weixin.qq.com/s/qOMO0LIdA47j3RjhbCWUEQ https://www.cnblogs.com/chenqf/p/6386163.html http://blog.csdn.net/yaofeiNO1/article/details/54428021 http://blog.csdn.net/qmickecs/article/details/73696954 http://blog.csdn.net/qmickecs/article/details/73822619 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"方案与设计","slug":"方案与设计","permalink":"https://ivonhoe.github.io/categories/%E6%96%B9%E6%A1%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://ivonhoe.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"移动端无痕埋点实践详解(一)","slug":"how-to-track-users","date":"2018-07-03T09:53:56.000Z","updated":"2022-05-25T16:58:42.176Z","comments":true,"path":"2018/07/03/how-to-track-users/","link":"","permalink":"https://ivonhoe.github.io/2018/07/03/how-to-track-users/","excerpt":"用户数据埋点的一般解决思路是使用代码手动埋点。国内主要的第三方数据分析服务商，如百度统计、友盟、TalkingData等都提供这一方案。但是使用代码手动埋点的方式，投入资源大，往往很难能够有实际产出。其中一个很重要的原因其实是在分析实际业务数据之前，很难知道我真正想看什么样的数据。用代码手动的埋点方案经常会导致一个尴尬的解决，想要看的数据没有埋，埋了的数据不准。用户数据埋点是少见的涉及到一个产品研发团队所有角色的项目。从运营的数据需求，到产品经理的抽象和规范，到移动端前端的手动采集数据，再到服务端和大数据的存储和转换，最终把结果反馈给运营和产品经理。埋点的实际产出涉及到几乎所有部门，如果按照链式的工作流来解决埋点问题，当任何一个环节出现问题，都会对整个项目结果的产出产生影响。这篇文章记录了无痕埋点方案的思路与其核心问题的解决方案。","text":"用户数据埋点的一般解决思路是使用代码手动埋点。国内主要的第三方数据分析服务商，如百度统计、友盟、TalkingData等都提供这一方案。但是使用代码手动埋点的方式，投入资源大，往往很难能够有实际产出。其中一个很重要的原因其实是在分析实际业务数据之前，很难知道我真正想看什么样的数据。用代码手动的埋点方案经常会导致一个尴尬的解决，想要看的数据没有埋，埋了的数据不准。用户数据埋点是少见的涉及到一个产品研发团队所有角色的项目。从运营的数据需求，到产品经理的抽象和规范，到移动端前端的手动采集数据，再到服务端和大数据的存储和转换，最终把结果反馈给运营和产品经理。埋点的实际产出涉及到几乎所有部门，如果按照链式的工作流来解决埋点问题，当任何一个环节出现问题，都会对整个项目结果的产出产生影响。这篇文章记录了无痕埋点方案的思路与其核心问题的解决方案。 0x01 什么是无痕埋点？所谓的”无痕埋点”，其实就是通过技术手段，无差别的记录用户在产品中的行为，当有一天突然想对某一个控件做点击分析时，不再需要开发手动添加数据采集信息。因为从部署埋点方案的时候，就一直在收集所有的用户的数据了。用户的数据并不是分析需求产生的那一刻才有的。无痕埋点在无差别的记录用户所有行为，而实际的埋点结果产出取决于BI工程师对无痕埋点数据的清洗。 从技术角度总结以往埋点项目结果产出困难的原因，这些也是无痕埋点方案想要解决的核心问题。 通过代码手动埋点比较原始，出错概率较高。 埋点链路较长，出现错埋漏埋需要重新发布 埋点数据准确性无法校验 所以，在项目上使用无痕埋点来解决项目链路过长的问题的方法是将埋点数据的产生过程分成两个并行的部分。将数据的采集过程前置，不再依赖运营和产品经理的需求产出。现有全量用户数据，再由运营和产品分析数据产出结果。 0x02 移动端无痕埋点如何实现？移动端埋点的方案以在Android系统上实现为例，关键在于解决2个问题： 如何统一标识控件 统一拦截用户操作行为。这里说的用户操作主要还是用户的单击事件。 2.1 如何标识控件为了自动生成事件标识，我们需要获取每个控件自身的ID、类名以及位于所属父组件的Index等特征信息，并逐级向上遍历找到根节点。约定控件标识的生成规则为 /root/ClassName:id/ClassName:id，以某一个业务界面的扫一扫按钮为例，寻找它到root节点的控件路径，它的控件标识字符串应该是 /root/RelativeLayout:-1/FrameLayout:1997209645/RelativeLayout:-1/RelativeLayout:1997209836/LinearLayout:1997209965/TextView:1997209967，并通过md5算法将这个标识字符串生成为XPATH就是我们想要的控件标识。当后台上报数据中包含1e3cdc9499fac8088220756a46c85599的点击时。我们就认为是扫一扫控件被点击了。 2.2 如何统一拦截单击事件还是以Android端上的实现为例，如何统一拦截用户的单击事件呢？先看如何实现一个单击操作的响应，在Android上一般的做法是针对View设置一个单击的监听。 1234567891011/** * Interface definition for a callback to be invoked when a view is clicked. */public interface OnClickListener &#123; /** * Called when a view has been clicked. * * @param v The view that was clicked. */ void onClick(View v);&#125; 那么有没有办法统一把所有的单击事件都替换掉呢？在运行时！业务开发的工程师还是按照原生Android系统的api实现对单击事件的响应，埋点SDK在运行时统一替换所有的View.OnClickListener，将其替换成原有View.OnClickListener的包装。当执行AutoTraceListenerWrapper的时候实际执行的还是原有Listener的单击事件，同时又能统一拦截所有的单击事件。 1234567891011121314151617public class AutoTraceListenerWrapper implements View.OnClickListener &#123; private View.OnClickListener mClickListener; public AutoTraceListenerWrapper(View.OnClickListener listener) &#123; mClickListener = listener; &#125; @Override public void onClick(View view) &#123; onViewClick(view); if (mClickListener != null) &#123; mClickListener.onClick(view); &#125; &#125;&#125; 那么如何统一替换所有的View的单击监听呢？只需要遍历安卓视图结构的View Tree，使用反射机制替换掉所有的原生OnClickListener就可以了。 0x03 总结埋点问题是不能通过一个方案适配所有业务场景的，不同的场景下需要选择不同的埋点方案。无痕埋点方案针对的是用户的简单用户行为事件，比如如何规范采集用户的点击事件。例如针对页面跳转的事件统计还是需要你单独埋点。埋点数据能不能最终完美的呈现依赖的不单单是技术方案，还有更多的是数据规范的问题。例如在面对运行时才能获知的业务信息时，如何使用埋点技术将需要的业务信息做统一的上报，是另一个重要的关键点。例如在做数据清洗时如何建立规范的数据中间表？无痕埋点只是获取完整埋点数据的第一步。 移动端无痕埋点实践详解(二) 0x04 参考文档美团点评前端无痕埋点实践 数据采集与埋点简介之 代码埋点、可视化埋点与无痕埋点 0x05 转载请标明出处病已blog https://ivonhoe.github.io/转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"方案与设计","slug":"方案与设计","permalink":"https://ivonhoe.github.io/categories/%E6%96%B9%E6%A1%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"无痕埋点","slug":"无痕埋点","permalink":"https://ivonhoe.github.io/tags/%E6%97%A0%E7%97%95%E5%9F%8B%E7%82%B9/"}]},{"title":"Android NDK编译错误解决","slug":"ndk17-build-error","date":"2018-06-05T13:10:54.000Z","updated":"2022-03-27T13:49:50.363Z","comments":true,"path":"2018/06/05/ndk17-build-error/","link":"","permalink":"https://ivonhoe.github.io/2018/06/05/ndk17-build-error/","excerpt":"0x01 问题描述现象： 将ndk版本升级到 17.0.4754217编译报错 123456* What went wrong:Execution failed for task &#x27;:app+stub:transformNativeLibsWithStripDebugSymbolForRelease&#x27;.&gt; A problem occurred starting process &#x27;command &#x27;/Users/Ivonhoe/Library/Android/sdk/ndk-bundle/toolchains/mips64el-linux-android-4.9/prebuilt/darwin-x86_64/bin/mips64el-linux-android-strip&#x27;&#x27;* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. 123456Caused by: java.io.IOException: Cannot run program &quot;/Users/Ivonhoe/Library/Android/sdk/ndk-bundle/toolchains/mips64el-linux-android-4.9/prebuilt/darwin-x86_64/bin/mips64el-linux-android-strip&quot; (in directory &quot;/Users/Ivonhoe/Workspace/keyaccount-repo/app+stub&quot;): error=2, No such file or directory at net.rubygrapefruit.platform.internal.DefaultProcessLauncher.start(DefaultProcessLauncher.java:25) ... 4 moreCaused by: java.io.IOException: error=2, No such file or directory ... 5 more","text":"0x01 问题描述现象： 将ndk版本升级到 17.0.4754217编译报错 123456* What went wrong:Execution failed for task &#x27;:app+stub:transformNativeLibsWithStripDebugSymbolForRelease&#x27;.&gt; A problem occurred starting process &#x27;command &#x27;/Users/Ivonhoe/Library/Android/sdk/ndk-bundle/toolchains/mips64el-linux-android-4.9/prebuilt/darwin-x86_64/bin/mips64el-linux-android-strip&#x27;&#x27;* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. 123456Caused by: java.io.IOException: Cannot run program &quot;/Users/Ivonhoe/Library/Android/sdk/ndk-bundle/toolchains/mips64el-linux-android-4.9/prebuilt/darwin-x86_64/bin/mips64el-linux-android-strip&quot; (in directory &quot;/Users/Ivonhoe/Workspace/keyaccount-repo/app+stub&quot;): error=2, No such file or directory at net.rubygrapefruit.platform.internal.DefaultProcessLauncher.start(DefaultProcessLauncher.java:25) ... 4 moreCaused by: java.io.IOException: error=2, No such file or directory ... 5 more 原因： 升级android ndk版本到17时未同时升级gradle编译工具到3.0.0以上，低版本的编译工具会执行mips64的脚本。而mips64的脚本在ndk17上已经被删除了！ 123This mipsel-linux-android-4.9 directory exists to make the NDK compatible with the AndroidSDK&#x27;s Gradle plugin, version 3.0.1 and earlier, which expects the NDKto have a MIPS toolchain directory. 解决方案：一种解决办法是同时升级gradle编译工具的版本。但是因为项目的原因，无法使用最新版本的gradle编译工具，只能使用2.3.0版本的编译工具，所以使用一个绕过问题的方法，在/Users/Ivonhoe/Library/Android/sdk/ndk-bundle/toolchains/mips64el-linux-android-4.9/prebuilt/darwin-x86_64/bin/目录创建一个mips64el-linux-android-strip的空文件。记得使用chmod 命令修改空文件的执行权限。 0x03 参考文档：React Native apps fail to build since NDK update to r17 (due to missing mipsel-linux-android-4.9 toolchain files) 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"学习总结","slug":"学习总结","permalink":"https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"ndk","slug":"ndk","permalink":"https://ivonhoe.github.io/tags/ndk/"}]},{"title":"深入浅出JVM垃圾回收算法","slug":"jvm-gc-1","date":"2018-06-03T14:43:32.000Z","updated":"2022-05-25T17:00:01.355Z","comments":true,"path":"2018/06/03/jvm-gc-1/","link":"","permalink":"https://ivonhoe.github.io/2018/06/03/jvm-gc-1/","excerpt":"在学习JVM如何进行垃圾回收方法时，发现所谓的JVM垃圾回收思想和现实生活的场景有很多相似的地方。所以用餐厅回收餐桌的方式类比JVM垃圾回收算法，应该能帮助JVM学习的理解和记忆。","text":"在学习JVM如何进行垃圾回收方法时，发现所谓的JVM垃圾回收思想和现实生活的场景有很多相似的地方。所以用餐厅回收餐桌的方式类比JVM垃圾回收算法，应该能帮助JVM学习的理解和记忆。 0x01 经典垃圾回收算法 标记-清除（Mark-Sweep） 研发园开了家新餐厅，餐厅老板在考虑如何回收餐盘时先使用了最简单的方式，那就是服务员在顾客用餐的过程中，不定时的观察餐厅，针对用完餐的顾客记录他们的位置（当然一般的服务员的脑海中自行处理），统一回收他们的餐具和餐盘。这种回收方式会有一个明显的问题，那就是回收后的餐厅座位，很有可能是不连续的。如果后续有同行的顾客想坐在一起，那很可能找不到连续的座位。 复制算法（Copying） 为了解决餐厅座位碎片化的问题，餐厅的老板提出了一个大胆的想法，这是一个很会思考的老板。把餐厅的用餐区域分成两部分A厅和B厅，当对A厅中的餐桌做回收时，将A厅中还未用完餐的顾客，‘请’到B厅去用餐，并且让这些顾客在B厅中拼桌用餐（为了餐位连续）。这样所有A厅中的位置都空余出来了，并且B厅中的用餐区域和未用餐区域都是连续的！简直是强迫症晚期。看似完美的解决了回收后餐位碎片化的问题。但是依然带来了其他的一些问题。 缺点： 餐厅的运营区域是一个整体，现在只能同时对外开放A厅，运营空间变小了。 当有很多顾客需要从A厅转移到B厅时，效率太低。 用餐体验很差 优点： 不容易产生碎片 标记-整理算法（Mark-Compact） 当实行复制算法解决餐位回收的问题后，餐厅的老板针对新问题又有了新想法，只要移动顾客就可以解决碎片化问题，为啥我要将餐厅分成两个部分呢？毕竟那样不能最大效率的利用餐厅的用餐区域。创造性的提出了标记-整理算法，结合前面两中方法的优缺点，当餐厅准备回收餐位时，移动所有未用晚餐的顾客，并且让从餐厅的第一桌开始拼桌。保证后面的餐桌都是回收的并且座位都是连续的。这样既提高了餐厅餐桌的利用率又保证了当有大量组团顾客进店用餐时，餐厅能够提供大量的连续餐桌。 0x02 分代收集（Generational Collection）如果还是用开餐厅的方式来思考JVM的话，可以把分代回收看做餐厅针对不同顾客的等级推出的个性化服务。分代收集算法并没有新的思想，只是根据对象存活周期的不同将内存划分为几块，一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，大量的对象都是’朝生夕死‘，每次垃圾回收是，都可以发现大量对象死去，所以针对新生代的垃圾回收一般选择复制算法。只需要复制少量存活对象就可以完成收集。针对老年代的垃圾回收，对象的存活时间较长，就必须使用’标记-清除‘或者’标记-整理‘算法来进行回收。 在新生代中，绝大多数的对象都是’朝生夕死‘的，新生代并不需要按照1：1的比例划分内存空间，而是将内存分为一个较大的Eden空间和一个较小的Survivor空间，并将Survivor空间分成两个较小空间，分别是From Space和ToSpace。每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中。Hotspot虚拟机默认Eden和Survivor的大小比例是8：1，也就是每次新生代可用内存空间为整个新生代容量的90%。 这里很显然会有一个问题，理论上每次新生代GC都会回收绝大多数的对象，但是无法保证GC存活后的对象大学都不超过整个新生代的10%。当Survivor空间的内存不够用是，就需要老年代做内存担保。同样用餐厅的理论来理解，你希望把A厅的顾客转移到B厅，但是B厅已经没有足够空间容纳所有顾客了，这时候可以选择将顾客安置在VIP包厢【老年代】。并且每次在新生代GC中存活的对象，其年龄就会+1，默认情况下年龄达到15的对象会被转移到老年代。这里也很好理解，餐厅的忠实吃货为啥不给办张VIP卡呢？ 参考文档《深入理解Java虚拟机》周志明 著 Java基础：JVM垃圾回收算法 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"学习总结","slug":"学习总结","permalink":"https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://ivonhoe.github.io/tags/JVM/"}]},{"title":"拒绝单例模式","slug":"design-patterns-singleton","date":"2018-05-27T14:23:37.000Z","updated":"2022-05-25T16:55:49.088Z","comments":true,"path":"2018/05/27/design-patterns-singleton/","link":"","permalink":"https://ivonhoe.github.io/2018/05/27/design-patterns-singleton/","excerpt":"相信很多同学在学习设计模式的过程中，最先了解的就是单例模式，至少我是这样。单例模式看似简单容易理解，实际上却有很多坑，正因为这样也成为了很多公司面试必考的面试题。实际使用单例模式时，难免会遇到滥用的情况，理解单例更要学会何时拒绝单例。","text":"相信很多同学在学习设计模式的过程中，最先了解的就是单例模式，至少我是这样。单例模式看似简单容易理解，实际上却有很多坑，正因为这样也成为了很多公司面试必考的面试题。实际使用单例模式时，难免会遇到滥用的情况，理解单例更要学会何时拒绝单例。 0x01单例模式的基础知识1. 单例的几种写法? 懒汉式: 懒加载模式，需要的时候才创建实例。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。需要考虑线程安全问题。 饿汉式：单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。 静态内部类：JVM本身机制保证了线程安全问题，由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。 2. 为什么要双重检验锁?12345678910public static Singleton getSingleton() &#123; if (instance == null) &#123; //Single Checked synchronized (Singleton.class) &#123; if (instance == null) &#123; //Double Checked instance = new Singleton(); &#125; &#125; &#125; return instance ;&#125; 第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。 不然，我们就开始同步线程。 第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。 3. 重排序问题1instance = new Singleton() 这并不是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。 给 instance 分配内存 调用 Singleton 的构造函数来初始化成员变量 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。对此，我们只需要把singleton声明成 volatile 就可以了。 0x02 滥用单例带来哪些问题？你的项目中可能会有一堆的Manager或者Controller，最简单获取方法是把他们设计成一个个单例，只需要通过一个getInstance的方法获取到他的唯一实例对象，在任何代码中的任何地方，甚至不需要上下文。是否思考过下面的这些问题？ 1.你的单例会有应用的生命周期吗？ 按照单例的定义，无法构建除该单例以外的实例，并且这个单例有一个静态引用，单例不会被虚拟机垃圾回收。单例对象一旦创建，对象的引用是保存在静态区，单例对象在堆上分配的内存空间只有在程序终止后才会释放，过多的单例必然增大内存的消耗，并且如果你的单例中的上下文引用了不当，可能会造成严重的内存泄露问题。单例的设计应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该用单例来管理。 2.如何尽可能的减少依赖【耦合】？ 有依赖就有耦合，如果你的单例提供的是某一个特定功能的公共方法或状态。那调用方和被调用方就会因为单例的设计建立了强耦合关系。甚至更极端的情况中，包含了多个单例之间的相互依赖甚至循环依赖关系。那你永远不可能将各种角色模块化拆分出来。 3.如果你想针对你的单例做扩展或升级怎么办? 对单例的实现升级其实并不是单例模式要解决的问题，但是单例模式缺少抽象，在使用过程中必然会遇到这样的问题。在业务的发展过程中，一定会遇到需要对已有单例进行实现升级的情况，比如你需要对相同功能换一种方式实现？或者需要增加删除一个方法或接口？甚至可能变成一个完全不一样的功能。这时候的单例就会遇到一些问题，你不单单需要修改单例，你还需要修改依赖单例的上层业务代码。 0x03如何尽可能少的使用单例模式？单例的好处是简单易用，单例模式在系统设置了全局的访问点，优化和共享资源的访问。但是滥用单例也带来的上述的三个方面的危害，无法统一管理对象的生命周期、增加耦合、针对实现编程而不是针对接口编程。如何享受单例模式带来的好处并且解决她带来的危害在于，如何通过一种解耦的方式全局获取一个单例对象，并且这个单例对象的生命周期是可管理的，并且这个单例对象是针对接口的抽象实现。 针对接口实现：单例不再提供getInstance方法，并且根据不同的抽象接口实现 提供全局的访问点: 调用方可以通过全局的SingleManager获取实现接口的具体实例 可管理的对象生命周期: 所有的单例的唯一对象都由SingleManager管理 低耦合的：为了避免循环引用问题，SingletonManager在运行时根据配置文件通过反射的方式实例化每个接口的具体实现类，调用方只依赖SingletonManager，并且通过SingletonManager获取接口的实现实例 0x04 参考文档深入浅出单实例SINGLETON设计模式 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"方案与设计","slug":"方案与设计","permalink":"https://ivonhoe.github.io/categories/%E6%96%B9%E6%A1%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://ivonhoe.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"HTTPS","slug":"https","date":"2018-05-21T13:55:38.000Z","updated":"2022-05-25T17:00:25.187Z","comments":true,"path":"2018/05/21/https/","link":"","permalink":"https://ivonhoe.github.io/2018/05/21/https/","excerpt":"https为什么安全？因为相对http的明文传输，https引入了数据加密和身份认证。服务器和客户端的消息只有服务器和客户端能够读懂，保证了数据的保密性。同时在交换数据之前，验证了对方的合法身份，保证了通信双方的安全。这篇总结主要记录了在理解https安全性的过程中遇到的问题。","text":"https为什么安全？因为相对http的明文传输，https引入了数据加密和身份认证。服务器和客户端的消息只有服务器和客户端能够读懂，保证了数据的保密性。同时在交换数据之前，验证了对方的合法身份，保证了通信双方的安全。这篇总结主要记录了在理解https安全性的过程中遇到的问题。 0x01 什么是对称加密和非对称加密在https的协议中如何实现数据加密和身份认证呢？简单来说是客户端先获取非对称加密的公钥，通过公钥和服务器协商生成对称加密的对称密钥，并使用对称密钥加密传输数据。 1.1 对称加密什么是对称加密：加密和解密使用相同密钥的算法。它要求发送方和接收方在安全通信之前，商定一个对称密钥。对称算法的安全性完全依赖于密钥，密钥泄漏就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。 特点：计算量小、加密速度快、加密效率高。交易双方都使用同样密钥，安全性得不到保证。每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信息双方所拥有的钥匙数量呈几何级数增长，密钥管理成为负担。 代表算法： DES、AES 1.2 非对称加密什么是非对称加密： 需要两个密钥来进行加密和解密。分别是公开密钥和私有密钥。如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 特点： CPU计算资源消耗非常大，效率较低。非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是2048位，意味着待加密内容不能超过256个字节。 代表算法： RSA 0x02 中间人劫持如果在通信过程中，客户端的请求被中间人劫持，那么中间人可以就可伪装成“冒牌客户端”和服务器通信，同时伪装成“冒牌服务器”与客户端通信。从而达到获取客户端服务端通信内容的目的！主要过程如下： 中间人在服务器发送公钥之前劫持客户端请求，伪造客户端向服务端发起SSL握手 中间人获取服务端加密公钥，伪造出一个自己的公钥发送给客户端 客户端接受到伪造的公钥，使用伪造的公钥发送对称密钥 中间人劫持到对称密钥，并利用自己的私钥解密出对称密钥 利用步骤2中的正确服务器加密公钥，加密客户端对称密钥发送给服务 客户端和服务器使用被中间人破解的对称密钥传输数据，中间人可以获取所有传输信息 2.1 数字签名数字签名过程： 服务端把一个报文经过HASH处理生成消息摘要信息Digest，使用私钥加密摘要信息生成签名信息。 将报文、签名发生给客户端 客户端使用相同的HASH算法对报文做相同的HASH处理，获取摘要Digest1 客户端使用公钥解密签名生成摘要Digest2，并且对比Digest1和Digest2是否一致 如果Digest1和Digest2一致说明报文没有被篡改过，这份报文和签名是对应的，具有不可抵赖性。 2.2 数字证书解决中间人劫持问题的关键在于，客户端如何能够分辨出接收到的公钥确实是服务端的呢？这时候就需要数字证书了。 数字证书是公司向一个证书发布机构”SecureTrust CA”申请的。这个证书发布机构”SecureTrust CA”是一个大家公认并被一些权威机构接受的证书发布机构，并且我们的操作系统里面已经安装了”SecureTrust CA”的证书。”SecureTrust CA”在给我们发布证书时，把Issuer,Public key,Subject,Valid from,Valid to等信息以明文的形式写到证书里面，然后用一个摘要算法计算出这些数字证书内容的一个Digest，并使用CA自己的私钥对Digest进行加密，生成证书的数字签名。 验证公钥过程： 服务端将证书发送给客户端，这里不是公钥 客户端提取证书中的发布机构(Issuer)为”SecureTrust CA”，在操作系统中受信任的发布机构的证书中去找”SecureTrust CA”的证书，如果查不到说明证书有问题。 如果找到了”SecureTrust CA”的证书，客户端从系统的证书中提取”SecureTrust CA”的公钥， 使用CA公钥对步骤1中获取到证书中的签名信息的进行解密获取解密摘要，并使用摘要算法计算证书的摘要 对比解密摘要和计算出的摘要信息是否一致。如果一致说明认证成功，当前证书中包含的公钥信息是可以信认的。 数字证书中包含公钥和证书所有者信息，并且保证数字证书里的公钥确实是这个证书的所有者的，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。 0x03 总结数字签名：为了说明谁编写的报文，同时证明报文未被篡改过。 数字证书：由权威的认证机构证明公钥的正确性。 0x04 参考文档HTTPS为什么安全 &amp;分析 HTTPS 连接建立全过程 一个故事教你看懂什么是数字证书，它的原理是什么?它的作用是什么？ 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"学习总结","slug":"学习总结","permalink":"https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://ivonhoe.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"对称加密","slug":"对称加密","permalink":"https://ivonhoe.github.io/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"},{"name":"非对称加密","slug":"非对称加密","permalink":"https://ivonhoe.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"},{"name":"数字签名，数字证书","slug":"数字签名，数字证书","permalink":"https://ivonhoe.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%EF%BC%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"}]},{"title":"Android插件化之资源加载机制","slug":"small-bug-555-fix","date":"2018-03-14T09:23:27.000Z","updated":"2022-05-25T17:00:56.219Z","comments":true,"path":"2018/03/14/small-bug-555-fix/","link":"","permalink":"https://ivonhoe.github.io/2018/03/14/small-bug-555-fix/","excerpt":"这篇文章主要记录了在使用Small插件化框架中遇到的资源加载问题及相应解决方案，并梳理出Android的资源加载流程和插件化框架的资源加载原理。在前两篇插件化技术介绍的基础上会关注更多技术细节，希望能有所收获！","text":"这篇文章主要记录了在使用Small插件化框架中遇到的资源加载问题及相应解决方案，并梳理出Android的资源加载流程和插件化框架的资源加载原理。在前两篇插件化技术介绍的基础上会关注更多技术细节，希望能有所收获！ 关于Small插件化的其他文档：《Android插件化之Small框架实践总结》《Android插件化之Small框架原理》《Android插件化之从入门到放弃》 0x01 Small框架的资源加载异常最近收到一个客户反馈，在他们的中兴V0840手机上打开我们的app会持续崩溃。第一时间在百度移动质量平台上短时租用了该机型，抓取了log。发现是资源查找失败异常。并在Small github issues中搜索android.content.res.Resources$NotFoundException 可以发现很多类似的问题，详细日志可查看下图。 Github issus链接：#555 Small Sample项目打包后在ZTE上闪退 项目崩溃日志： 1234567891011121314151617181920212223242526272829303103-06 17:48:31.685 E/AndroidRuntime( 8189): FATAL EXCEPTION: main03-06 17:48:31.685 E/AndroidRuntime( 8189): Process: com.shandiangou.kaguanjia, PID: 818903-06 17:48:31.685 E/AndroidRuntime( 8189): java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.shandiangou.kaguanjia/com.shandiangou.kaguanjia.app.main.activity.GuideActivity&#125;: android.content.res.Resources$NotFoundException: Resource ID #0x2a03001003-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2669)03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2730)03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.ActivityThread.-wrap12(ActivityThread.java)03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1481)03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.os.Handler.dispatchMessage(Handler.java:102)03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.os.Looper.loop(Looper.java:154)03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.ActivityThread.main(ActivityThread.java:6144)03-06 17:48:31.685 E/AndroidRuntime( 8189): at java.lang.reflect.Method.invoke(Native Method)03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:886)03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:776)03-06 17:48:31.685 E/AndroidRuntime( 8189): Caused by: android.content.res.Resources$NotFoundException: Resource ID #0x2a03001003-06 17:48:31.685 E/AndroidRuntime( 8189): at android.content.res.ResourcesImpl.getValue(ResourcesImpl.java:196)03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.content.res.Resources.loadXmlResourceParser(Resources.java:2101)03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.content.res.Resources.getLayout(Resources.java:1115)03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.view.LayoutInflater.inflate(LayoutInflater.java:424)03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.view.LayoutInflater.inflate(LayoutInflater.java:377)03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.shandiangou.kaguanjia.common.base.CustomProgressDialog.init(CustomProgressDialog.java:38)03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.shandiangou.kaguanjia.common.base.CustomProgressDialog.&lt;init&gt;(CustomProgressDialog.java:26)03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.shandiangou.kaguanjia.common.base.BaseActivity.initProgressDialog(BaseActivity.java:27)03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.shandiangou.kaguanjia.common.base.BaseActivity.onCreate(BaseActivity.java:22)03-06 17:48:31.685 E/AndroidRuntime( 8189): at com.shandiangou.kaguanjia.app.main.activity.GuideActivity.onCreate(GuideActivity.java:45)03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.Activity.performCreate(Activity.java:6722)03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1119)03-06 17:48:31.685 E/AndroidRuntime( 8189): at net.wequick.small.ApkBundleLauncher$InstrumentationWrapper.callActivityOnCreate(ApkBundleLauncher.java:334)03-06 17:48:31.685 E/AndroidRuntime( 8189): at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2622)03-06 17:48:31.685 E/AndroidRuntime( 8189): ... 9 more03-06 17:48:31.688 W/ActivityManager( 1384): Force finishing activity com.shandiangou.kaguanjia/net.wequick.small.A Small框架官方Sample崩溃日志 0x02 Android资源加载流程Android源码Resources创建流程图： ActivityThread在接收到LAUNCH_ACTIVITY消息以后，在 performLaunchActivity 方法中，使用Instrumentation通过反射的方式创建Activity实例，再创建Activity的Base Context, 并在创建Context过程中实例化AssetManger和Resources。ActivityThread在LAUNCH_ACTIVITY消息中，完成了Activity生命周期中的三个回调，分别是onCreate onStart onRestoreInstanceState。 Android中资源管理类在不同sdk版本中的关系如下图所示。 0x03 Small框架插件资源加载方案Small框架的资源加载流程在ApkBundleLauncher中完成，setup流程获取到所有插件so的信息，在postSetUp中获取所有插件包的资源路径，通过反射调用AssetManager的addAssetPaths方法，构造一个包含宿主包资源、系统资源和插件包资源的AssetManger。最后还是通过反射，使用包含所有资源的AssetManager替换掉ResourcesManager中Resources的AssetManger，最终达到加载插件中资源的目的。 Small框架资源加载流程: 0x04 bug修复方案看完Small插件资源加载流程，你是否有疑问？Small只在框架加载时对ResourcesManager进行了hook，好像在创建新的Resources并没有进行hook操作？那么当系统新创建Resources实例时，新的Resources中包含的资源路径并没有插件资源，这好像说不通吧。其实关注Small的源码中ReflectAccelerator.ensureCacheResources，这个方法想要的达到的作用是当每次启动Activity时遍历系统缓存的ResourceImpl，将它的AssetManager替换成包含插件资源的AssetManager。当然这个机制只在SDK&gt;&#x3D;24时生效。 1234567891011121314151617public static void ensureCacheResources() &#123; if (Build.VERSION.SDK_INT &lt; 24) return; if (sResourceImpls == null || sMergedResourcesImpl == null) return; Set&lt;?&gt; resourceKeys = sResourceImpls.keySet(); for (Object resourceKey : resourceKeys) &#123; WeakReference resourceImpl = (WeakReference)sResourceImpls.get(resourceKey); if (resourceImpl != null &amp;&amp; resourceImpl.get() != sMergedResourcesImpl) &#123; // Sometimes? the weak reference for the key was released by what // we can not find the cache resources we had merged before. // And the system will recreate a new one which only build with host resources. // So we needs to restore the cache. Fix #429. // FIXME: we&#x27;d better to find the way to KEEP the weak reference. sResourceImpls.put(resourceKey, new WeakReference&lt;Object&gt;(sMergedResourcesImpl)); &#125; &#125;&#125; 这里有两个问题: SDK&lt;24时，在原生的Android系统中并不是每启动一个Activity都会创建一个新的Resources实例，ResourcesManager会使用缓存的Resources实例，所以只需要Hook一次资源加载。但是一旦创建多个Resources实例时，是不是意味着新创建的Resources并会包含插件的资源路径。个人理解是这样的。这应该也能解释为啥Small框架会在某些手机的分屏模式和某些横竖屏切换的时候会发生Crash，详情请查看#356和#548 SDK&gt;24时，Small会执行ensureCacheResources希望将新创建的ResourcesImpl的AssetsManger替换掉。但是看到源码中的实现方式是，通过反射为ActivityThread的mHHandler注入一个Handler.Callback。当HandlerCallback handleMessage LAUNCH_ACTIVITY消息时，执行ensureCacheResources方法。查看Handler的dispatchMessage 发现mCallback.handleMessage是先于mHandler.handleMessage的。 123456789101112131415/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 查看 0x02 Android资源加载流程 的资源流程，你会发现Resources对象的实例化并将ResourcesImpl添加到ResourcesManger的缓存列表中是在Handler.handleMessage之后的。所以ensureCacheResources并不能保证启动Activity时新创建的ResourcesImpl实例能够被正常hook的！！ 综上所述，这就是文章开头中兴手机Android7.1系统的手机上使用Small框架会发生Crash问题的原因，因为中兴系统每次打开新的Activity都会创建一个新的Resources和ResourcesImpl实例，而这些都是没有被hook的，不包含插件资源路径，自然就会发生资源查找失败的异常。解决方法也比较简单，因为是SDK&gt;24的机器，只需要在Small框架的InstrumentationWrapper.callActivityOnCreate方法中执行ReflectAccelerator.ensureCacheResources()就可以解决上面的问题了。 同时你需要注意另一个问题，查看ActivityThread的源码，在启动Activity流程的performLaunchActivity方法中，在mInstrumentation.callActivityOnCreate之前系统会为Activity设置主题。如果你选择在mInstrumentation.callActivityOnCreate中执行Resources的hook，并且此时需要的主题资源恰好在插件中，那依然会发生Crash。 123456789101112131415161718private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; .... ....省略其他代码 int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ....省略其他代码 ....&#125; 这里我的建议是把你项目中所有的主题定义都放在宿主中，并且修改Small的框架代码在InstrumentationWrapper.callActivityOnCreate方法中执行ReflectAccelerator.ensureCacheResources方法，这样就可以解决Small框架在某些场景下发生Resources$NotFoundException异常的问题。 0x05 完Small插件化框架是我在项目中使用的框架，他的设计和实现思路上都非常优雅，是首选的轻量级插件化框架。以上分析只是对Android源码和Small框架的个人理解，如有理解有误的地方还望指出，个人微信号:tykYang，邮箱:&#x79;&#x61;&#x6e;&#x67;&#102;&#x61;&#110;&#x33;&#54;&#56;&#x37;&#x40;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#x6d;。🙏🙏🙏 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"Android插件化","slug":"Android插件化","permalink":"https://ivonhoe.github.io/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96/"}],"tags":[{"name":"插件化","slug":"插件化","permalink":"https://ivonhoe.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"},{"name":"Android","slug":"Android","permalink":"https://ivonhoe.github.io/tags/Android/"},{"name":"Android源码","slug":"Android源码","permalink":"https://ivonhoe.github.io/tags/Android%E6%BA%90%E7%A0%81/"}]},{"title":"Android插件化之Small框架原理","slug":"small-plugin-1","date":"2018-01-18T09:54:19.000Z","updated":"2022-05-25T17:01:11.611Z","comments":true,"path":"2018/01/18/small-plugin-1/","link":"","permalink":"https://ivonhoe.github.io/2018/01/18/small-plugin-1/","excerpt":"Small是一个轻量化的插件化框架，Small的使用介绍可以查看官网文档)了解，Small项目接入总结可以查看博客的另一篇《Small框架实践总结》。这篇文章主要从以下几个角度来看Small框架的实现原理。 Small如何实现插件代码打包和资源打包 Small加载插件代码和资源的原理 Small代理插件activity生命周期的原理","text":"Small是一个轻量化的插件化框架，Small的使用介绍可以查看官网文档)了解，Small项目接入总结可以查看博客的另一篇《Small框架实践总结》。这篇文章主要从以下几个角度来看Small框架的实现原理。 Small如何实现插件代码打包和资源打包 Small加载插件代码和资源的原理 Small代理插件activity生命周期的原理 关于Small插件化的其他文档：《Android插件化之Small框架实践总结》《Android插件化之资源加载机制》《Android插件化之从入门到放弃》 0x01 Small如何打包module代码?small插件化中的三种组件角色，分别是app.*，lib.*，宿主。small在打包过程中会根据不同module的类型针对不同组件使用不同编译插件做处理，分别是: AppPlugin –&gt; app.* LibraryPlugin –&gt; lib.* HostPlugin –&gt; app AssetPlugin –&gt; 其他 在处理模块依赖上，首先区分gradle的两种依赖方式: Compile: compile是对所有的build type以及flavors都会参与编译并且打包到最终的apk文件中。 Provided: Provided是对所有的build type以及flavors只在编译时使用，只参与编译，不打包到最终apk。 在打包app.*插件时，将app.*对其他module的依赖转换成provided依赖。当执行插件打包时可以看做是插件模块执行assembleRelease。 在打包lib.*插件时，LibraryPlugin会修改插件模块的build.gradle文件，apply plugin: 从&#39;com.android.library&#39;修改成&#39;com.android.application&#39;，将对lib的方式转换成app的打包，再执行assembleRelease任务。 0x02 Small如何解决资源id冲突?Android App资源id的格式是0xPPTTNNNN，其中： PP 资源的package id TT 资源类型的id，类型是attr、layout、string等等 NNNN 资源的entry id Android App资源的默认packageId是0x7f，当同时加载多个插件apk时。必然会有插件间资源id冲突的情况。业界解决资源id冲突主要通过package id的分段，实现方式一般有两种方式，第一种方式是修改aapt工具源码，让aapt针对插件打包时每个插件的packageId都不相同，重新编译出aapt，而达到解决资源id冲突的问题。small框架使用的是另外一种方式，那就是读取并重写resources.arsc文件。大致的处理流程如下（出自small原作者在github issues的回答）： 编译完整的资源包，利用symbol&#x2F;R.txt搜集完整包entries的资源信息 搜集当前插件包res目录的entry信息 根据(2)，通过重新排序分配各个entry的资源id，并结合(1),形成旧id到新id的映射 解析(1)生成的resources.arsc文件，利用(3)进行过滤输出 0x03 Small如何加载插件代码？Small的加载插件代码的方式基于android dex分包方案的，简单的说small通过将多个dex文件塞入到app的classloader中，达到加载插件代码的目的。Small并不会更换系统的classloader，所以这样在面对多种不同机型时可能就不会遇到的兼容性问题。 怎样把多个dex文件塞入系统classloader中，可以看下QQ空间的热修复方案 0x04 Small如何加载插件资源?Android资源是由 AssetManager 加载的。应用启动时系统创建一个AssetManager实例，并通过addAssetPath方法添加资源路径，默认添加: “&#x2F;framework&#x2F;base.apk” - Android base resources (base) “&#x2F;data&#x2F;app&#x2F;*.apk” - The launching apk resources (host) 那么如何让插件的资源能够被系统加载？Small的方式是自己创建的AssetManager，调用AssetManger的addAssetPath方法添加插件资源路径，再将系统创建的AssetManager替换掉。 Hook AssetManager路径如下: 12345678910111213141516ActivityThread||---ResourcesManager mResourcesManager | |--- ArrayList&lt;WeakReference&lt;Resources&gt;&gt; mResourceReferences | |--- ResourcesImpl mResourcesImpl | |--- AssetManager mAssets |--- ArrayMap&lt;ResourcesKey, WeakReference&lt;ResourcesImpl&gt;&gt; mResourceImpls | |--- ResourcesImpl mResourcesImpl | |--- AssetManager mAssets 0x05 Small如何代理插件Activity的生命周期?先看Andriod中Activity是如何启动的。 12345678910MyActivity.startActivity()||--&gt;Activity.startActivity() | |--&gt;Activity.startActivityForResult() | |--&gt;Instrumentation.execStartActivty() | |--&gt;ActivityManagerNative.getDefault().startActivityAsUser() 通过 Activity 的启动流程可以发现，Activity是由 ActivityThread 和 Instrumentation 启动的，Instrumentation有关Activity启动相关的方法大概有：execStartActivity、newActivity等等。Small是这样操作的: 123456789101112131415MyActivity.startActivity()||--&gt;Activity.startActivity() | |--&gt;Activity.startActivityForResult() | |--&gt;InstrumentationWrapper.execStartActivty() | |--&gt; InstrumentationWrapper.wrapIntent() 将 Intent &#123; cmp=net.wequick.example.small/.app.main.MainActivity &#125; |--&gt; 转换成 Intent &#123; cat=[&gt;net.wequick.example.small.app.main.MainActivity] cmp=net.wequick.example.small/net.wequick.small.A &#125; | |--&gt;Instrumentation.execStartActivty() | |--&gt;ActivityManagerNative.getDefault().startActivityAsUser() Small首先在宿主manifest中注册一个命名特殊的占坑activity来欺骗系统获取生命周期，在封装一个Instrumentation替换掉宿主的，系统启动的是A这个activity，但classloader实际加载的代码却是 MainActivity.class 这个类。 12&lt;!-- Stub Activities --&gt;&lt;activity android:name=&quot;.A&quot; android:launchMode=&quot;standard&quot;/&gt; 伪代码如下: 1234567891011121314151617ActivityThread thread = currentActivityThread();Instrumentation base = thread.@mInstrumentation;Instrumentation wrapper = new InstrumentationWrapper(base);thread.@mInstrumentation = wrapper;class InstrumentationWrapper extends Instrumentation &#123; public ActivityResult execStartActivity(..., Intent intent, ...) &#123; fakeToStub(intent); base.execStartActivity(args); &#125; @Override public Activity newActivity(ClassLoader cl, String className, Intent intent) &#123; className = restoreToReal(intent, className); return base.newActivity(cl, className, intent); &#125;&#125; 0x06 Small如何动态更新插件模块?查看github sample实现方式 0x07 参考文档Small 官方 wiki QQ空间热补丁动态修复技术介绍 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"Android插件化","slug":"Android插件化","permalink":"https://ivonhoe.github.io/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96/"}],"tags":[{"name":"插件化","slug":"插件化","permalink":"https://ivonhoe.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"},{"name":"Android","slug":"Android","permalink":"https://ivonhoe.github.io/tags/Android/"}]},{"title":"Android插件化之Small框架实践总结","slug":"small-plugin-2","date":"2018-01-18T09:42:57.000Z","updated":"2022-05-25T17:01:19.675Z","comments":true,"path":"2018/01/18/small-plugin-2/","link":"","permalink":"https://ivonhoe.github.io/2018/01/18/small-plugin-2/","excerpt":"这篇文章主要总结了在使用Small框架改造老项目过程中遇到的问题和相应的解决方案，也总结了使用Small框架的基础知识点，并从一个使用者的角度来分析Small框架的优缺点。如果你的项目也面临业务模块耦合，边界不清晰，没有动态部署方案等等需要插件化方案来解决的问题，不妨先看下这篇文章再试一试Small框架，Small的功能未必全面但绝对聚焦了插件化框架需要解决的的核心问题。 什么是Small框架？ Small是一个轻量级的插件化框架，Small也是一个dex分包方案，Small也是一个业务模块解耦方案，同时Small也是一个动态化加载和更新方案。先去看官网文档了解Small的基础知识~~ Small官网文档","text":"这篇文章主要总结了在使用Small框架改造老项目过程中遇到的问题和相应的解决方案，也总结了使用Small框架的基础知识点，并从一个使用者的角度来分析Small框架的优缺点。如果你的项目也面临业务模块耦合，边界不清晰，没有动态部署方案等等需要插件化方案来解决的问题，不妨先看下这篇文章再试一试Small框架，Small的功能未必全面但绝对聚焦了插件化框架需要解决的的核心问题。 什么是Small框架？ Small是一个轻量级的插件化框架，Small也是一个dex分包方案，Small也是一个业务模块解耦方案，同时Small也是一个动态化加载和更新方案。先去看官网文档了解Small的基础知识~~ Small官网文档 关于Small插件化的其他文档：《Android插件化之Small框架原理》《Android插件化之资源加载机制》《Android插件化之从入门到放弃》 0x01 Small必知必会 Small框架将工程模块分为这几个角色，宿主，宿主分身，app插件，公共lib插件 宿主不依赖任何模块，宿主分身被所有app和lib依赖，但是宿主和宿主分身都被打包在主应用的主dex中，app插件和公共lib插件被单独打包在自己的插件so中 Small如何编译? .&#x2F;gradlew cleanLib 编译公共库: .&#x2F;gradlew buildLib .&#x2F;gradlew cleanBundle 编译app插件: .&#x2F;gradle buildBundle 编译宿主app: .&#x2F;gradle :app:assembleDaily 注意：这里不是assembleDaily 而是:app:assembleDaily app插件的模块名称必须是app.* , 公共库lib插件的模块名称必须是lib.*。 在宿主app assets目录的bundle.json文件中声明每个插件的包名、类型和页面路由等信息。当app插件的包名为 **.app.* 或 **.app*时, small框架会默认该插件模块为app插件。 app插件和app插件之间无法相互依赖，app插件之间可以通过路由uri传参，或者LocalBroadcast、Eventbus等消息机制实现通信。 Small中插件的packageId是自动根据模块名称hash计算生成，有可能会遇到插件模块packageId冲突的情况，在这种情况下需要在发生冲突模块的build.gradle重新声明packageId, 如下： 123ext &#123; packageId = 0x33&#125; 生成插件到 x86 架构下.&#x2F;gradlew buildLib -q -Dbundle.arch&#x3D;x86，需要注意 宿主的ndk abiFilters 要和bundle.arch一致哦。 如何启动其他插件模块的页面？通过Small.openUri()方法打开页面的路由地址。 动态更新插件时，需要升级插件的versionCode才会生效 非Activity组件需要声明在宿主或者宿主分身的manifest中 0x02 Small框架的优缺点选择small框架的原因： 集成简单 开发方式非常接近Android app的原生开发方式 不需要更换编译工具，已有项目中针对业务需求开发的编译工具依然可以继续使用 优雅，特别是对资源id冲突的处理方式 轻量化，尽可能少的hook系统变量，兼容性问题较少 不选择small框架的原因： 插件的加载并不是按需加载 插件的更新实现较简单，且没有回滚方案 有些隐藏bug还未解决，但可以绕过 功能相对其他插件化框架(比如atlas)来说还不够完善，但足够解决项目插件化目标中遇到的80%问题 0x03 Small插件化实践踩过的那些坑遇到问题怎么办？到github issues里查询你遇到的问题，一般都可以找到答案。这里大致总结了我们团队在small框架使用过程中遇到的常见问题。 lib插件中增加或减少资源时，需要删除模块目录下public.xml再重新编译。public.xml是为了锁定lib中资源id 增加或修改插件中ndk module覆盖安装不生效，需要将native module编译生成的so文件放在宿主中才能实现更新 遇到ClassNotFoundException异常或者无法启动某些activity companentInfo，排查问题的方法: 查看Fatal Runtime Exception日志，查看日志中已经加载的so是否包含你的插件so 如果插件so被加载，再确定相应代码已经被编译进插件so中，查看方法很简单，将插件so重命名为apk直接在Android Studio中打开 确认是否将插件so正确声明在bundle.json文件中 确认该异常类继承的父类或者接口满足上述几个条件 Class ref in pre-verified class resolved to unexpected implementation ，使用gradle smallLint命令查看是否有class重复了 https://github.com/wequick/Small/issues/423 Activity launch mode为singletop时在activity style中设置透明背景无效 https://github.com/wequick/Small/issues/94 无法通过Small.openUri()方法启动页面怎么办？一定是你用法不对，debug找原因。 0x04 Small插件化规范 不要在宿主中添加业务代码 native module so放在宿主中, 原因关注Github issue: 增加或修改插件中ndk module覆盖安装不生效 不同插件模块中依赖相同第三方aar或jar的版本号要相同，建议将aar或jar的版本号统一声明在gradle.properties中，将共同依赖的第三方sdk声明在宿主分身中 所有Theme的定义都放在宿主和宿主分身中，具体原因看我的另一篇问题总结：Android插件化之资源加载 Small插件化项目的完全体 0x05 参考Small官网文档 http://code.wequick.net/Small/cn/quickstart Small github主页 https://github.com/wequick/Small GMTC演讲PPT 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"Android插件化","slug":"Android插件化","permalink":"https://ivonhoe.github.io/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96/"}],"tags":[{"name":"插件化","slug":"插件化","permalink":"https://ivonhoe.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"},{"name":"Android","slug":"Android","permalink":"https://ivonhoe.github.io/tags/Android/"}]},{"title":"Android安全之某团请求加密破解","slug":"android-security-gold-flow-hack","date":"2017-06-18T10:13:19.000Z","updated":"2022-05-25T17:01:48.413Z","comments":true,"path":"2017/06/18/android-security-gold-flow-hack/","link":"","permalink":"https://ivonhoe.github.io/2017/06/18/android-security-gold-flow-hack/","excerpt":"本文记录了破解某外卖App http请求参数加密过程中遇到的问题和解决思路，实现的目标是希望是能够通过一些手段实现自由调用其服务接口。这篇文章主要讲述什么？ 静态分析和动态调试的基本方法和遇到的问题 如何听过修改android源码实现全局hook","text":"本文记录了破解某外卖App http请求参数加密过程中遇到的问题和解决思路，实现的目标是希望是能够通过一些手段实现自由调用其服务接口。这篇文章主要讲述什么？ 静态分析和动态调试的基本方法和遇到的问题 如何听过修改android源码实现全局hook 可以看到每次请求都会自动生成相应的请求参数，并计算出一个加密后的参数__skcy，服务端根据这些参数信息和请求内容做校验，校验通过服务端才会返回正确的结果。通过抓包和反编译后的代码大致梳理了上图请求参数的含义和生成方法，具体参数如下所示: __skck:Java层面常量，6a375bce8c66a0dc293860dfa83833ef **__skts:**系统时间值，通过Sytem.currentTime()获取，例如：1487054997740 __skua:通过UserAgent方法，获取ua，并计算出md5，通过动态调试发现该UserAgent方法返回为空，所以该值也为常量，d41d8cd98f00b204e9800998ecf8427e **__skno:**通过Java randomUUID获取随机数，例如：eccb0210-c86f-43bb-b12d-04927547b9ea **__skcy:**以上四个参数加上PostContent，调用native方法获取加密后得到该值 0x01 尝试静态分析首先使用常用的静态分析工具，如apkTools、dex2jar做apk的反编译和转Jar。虽然该App安装包没有加壳，但在反编译过程中依然遇到一些问题。 1.1、遇到问题该App针对dex2jar工具做了防范. 原理分析请看Android安全之应用防dex2jar原理及实现 1.2、解决方案 将插入的Exist代码删除，再做smali–&gt;dex–&gt;jar处理。 或者，直接阅读smali代码。 1.3、分析结果 该App在java层处理Http请求的核心类是CandyPreProcessor.java 该App调用加密so的JNI类是 CandyJni.java 该App执行参数加密的so是libmtguard.so 123456789public class CandyJni&#123; static &#123; System.loadLibrary(&quot;mtguard&quot;); &#125; static native String getCandyDataWithKey(Object paramObject, byte[] paramArrayOfByte, String paramString);&#125; 0x02 尝试动态调试smali这里先使用了源apk包在root手机上进行调试，但没有成功。只能尝试重打包调试。 2.1、如何使用AS动态调试参考吾爱破解这篇文章，需要下载AS baksmali插件，需要注意的是： AS remote debug端口号设置为8700 AS没有识别安卓代码情况下工具栏没有Android Device monitor的按钮，这时候通过monitor命令启动monitor 如果monitor启动时提示8700端口已经被占用，可以通过 lsof -n -i4TCP:8700 | grep LISTEN 命令查看8700端口目前对应的进程名 attach前一定要先在monitor里选中想要调试的进程，再debug 2.2、重写Java代码，直接调用加密so动态调试可以比较清楚的看到Java层的内部调用逻辑，通过debug watch功能可以清楚的看到寄存器值，结合反编译和静态分析可以知道调用native方法的入参格式。 现在的思路是解压出源apk包中的so文件，编写java代码直接调用so文件中的native方法获取计算__skcy参数。但测试的结果是一直返回null。这里猜测在native层中对运行环境做了监测，所以一直返回空值。 这里该app的参数签名详细过程是，通过__skck、__skts、__skno、__skua(详细规则见上)，调用CandyPreprocessor.java的getParametersSignature()方法获取__skcy参数。Java层核心方法getParametersSignature()如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * @param paramBuilder https://eapi.*****/api/poi/logon/acctdevice?__skck=6a375bce8c66a0dc293860dfa83833ef&amp;__skts=1486970558719&amp;__skua=d41d8cd98f00b204e9800998ecf8427e&amp;__skno=5ed4629c-098c-489c-b598-81841e0479e0 */String getParametersSignature(Uri.Builder paramBuilder, Context paramContext) &#123; if (paramBuilder == null) &#123; throw new RuntimeException(&quot;CandyPreprocessor getParametersSignature builder is null&quot;); &#125; // 获取网络接口名称 https://eapi.waimai.meituan.com/api/poi/logon/acctdevice Object localObject = baseString(); if (TextUtils.isEmpty((CharSequence) localObject)) &#123; throw new RuntimeException(&quot;CandyPreprocessor getParametersSignature normalizedURI is null&quot;); &#125; ArrayList localArrayList = new ArrayList(); /** * 0 = &#123;CandyPreprocessor$MyEntry@5016&#125; &quot;__skck&quot; -&gt; &quot;6a375bce8c66a0dc293860dfa83833ef&quot; 1 = &#123;CandyPreprocessor$MyEntry@5017&#125; &quot;__skts&quot; -&gt; &quot;1486970558719&quot; 2 = &#123;CandyPreprocessor$MyEntry@5018&#125; &quot;__skua&quot; -&gt; &quot;d41d8cd98f00b204e9800998ecf8427e&quot; 3 = &#123;CandyPreprocessor$MyEntry@5019&#125; &quot;__skno&quot; -&gt; &quot;5ed4629c-098c-489c-b598-81841e0479e0&quot; */ // 获取参数key和参数value放到数组中 appendList(localArrayList, paramBuilder, false); // add &quot;__sksc&quot; -&gt; &quot;https&quot; // 获取scheme放入数组中 localArrayList.add(new CandyPreprocessor.MyEntry(&quot;__sksc&quot;, this.candyOriginalMaterial.getScheme())); // 将post content放入数组中 if (formURLEncoded()) &#123; // /?dVersion=23_6.0&amp;utm_medium=android&amp;password=2222&amp;utm_content=867689027084732&amp;appCode=388&amp;acctId=&amp;wmPoiId=&amp;token=&amp;uuid=03EB35F2C93419DC64AFFBC9EF6BB6BADE4DD72DC1E2F4733198E91C91AEAF93&amp;logType=C&amp;appName=%E7%BE%8E%E5%9B%A2%E5%A4%96%E5%8D%96%E5%95%86%E5%AE%B6%E7%89%88&amp;appType=4&amp;dType=PLK-TL01H&amp;userName=1111&amp;utm_term=4.2.0.388&amp;utm_source=&amp;utm_campaign=&amp;wm_appversion=4.2.0.388&amp; // post 的内容入参 /** * 5 = &#123;CandyPreprocessor$MyEntry@5071&#125; &quot;dVersion&quot; -&gt; &quot;23_6.0&quot; 6 = &#123;CandyPreprocessor$MyEntry@5072&#125; &quot;utm_medium&quot; -&gt; &quot;android&quot; 7 = &#123;CandyPreprocessor$MyEntry@5073&#125; &quot;password&quot; -&gt; &quot;123&quot; 8 = &#123;CandyPreprocessor$MyEntry@5074&#125; &quot;utm_content&quot; -&gt; &quot;867689027084732&quot; 9 = &#123;CandyPreprocessor$MyEntry@5075&#125; &quot;appCode&quot; -&gt; &quot;388&quot; 10 = &#123;CandyPreprocessor$MyEntry@5076&#125; &quot;acctId&quot; -&gt; 11 = &#123;CandyPreprocessor$MyEntry@5077&#125; &quot;wmPoiId&quot; -&gt; 12 = &#123;CandyPreprocessor$MyEntry@5078&#125; &quot;token&quot; -&gt; 13 = &#123;CandyPreprocessor$MyEntry@5079&#125; &quot;uuid&quot; -&gt; &quot;03EB35F2C93419DC64AFFBC9EF6BB6BADE4DD72DC1E2F4733198E91C91AEAF93&quot; 14 = &#123;CandyPreprocessor$MyEntry@5080&#125; &quot;logType&quot; -&gt; &quot;C&quot; 15 = &#123;CandyPreprocessor$MyEntry@5081&#125; &quot;appName&quot; -&gt; &quot;****&quot; 16 = &#123;CandyPreprocessor$MyEntry@5082&#125; &quot;appType&quot; -&gt; &quot;4&quot; 17 = &#123;CandyPreprocessor$MyEntry@5083&#125; &quot;dType&quot; -&gt; &quot;PLK-TL01H&quot; 18 = &#123;CandyPreprocessor$MyEntry@5084&#125; &quot;userName&quot; -&gt; &quot;***&quot; 19 = &#123;CandyPreprocessor$MyEntry@5085&#125; &quot;utm_term&quot; -&gt; &quot;4.2.0.388&quot; 20 = &#123;CandyPreprocessor$MyEntry@5086&#125; &quot;utm_source&quot; -&gt; 21 = &#123;CandyPreprocessor$MyEntry@5087&#125; &quot;utm_campaign&quot; -&gt; 22 = &#123;CandyPreprocessor$MyEntry@5088&#125; &quot;wm_appversion&quot; -&gt; &quot;4.2.0.388&quot; */ appendList(localArrayList, Uri.parse(&quot;/?&quot; + new String(this.candyOriginalMaterial.getPostContent())).buildUpon(), true); &#125; // 特殊字符转码 List percentParamList = getPercentList(localArrayList); // 分别对Value和Key做升序排列 dictionarySort(percentParamList); // 将排序后的数组，拼接成字符串__skck=6a375bce8c66a0dc293860dfa83833ef&amp;__skno=5ed4629c-098c-489c-b598-81841e0479e0&amp;__sksc=https&amp;__skts=1486970558719&amp;__skua=d41d8cd98f00b204e9800998ecf8427e&amp;acctId=&amp;appCode=388&amp;appName=%E7%BE%8E%E5%9B%A2%E5%A4%96%E5%8D%96%E5%95%86%E5%AE%B6%E7%89%88&amp;appType=4&amp;dType=PLK-TL01H&amp;dVersion=23_6.0&amp;logType=C&amp;password=2222&amp;token=&amp;userName=1111&amp;utm_campaign=&amp;utm_content=867689027084732&amp;utm_medium=android&amp;utm_source=&amp;utm_term=4.2.0.388&amp;uuid=03EB35F2C93419DC64AFFBC9EF6BB6BADE4DD72DC1E2F4733198E91C91AEAF93&amp;wmPoiId=&amp;wm_appversion=4.2.0.388 String paramBuilderString = getNormalizedParameters(percentParamList); // POST+空格+&quot;接口名称&quot;+空格+&quot;参数内容&quot; // POST http://eapi.waimai.meituan.com/api/poi/logon/acctdevice __skck=6a375bce8c66a0dc293860dfa83833ef&amp;__skno=57749130-26d4-4239-8abd-b99c16584908&amp;__sksc=http&amp;__skts=1486995346041&amp;__skua=d41d8cd98f00b204e9800998ecf8427e&amp;acctId=&amp;appCode=388&amp;appName=%E7%BE%8E%E5%9B%A2%E5%A4%96%E5%8D%96%E5%95%86%E5%AE%B6%E7%89%88&amp;appType=4&amp;dType=PLK-TL01H&amp;dVersion=23_6.0&amp;logType=C&amp;password=2222&amp;token=&amp;userName=1111&amp;utm_campaign=&amp;utm_content=867689027084732&amp;utm_medium=android&amp;utm_source=&amp;utm_term=4.2.0.388&amp;uuid=03EB35F2C93419DC64AFFBC9EF6BB6BADE4DD72DC1E2F4733198E91C91AEAF93&amp;wmPoiId=&amp;wm_appversion=4.2.0.388 paramBuilderString = this.candyOriginalMaterial.getHttpMethod() + &quot; &quot; + (String) localObject + &quot; &quot; + paramBuilderString; // JV1EOT1VZGN8USskB3jZYnVGyyQ= // 调用jni获取加密后的参数值__skcy localObject = CandyJni.getCandyDataWithKey(paramContext, paramBuilderString.getBytes(), &quot;candyKey&quot;); // TODO for test return (String) localObject; &#125; 2.3、修改app代码，重打包调用so直接调用so的方法失败了，现在尝试反编译APK后，加入包含自己逻辑的smali代码，调用CandyJni的目的。具体的步骤是： 利用上2.2的项目，拷贝和该App CandyJni完全相同的类名，方法名。 编写CandyHackActivity.Java和CandyHack.java，去调用新项目中的CandyJni，并打包。 apktools反编译新项目包，获取CandyHack.smali 和CandyHackActivity.smali。 修改反编译后项目的AndroidManifest.xml文件，将CandyHackActivity注册到manifest中进去。 重打包，签名，安装。 通过adb命令启动CandyHackActivity。 结果一点不意外，能够成功调用CandyJni中的方法并且有返回值，但是经过测试在相同入参的情况下，和源APK包的加密结果不一致。问题应该出在签名。猜测应该是so中的方法将应用签名作为了一个加密参数。虽然能正常调用，但结果是错的~~ 2.4、尝试IDA pro反编译so一句话，IDA反编译后发现，在function窗口中找不到getCandyDataWithKey或者getCandyData这些在Java层声明的native方法。应该是使用了动态注册的方式注册了native方法，又一次把代码阅读门槛从C升级到了汇编，泪目~~~ 2.5、总结问题 想要在root机器上动态调试dex，但不进行重打包，就需要绕过他的反调试手段。反调试手段是什么？怎么绕过？我不知道 想要通过重打包动态调试dex，重打包必须重新签名，重新签名会导致加密算法计算结果出错。 想要反编译so，需要阅读加密后的C语言和汇编语言。汗！我是菜鸟汇编阅读不来 0x03 万金流破解思路根据以上分析的过程，发现不管是重打包、借用so、静态分析、动态调试等基础的破解方式，该app都做了相应的防护措施，总的破解思路都是破坏了app原有环境。在一次逛安全论坛的过程中，看到通过修改Android原生代码加载特定so的思路，其实这种破解思路也适用于app的破解。如果在app启动时，让app进程的DexClassLoader能够加载你自己的代码，那么不管在任何的app运行环境中，诸如修改内存变量、调用方法或者是改变原有app系统的处理流程等目的都能够轻松达到。当然前提是运行在自己编译的Android源码或者是已经root的机器上。下面就以这个思路针对该外卖app做具体的破解实操，目标是在pc上能够自由调用该app服务端的http接口。 3.1. 下载并修改源码如何下载编译源码这里不废话，没有尝试过的可以参考这篇《Mac OS上编译Android源码》。在ActivityThread.java的handleBindApplication()方法中增加dex注入的逻辑。 1234567891011121314private void handleBindApplication(AppBindData data) &#123; // 省略源码... //=================全局注入之修改java层=================================================== checkFrameworkInject(data.processName); //=============================================================================&#125;private void checkFrameworkInject(String processName) &#123; //=================全局注入之修改java层=================================================== Log.e(&quot;frameworkInjector&quot;, &quot;--processName=&quot; + processName); invokeJarLoader(processName); //=============================================================================&#125; 从指定路径加载配置文件，配置信息包括要dex注入的进程名，dex路径，dex中main函数信息。当相应的进程启动时，加载指定路径的dex，并运用其中的main函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 根据配置加载jar，执行指定类的main方法 */ public void invokeJarLoader(String processName) &#123; List&lt;String&gt; config = readHookConfig(&quot;/data/local/jarHookConfig.txt&quot;); if (config == null || config.size() &lt; 3) &#123; return; &#125; String configProcessName = config.get(0); String configJarPath = config.get(1); String configClassName = config.get(2); if (processName.equals(configProcessName) &amp;&amp; !TextUtils.isEmpty(configJarPath) &amp;&amp; !TextUtils.isEmpty(configClassName)) &#123; Log.e(&quot;frameworkInjector&quot;, &quot;targetPackage:&quot; + configProcessName + &quot;,start-load-jarPath&quot; + configJarPath + &quot;, class name:&quot; + configClassName); jarInvokeTest(configJarPath, configClassName); &#125; &#125; public void jarInvokeTest(String jarPath, String className) &#123; final File optimizedDexOutputPath = new File(jarPath); Context context = getApplication(); File dexOutputDir = context.getDir(&quot;dex&quot;, 0); DexClassLoader cl = new DexClassLoader( optimizedDexOutputPath.getAbsolutePath(), dexOutputDir.getAbsolutePath(), null, context.getClassLoader()); Class libProviderClazz = null; try &#123; libProviderClazz = cl.loadClass(className); Method method = libProviderClazz.getMethod(&quot;main&quot;); method.invoke(null, (Object[]) null); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; 3.2 生成注入的dex在这里具体的注入代码就不啰嗦了，总的来说你可以针对任何app中的任何方法变量任意操作。如果你想在pc上实现请求的自由收发要稍微复杂些，你需要实现一个简单的Hook socket server（简称HSS），将HSS打包成dex做注入，将参与参数加密的数据发送给HSS，HSS调用app中的加密方法获取加密结果，并将最终的加密结果发送出来就可以啦。具体的实现如下图所示: 0x04 严重声明本文的意图只有一个，就是通过分析app学习更多的逆向技术，如果有人利用本文知识和技术进行非法操作进行牟利，带来的任何法律责任都将由操作者本人承担，和本文作者无任何关系，最终还是希望大家能够秉着学习的心态阅读此文。 0x05 参考文档 Smali语法 逆向加固的apk详细教程 修改源码实现全局(无需root)注入躲开注入检测 Android动态加载jar Java之jar打包 0x06 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"Android安全","slug":"Android安全","permalink":"https://ivonhoe.github.io/categories/Android%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ivonhoe.github.io/tags/Android/"},{"name":"移动安全","slug":"移动安全","permalink":"https://ivonhoe.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"}]},{"title":"捕获线程池任务异常引发的血案","slug":"executor-eat-exception","date":"2017-05-12T08:41:53.000Z","updated":"2022-05-25T17:02:46.196Z","comments":true,"path":"2017/05/12/executor-eat-exception/","link":"","permalink":"https://ivonhoe.github.io/2017/05/12/executor-eat-exception/","excerpt":"今天遇到一个很诡异的问题，在多款Android 4.2.2版本的手机上发现处理后台任务的服务对前台请求毫无响应。这里的后台服务是一个RemoteService，目的为了处理更新&amp;上传等任务。本来以为是跨进程组件间通讯出现兼容性问题，后来根据分析发现问题没有那么简单，这里记录下问题原因。","text":"今天遇到一个很诡异的问题，在多款Android 4.2.2版本的手机上发现处理后台任务的服务对前台请求毫无响应。这里的后台服务是一个RemoteService，目的为了处理更新&amp;上传等任务。本来以为是跨进程组件间通讯出现兼容性问题，后来根据分析发现问题没有那么简单，这里记录下问题原因。 第一个错误在后台服务处理任务请求时,使用了自定义线程池处理异步任务，而Java 线程池java.util.concurrent.ThreadPoolExecutor会Catch住所有异常，即便是你运行例如下面的代码也不会抛出异常。 12345678910Runnable runnable = new Runnable() &#123; @Override public void run() &#123; Test test = null; System.out.println(test.toString()); &#125;&#125;;mExecutor.submit(runnable); 在处理线程池异常捕获的问题时，犯下了第一个错误，使用了submit方法拿到任务执行结果会阻塞当前线程。 12345678910111213141516public Future&lt;?&gt; submit(Runnable task) &#123; Future&lt;?&gt; future = mExecutor.submit(task); try &#123; future.get(); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); // Reset interrupted status &#125; catch (ExecutionException e) &#123; Throwable exception = e.getCause(); // Forward to exception reporter if (exception instanceof UncatchException) &#123; throw (UncatchException) exception; &#125; &#125; return future;&#125; 第二个错误在错误一的基础上，使用了一个开源并发库android-lite-go，先看它的异步任务是如何调度的。 12345678910111213int coreSize = CPU_CORE;int queueSize = coreSize * 32;synchronized (lock) &#123; if (runningList.size() &lt; coreSize) &#123; runningList.add(scheduler); threadPool.execute(scheduler); &#125; else if (waitingList.size() &lt; queueSize) &#123; waitingList.addLast(scheduler); &#125; else &#123; //... &#125;&#125; 当正在运行的任务数小于设定的coreSize时，submit的任务会提交到线程池。 coreSize由系统核心数确定。 当正在运行的任务数小于queueSize时，submit的任务会提交到等待队列中。 当一个任务执行完后，会从等待队列中获取一个任务提交给线程池执行。 在一个异步任务中使用阻塞当前线程的方法，把另一个任务提交给了executor。 1234567891011121314151617181920212223private void runTaskOne() &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; // do something runTaskTwo(); &#125; &#125;; mTaskController.submit(runnable);&#125;private void runTaskTwo() &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; // do task2 // ...... &#125; &#125;; mTaskController.submit(runnable);&#125; 问题原因及解决方案当正在运行的任务使用阻塞当前进程的submit方法提交另一个异步任务时，后提交的任务被放入等待队列等待线程池执行，但在Running list中的任务又在等待后任务执行的结果，这样就造成了死锁！！这个问题跟Android系统版本并没有关系，但因为Android 4.2.2版本的手机低端较多核心数较少，所以runningList的大小就比较小，Running List很容易就被填满。 解决方案 使用非阻塞的方法提交异步任务 自定义线程池，重写afterExecute()方法，在该中获取线程池运行的异步任务运行时异常。 123456789101112131415161718192021222324252627ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(11, 100, 1, TimeUnit.MINUTES, // new ArrayBlockingQueue&lt;Runnable&gt;(10000),// new DefaultThreadFactory()) &#123; protected void afterExecute(Runnable r, Throwable t) &#123; super.afterExecute(r, t); printException(r, t); &#125;&#125;;private static void printException(Runnable r, Throwable t) &#123; if (t == null &amp;&amp; r instanceof Future&lt;?&gt;) &#123; try &#123; Future&lt;?&gt; future = (Future&lt;?&gt;) r; if (future.isDone()) future.get(); &#125; catch (CancellationException ce) &#123; t = ce; &#125; catch (ExecutionException ee) &#123; t = ee.getCause(); &#125; catch (InterruptedException ie) &#123; Thread.currentThread().interrupt(); // ignore/reset &#125; &#125; if (t != null) log.error(t.getMessage(), t);&#125; 参考文档 捕获Java线程池执行任务抛出的异常 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"学习总结","slug":"学习总结","permalink":"https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://ivonhoe.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"死锁","slug":"死锁","permalink":"https://ivonhoe.github.io/tags/%E6%AD%BB%E9%94%81/"}]},{"title":"Android performance optimization tips","slug":"android-performance-tips","date":"2017-05-05T14:59:14.000Z","updated":"2022-03-27T13:57:36.739Z","comments":true,"path":"2017/05/05/android-performance-tips/","link":"","permalink":"https://ivonhoe.github.io/2017/05/05/android-performance-tips/","excerpt":"使用windowBackground实现应用秒开1234&lt;style name=&quot;SplashTheme&quot; parent=&quot;@android:style/Theme.Black.NoTitleBar.Fullscreen&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/bg_splash_activity&lt;/item&gt; &lt;item name=&quot;@android:windowAnimationStyle&quot;&gt;@style/myact&lt;/item&gt;&lt;/style&gt; 使用windowBackground减少过度绘制12345&lt;style name=&quot;AppMainTheme&quot; parent=&quot;@android:style/Theme.Holo.Light&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@color/white&lt;/item&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;@android:windowAnimationStyle&quot;&gt;@style/myact&lt;/item&gt;&lt;/style&gt;","text":"使用windowBackground实现应用秒开1234&lt;style name=&quot;SplashTheme&quot; parent=&quot;@android:style/Theme.Black.NoTitleBar.Fullscreen&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/bg_splash_activity&lt;/item&gt; &lt;item name=&quot;@android:windowAnimationStyle&quot;&gt;@style/myact&lt;/item&gt;&lt;/style&gt; 使用windowBackground减少过度绘制12345&lt;style name=&quot;AppMainTheme&quot; parent=&quot;@android:style/Theme.Holo.Light&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@color/white&lt;/item&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;@android:windowAnimationStyle&quot;&gt;@style/myact&lt;/item&gt;&lt;/style&gt; 手动清除GPU绘图缓存，降低应用PSS内存值123456789101112131415161718192021/** * 清除GPU绘图缓存 */private void cleanGraphicsCache() &#123; Object instance = ReflectUtils.getStaticMethod(&quot;android.view.WindowManagerGlobal&quot;, &quot;getInstance&quot;, null, null); try &#123; Class threadClazz = Class.forName(&quot;android.view.WindowManagerGlobal&quot;); Method m1 = threadClazz.getDeclaredMethod(&quot;trimMemory&quot;, int.class); m1.invoke(instance, TRIM_MEMORY_COMPLETE); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125;&#125; 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"对Android系统资源预加载的思考","slug":"Zygote-2","date":"2017-04-25T16:49:27.000Z","updated":"2022-04-09T16:13:10.215Z","comments":true,"path":"2017/04/26/Zygote-2/","link":"","permalink":"https://ivonhoe.github.io/2017/04/26/Zygote-2/","excerpt":"","text":"一、分析一个Hello World App中bitmap对象的分布使用BitmapAnalyzer分析一个Android Hello World App时你会dump出400+张图片，什么是BitmapAnalyzer？BitmapAnalyzer是一个自动分析Android dump heap中bitmap对象的工具，详细请看《Android Bitmap的内存大小是如何计算的？》这篇文章的介绍。 分析仔细看一下可以发现，上图中sPreloadedDrawables数组所引用的预加载Drawable就会占用10M以上的内存空间。这些都是Android系统的主题资源图片，为什么会有这么多主题资源被加载？不需要的无用的系统资源能否避免被加载？那么要如何做到？ 二、为什么有这么多系统资源被加载？使用Android Studio(简称AS)的monitor工具dump内存如上图所示，hprof中的内存信息分为三类，分别是App heap，Image heap，Zygote heap。App heap很好理解，就是应用进程独占的内存空间，在应用中创建的对象都会在App heap上。而在Dalvik虚拟机上运行的app，只有App heap和Zygote heap，并没有Image heap。Android官网文档的三者的解释是： 12345App heap - The heap used by the current app.Image heap - The memory mapped copy of the current app on disk.Zygote heap - The common set of libraries and runtime classes and data that all apps are forked from. The zygote space is created during device startup and is never allocated into. Zygote机制总的来说是app_process启动Zygote并创建第一个虚拟机进程，Zygote启动时会预加载所有需要的Java classes和”必要的”资源文件，这些资源文件就包括我们在hprof文件中看到的被sPreloadedDrawables所直接引用的Bitmap资源。应用进程都是从Zygote中fork出来的，所以所有的应用进程都会包含上面提到的资源文件。这些资源的拷贝可以看成浅拷贝，并不是真正的内存copy，而是作为进程间的共享内存使用。详细的可以查看《Zygote》这篇文章。 三、强制清除未使用的系统资源图片会怎样？123456789101112131415161718192021222324252627282930313233343536private void clearPreloadedDrawables() &#123; try &#123; Field mFieldPreloadedDrawables = getField(Resources.class, &quot;sPreloadedDrawables&quot;); if (mFieldPreloadedDrawables != null) &#123; mFieldPreloadedDrawables.setAccessible(true); boolean access = mFieldPreloadedDrawables.isAccessible(); if (!access) &#123; mFieldPreloadedDrawables.setAccessible(true); &#125; if (Build.VERSION.SDK_INT &lt;= 17) &#123; LongSparseArray&lt;Drawable.ConstantState&gt; dArray = (LongSparseArray&lt;Drawable.ConstantState&gt;) mFieldPreloadedDrawables.get(getResources()); if (dArray != null) &#123; dArray.clear(); &#125; // dArray.put(1, createDrawableConstant()); &#125; else if (Build.VERSION.SDK_INT &gt;= 18) &#123; LongSparseArray&lt;Drawable.ConstantState&gt;[] dArray = (LongSparseArray&lt;Drawable.ConstantState&gt;[]) mFieldPreloadedDrawables.get(getResources()); if (dArray != null) &#123; for (int i = 0; i &lt; dArray.length; i++) &#123; if (dArray[i] != null) &#123; dArray[i].clear(); // dArray[i].put(1, createDrawableConstant()); &#125; &#125; &#125; &#125; mFieldPreloadedDrawables.setAccessible(true); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 当通过上述clearPreloadedDrawables函数清除sPreloadDrawable对这些资源的强引用，然后使用Android Studio的monitor工具发现，gc以后App heap发生了断崖式的内存回收，并且使用adb shell dumpsys meminfo命令可以发现Heap Alloc和Heap Size都发生了显著的减小，但Pss total并没有显著变化。这里的理解是PSS &#x3D; Private RAM + 按比例计算的Shared RAM，这两部分都没有发生显著变化，所以PSS Total没有变化。 那请问，上面👆的内存清理有意义吗？Heap allocated较少了10M，但PSS并没有明显的变化，给我的感觉就像大家在吃大锅饭，我只吃了1碗，别人吃了10碗，付钱的时候却是AA，甚至可能我付的还更多一些。你说你是不是萨？ 四、Copy-On-Write(COW)Zygote heap是系统共享内存heap，这里我尝试修改sPreloadDrawable对应数据时，如下图所示，系统默认预加载399张资源图片，当手动插入一张新的图片到缓存后，缓存大小变成了400。但让我觉得诡异的是，不是说Android系统使用COW机制吗？为啥插入前后sPreloadDrawable相关的内存地址根本没有变化？ 我的理解是在fork子进程的时候并不会真正拷贝父进程内存数据，而是子进程的虚拟内存空间指向父进程的物理内存空间。子进程和父进程的虚拟空间不同，但物理空间是同一个。当子进程需要重写共享内存数据时，系统才会为子进程分配响应的物理内存。这里的虚拟内存空间对应用程序来说就是逻辑地址，对于CPU来说就是线性地址。 五、总结回到之前思考的几个问题： 为什么会有这么多主题资源被加载？这些主题资源是系统启动时Zygote预加载的系统资源，Zygote认为这些资源每个App都会用到，特别是5.0+的系统会达到400+的默认theme图片，占用10M+的内存空间，不过这些内存是系统共享的你用或不用他们都在那里。改变应用的主题样式并不会改变sPreloadDrawable的加载内容。 不需要的无用资源能否避免被加载？这些默认系统资源无法避免被系统预加载，但是不同ROM厂商针对这些资源的看法差别还是很大的，根据测试的情况看，三星的预加载资源比源码的还要多，清空sPreloadDrawable也不能减少Heap allocte的大小。相反锤子手机对这些预加载资源的作用倒是不太看好，在锤子坚果上看到的预加载资源就很少，几乎可以忽略不计。而在Android 5.0以下的系统版本，这块预加载的资源也不是很夸张。 清空预加载资源对应用内存有无优化作用？说下个人看法，如果你的应用分为UI进程和后台服务进程。在UI进程清除系统预加载资源可能并不是明智的选择，为啥？因为这是一件吃力未必讨好的事情，虽然这10M空间你并没有使用，但系统并没有领情，反而当你想要在使用系统资源的时候，那这些资源就会完全算到你的头上。那样反而会造成应用进程内存的上升。为啥？清除系统的共享内存后，再加载系统资源时分配的就是应用的私有内存了。如果是后台服务进程，打死也不会用到系统主题资源的情况下，清除预加载资源为什么不是对自己有利的事情呢？因为这样做确实让Heap变小了呀！ 当然以上都是个人的理解，如有理解错误，恳请能够指出。对于如何获取Java对象的物理地址，我还没有找到更好的办法，所以暂时还没有实践验证COW。 临帖顿首，不知所言，2017.4.26日夜。 参考HPROF Viewer and Analyzer Manage Your App’s Memory 深入理解 Zygote Linux写时拷贝技术(copy-on-write) linux虚拟地址转物理地址","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Zygote","slug":"Zygote","permalink":"https://ivonhoe.github.io/tags/Zygote/"},{"name":"Copy-on-write","slug":"Copy-on-write","permalink":"https://ivonhoe.github.io/tags/Copy-on-write/"},{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"如何写出GC友好的应用","slug":"如何写出GC友好的Android应用","date":"2017-04-25T13:21:23.000Z","updated":"2022-03-27T14:00:48.512Z","comments":true,"path":"2017/04/25/如何写出GC友好的Android应用/","link":"","permalink":"https://ivonhoe.github.io/2017/04/25/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BAGC%E5%8F%8B%E5%A5%BD%E7%9A%84Android%E5%BA%94%E7%94%A8/","excerpt":"作者：乐蛙科技高级研发经理 易宁 Android应用普遍没有iOS应用流畅，这与Android应用是运行在Java虚拟机上有很大的关系，而关系最大的恐怕就是Java虚拟机上的Garbage Collection（GC）了。Java语言提供了自动内存管理，垃圾对象会在GC过程中自动被释放。这提供了开发效率，使开发者能集中精力在业务逻辑上；但天下没有免费的午餐，你写的Android应用的某些性能上的问题很可能就是GC导致的。 下面是一段非常简单的Java语句： 1byte[] data = new byte[512 * 512 * 4]; 这条语句申请了一块大小相等于512*512大小图片的内存。执行这条语句会消耗多少时间呢？0+ms吗？基本没有性能影响吗？","text":"作者：乐蛙科技高级研发经理 易宁 Android应用普遍没有iOS应用流畅，这与Android应用是运行在Java虚拟机上有很大的关系，而关系最大的恐怕就是Java虚拟机上的Garbage Collection（GC）了。Java语言提供了自动内存管理，垃圾对象会在GC过程中自动被释放。这提供了开发效率，使开发者能集中精力在业务逻辑上；但天下没有免费的午餐，你写的Android应用的某些性能上的问题很可能就是GC导致的。 下面是一段非常简单的Java语句： 1byte[] data = new byte[512 * 512 * 4]; 这条语句申请了一块大小相等于512*512大小图片的内存。执行这条语句会消耗多少时间呢？0+ms吗？基本没有性能影响吗？ 实际的情况是：0200ms，甚至更多！这取决于应用当前Heap使用情况。在一个类似Hello World的测试程序里，执行这条语句有时候只需要0+ms就完成了，但一般情况是16+ms，甚至有时候需要30+ms。我们知道一段流畅的动画每帧绘图消耗的时间应该小于16ms，因为这样才能保证动画有60FPS的帧率。但如果执行上面那句简单的语句就要错过12帧，那就难怪动画不流畅了。 不过，有人可能要说了：“没人会傻到在每帧绘图的时候去申请一块这么大的内存，实际情况不会有这个问题”。实际的工程中的确不会这么写，但造成执行这条语句耗时比较长的原因不是因为申请的内存太大，而是申请过程中产生了GC，就算是一个Byte的内存申请也可能消耗比这更长的时间。 Dalvik中GC的原理在Dalvik虚拟机中定义了四种触发GC的条件（参看Heap.h）： GC_CONCURRENT，当Heap的使用率达到某一阈值时自动触发。 GC_FOR_MALLOC，当Heap没有足够的空间用于容下新创建的对象时。 GC_EXPLICIT，用户主动调用GC时。 GC_BEFORE_OOM，当要发生OOM时系统尝试进行最后GC的努力。 GC_CONCURRENT和GC_EXPLICIT是并行的，GC过程中应用不会被暂停，只在GC开始和结束时会暂停应用，每次暂停的时间比较短，一般只有3~4ms。GC_FOR_MALLOC是非并行的，GC过程中应用被暂停，耗时比较长，可能几十毫秒也可能几百毫秒。在应用向Dalvik申请内存时，Dalvik先检查当前Heap中有无足够的空余空间用来安排对象，当发现没有足够的空间的时候会先进行GC_FOR_MALLOC以试图释放垃圾对象来获取新的空间，如果发现空间还不够则进行Heap的增长。在每次成功分配完新的空间后，Dalvik会检查当前Heap的使用情况，如果使用空间超过一定的阈值的时候，GC_CONCURRENT就会触发。 每次GC的时候会打印如下的Log信息： 1D/dalvikvm(10497): GC_CONCURRENT freed 2940K, 54% free 2885K/6204K, paused 1ms+4ms， total 38ms 上面的Log信息表明：这次GC_CONCURRENT释放了2940K的空间，当前Heap使用率为54%，总的Heap大小是6204K，空余2885K，GC开始时暂停了1ms，GC结束时暂停了4ms，GC总共花了38ms。 Dalvik虚拟机通过下面几个个属性值来控制Heap的空间配置： targetUtilization，理想的Heap利用率，每当Heap增长时Dalvik会使增长后的Heap维持在这个利用率附近。 minFree，空余空间最小值。 maxFree，空余空间最大值。 startSize，虚拟机启动时初始的Heap大小。 growthLimit，用户设置的允许的最大Heap大小。 maximumSize， Heap空间最大极限值。 这些属性值都可以通过system/build.prop来配置，zygote启动dalvik虚拟机时会从该文件中读取这些参数。通常来说，Heap空余空间越大应用越流畅，消耗的内存也更多。 下图为一次“顺利”的4M内存申请:可以看到在申请之前，空余的空间达到8M，申请4M的内存很顺利没有任何GC发生。 下图为一次“不顺利”的8M内存申请：虽然空余的空间已经有8M，但是为了保证正常的Heap利用率，Heap空间还是增长了，并且增长Heap之前进行了一次GC_FOR_MALLOC。 下图为继续申请8M的内存：相应的输出Log： 1D/dalvikvm﹕ GC_FOR_ALLOC freed 8195K, 34% free 16726K/24972K, paused 23ms, total 23ms 上图和Log更加清晰的表明Heap空间不够时会先进行一次GC，GC的类型就是GC_FOR_MALLOC。 Android流畅的关键：GC_FOR_MALLOCGC_CONCURRENT和GC_FOR_MALLOC虽然都是系统自动调用的，都暂停了应用，但它们花费的时间不在一个数量级。通过上面的分析我们知道每次申请内存空间不够时就会产生GC_FOR_MALLOC，我们不可能不申请内存，所以也不可能完全避免GC_FOR_MALLOC，但还是有些策略能降低GC_FOR_MALLOC的影响： 避免不必要的GC_FOR_MALLOC Heap空间都有其理想的利用率，在理想的利用空间内，申请内存是不会发生GC_FOR_MALLOC。 应用应该避免内存开销的波动，将内存的波动维持在maxFree和mixFree之间。 避免大的内存需求。比如，不要轻易去用WallpaperManager，因为壁纸占用巨大的内存。 应该尽量复用对象。比如，使用BitmapFactory加载图片时使用BitmapFactory.Option.inBitmap复用Bitmap，避免申请内存。 对于已知有垃圾对象的情况下，先进行手动的System.gc()来释放空间，而不是等到系统自动调用GC_FOR_MALLOC。因为GC_EXPLICIT是异步的，暂停应用的时间远小于GC_FOR_MALLOC。 不要在循环中申请创建对象。循环中申请的对象会不断累积，直到空间不够发生GC_FOR_MALLOC。 减少GC_FOR_MALLOC的影响 不要在Android应用运行的关键阶段申请内存。比如，不要在onDraw, onLayout, onXXX中创建对象。在关键阶段创建对象可能使应用出现随机性卡顿。 尽量在onCreate和onStart阶段创建对象，同时在onStop和onDestroy阶段释放对象。 尽量复用ListView中Item，在ListView滑动时不要创建对象。 降低每次GC_FOR_MALLOC的时间消耗 避免大量的，细小的对象。这些对象会增加Heap空间的复杂度，在GC时会严重影响GC的耗时。 对于不用的对象近早将其引用消除，减少Heap空间占用和复杂度。 尽量用数据结构，数组来组织对象。 明确对象之间的关系，使对象之间的依赖关系简单明了。 减少View的数量。每个View包含大量属性，对于没有交互的View，大多数的属性都是没有用的，可以用Drawable替代。 需要注意的是：本文讨论的只限于Dalvik虚拟机。对于Art虚拟机，官方文档已经表明Art虚拟机有极大的改进，其中就特别提到不用主动调用System.gc()来避免产生GC_FOR_MALLOC。 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"Android","slug":"Android","permalink":"https://ivonhoe.github.io/tags/Android/"},{"name":"Delvik","slug":"Delvik","permalink":"https://ivonhoe.github.io/tags/Delvik/"},{"name":"GC","slug":"GC","permalink":"https://ivonhoe.github.io/tags/GC/"},{"name":"转载","slug":"转载","permalink":"https://ivonhoe.github.io/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"[译]Zygote","slug":"Zygote","date":"2017-04-15T15:32:51.000Z","updated":"2018-09-11T13:30:14.000Z","comments":true,"path":"2017/04/15/Zygote/","link":"","permalink":"https://ivonhoe.github.io/2017/04/15/Zygote/","excerpt":"原文地址：Zygote https://anatomyofandroid.com/2013/10/15/zygote/ Zygote（受精卵）是一个启动应用的守护进程，在Server Manager之后被init.rc触发，但其实他是真正被app_process启动的，下面是启动这个特殊进程的流程。 1234567service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-serverclass mainsocket zygote stream 660 root systemonrestart write /sys/android_power/request_state wakeonrestart write /sys/power/state ononrestart restart mediaonrestart restart netd 你可以发现Zygote是如何当做系统服务启动的，你也可以看到app_process为什么说app_process是启动Zygote的真正命令。就像之前说的，Zygote是一个以专门启动应用为的守护进程。这意味着Zygote是所有App进程的父进程。当app_process启动Zygote时，它通过调用Zygote的main()方法创建了第一个Dalvik虚拟机。当Zygote启动后，zygote会预加载所有必须的Java类和资源，启动System Server并打开一个名为&#x2F;dev&#x2F;socket&#x2F;zygote的socket服务，去监听所有启动应用的请求。 想之前的文章所说，System Server 是一个和它的父进程完全分离的进程。一旦System Server创建完成，它会初始化一系列不同的System Services并启动Activity Manager。那Zygote是如何启动新的应用的呢？","text":"原文地址：Zygote https://anatomyofandroid.com/2013/10/15/zygote/ Zygote（受精卵）是一个启动应用的守护进程，在Server Manager之后被init.rc触发，但其实他是真正被app_process启动的，下面是启动这个特殊进程的流程。 1234567service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-serverclass mainsocket zygote stream 660 root systemonrestart write /sys/android_power/request_state wakeonrestart write /sys/power/state ononrestart restart mediaonrestart restart netd 你可以发现Zygote是如何当做系统服务启动的，你也可以看到app_process为什么说app_process是启动Zygote的真正命令。就像之前说的，Zygote是一个以专门启动应用为的守护进程。这意味着Zygote是所有App进程的父进程。当app_process启动Zygote时，它通过调用Zygote的main()方法创建了第一个Dalvik虚拟机。当Zygote启动后，zygote会预加载所有必须的Java类和资源，启动System Server并打开一个名为&#x2F;dev&#x2F;socket&#x2F;zygote的socket服务，去监听所有启动应用的请求。 想之前的文章所说，System Server 是一个和它的父进程完全分离的进程。一旦System Server创建完成，它会初始化一系列不同的System Services并启动Activity Manager。那Zygote是如何启动新的应用的呢？ Zygote 通过&#x2F;dev&#x2F;socket&#x2F;zygote(一个sockete Socket Server)接收启动应用的请求，就会触发一次fork()调用，会在另一个存储空间创建一个自身的拷贝。这个过程是很高效的。当Zygote执行fork时，它会精准创建一个预加载了应用进程所需的所有必要类和资源的Dalvik虚拟机，这样就会把创建虚拟机和加载资源的过程变得很高效。但这个设计不仅仅是这样。由于Android运行在Linux内核上，Linux Kernal实现了一个叫做Copy On Write（COW）的策略，在fork进程的过程中并不会真正的拷贝内存。一个进程想要修改这个共享的内存是，kernel会拦截这个请求，并对要修改的内存做一个拷贝。当一些Android的类库是不可写的情况下，那就意味着所有从Zygote fork出来的进程都在共享一份系统类文件和资源。另一个好处就是真的节省内存。不管启动多少应用进程在内存的增长上都会小很多。 If you are in an early stage of a porting process, Zygote is another big process that you don’t need to start. You can disable it by adding the keyword “disabled” at the end of the boot sequence in init.rc 12345678service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-serverclass mainsocket zygote stream 660 root systemonrestart write /sys/android_power/request_state wakeonrestart write /sys/power/state ononrestart restart mediaonrestart restart netddisabled 下面是一张说明Zygote在Android平台中作用的关系图(from Embedded Android)。 zygote的main()方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String argv[]) &#123; try &#123; // Start profiling the zygote initialization. SamplingProfilerIntegration.start(); registerZygoteSocket(); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis()); preload(); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis()); // Finish profiling the zygote initialization. SamplingProfilerIntegration.writeZygoteSnapshot(); // Do an initial gc to clean up after startup gc(); // Disable tracing so that forked processes do not inherit stale tracing tags from // Zygote. Trace.setTracingEnabled(false); // If requested, start system server directly from Zygote if (argv.length != 2) &#123; throw new RuntimeException(argv[0] + USAGE_STRING); &#125; if (argv[1].equals(&quot;start-system-server&quot;)) &#123; startSystemServer(); &#125; else if (!argv[1].equals(&quot;&quot;)) &#123; throw new RuntimeException(argv[0] + USAGE_STRING); &#125; Log.i(TAG, &quot;Accepting command socket connections&quot;); runSelectLoop(); closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (RuntimeException ex) &#123; Log.e(TAG, &quot;Zygote died with exception&quot;, ex); closeServerSocket(); throw ex; &#125;&#125; 通过下面代码可以看到Zygote是如何启动System Server的。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Prepare the arguments and fork for the system server process. */private static boolean startSystemServer() throws MethodAndArgsCaller, RuntimeException &#123; /* Hardcoded command line to start the system server */ String args[] = &#123; &quot;--setuid=1000&quot;, &quot;--setgid=1000&quot;, &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,3001,3002,3003,3006,3007&quot;, &quot;--capabilities=130104352,130104352&quot;, &quot;--runtime-init&quot;, &quot;--nice-name=system_server&quot;, &quot;com.android.server.SystemServer&quot;, &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; /* For child process */ if (pid == 0) &#123; handleSystemServerProcess(parsedArgs); &#125; return true;&#125; 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"翻译","slug":"翻译","permalink":"https://ivonhoe.github.io/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"Zygote","slug":"Zygote","permalink":"https://ivonhoe.github.io/tags/Zygote/"},{"name":"翻译","slug":"翻译","permalink":"https://ivonhoe.github.io/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"如何使用ddmlib dump出堆文件","slug":"how-to-dump-heap","date":"2017-04-09T11:03:01.000Z","updated":"2022-03-27T13:58:44.795Z","comments":true,"path":"2017/04/09/how-to-dump-heap/","link":"","permalink":"https://ivonhoe.github.io/2017/04/09/how-to-dump-heap/","excerpt":"一般情况下如果我想要较详细的分析内存状况，会使用android monitor(下简称monitor)和Memory Analyzer工具(下简称MAT)，但步骤有些麻烦。 使用monitor dump堆文件 使用hprof-conv工具，将hprof转换成MAT能够识别的格式 使用MAT分析 需要手动dump hprof再使用hprof-conv工具手动转码，上篇Android Bitmap的内存大小是如何计算的？说到使用square的haha来做内存堆中Bitmap的分析。所以在思考如何一键完成内存dump和analyze的过程，当然也可以任意其他Java对象做分析。如何完成dump和转码，思路还是Read the fucking source code，看下monitor是如何dump hprof文件的。打开Android sdk目录，monitor和其依赖的jar分别在/tools和’&#x2F;tools&#x2F;lib’目录，核心代码在ddmlib.jar中，Java swring代码在ddms.jar和ddmuilib.jar中，ddmlib需要依赖common.jar和guava.jar。","text":"一般情况下如果我想要较详细的分析内存状况，会使用android monitor(下简称monitor)和Memory Analyzer工具(下简称MAT)，但步骤有些麻烦。 使用monitor dump堆文件 使用hprof-conv工具，将hprof转换成MAT能够识别的格式 使用MAT分析 需要手动dump hprof再使用hprof-conv工具手动转码，上篇Android Bitmap的内存大小是如何计算的？说到使用square的haha来做内存堆中Bitmap的分析。所以在思考如何一键完成内存dump和analyze的过程，当然也可以任意其他Java对象做分析。如何完成dump和转码，思路还是Read the fucking source code，看下monitor是如何dump hprof文件的。打开Android sdk目录，monitor和其依赖的jar分别在/tools和’&#x2F;tools&#x2F;lib’目录，核心代码在ddmlib.jar中，Java swring代码在ddms.jar和ddmuilib.jar中，ddmlib需要依赖common.jar和guava.jar。 如何使用ddmlib获取adb连接的设备1234567891011121314151617181920212223242526public static void main(String[] args) &#123; IDevice device; // 这里需要传参true，不然待会会拿不到手机上的client AndroidDebugBridge.init(true); AndroidDebugBridge bridge = AndroidDebugBridge.createBridge( &quot;/Users/Ivonhoe/Library/Android/sdk/platform-tools/adb&quot;, false); waitForDevice(bridge); IDevice devices[] = bridge.getDevices(); device = devices[0]; &#125; private static void waitForDevice(AndroidDebugBridge bridge) &#123; int count = 0; while (!bridge.hasInitialDeviceList()) &#123; try &#123; Thread.sleep(100); count++; &#125; catch (InterruptedException ignored) &#123; &#125; if (count &gt; 300) &#123; System.err.print(&quot;Time out&quot;); break; &#125; &#125; &#125; 如何dump hprof这里不说看ddms源码的过程了，主要还是通过关键字搜索跟一下dump操作的处理逻辑 1234567891011121314151617181920212223242526272829303132333435363738/** * 设置HprofDumpHandler，对dump事件做监听处理dump成功或者失败的回调， * 并保存hprof文件数据 * * @param device */public HprofDump(Device device) &#123; mDevice = device; ClientData.IHprofDumpHandler hprofDumpHandler = new ClientData.IHprofDumpHandler() &#123; @Override public void onSuccess(String remoteFilePath, Client client) &#123; String hprofPath = getHprofPath(client.getClientData().getClientDescription()); mDevice.pull(hprofPath, remoteFilePath); conversionAndRemoveHprof(hprofPath); isDumping = false; &#125; @Override public void onSuccess(byte[] bytes, Client client) &#123; String hprofPath = getHprofPath(client.getClientData().getClientDescription()); Utilities.saveFile(bytes, hprofPath); conversionAndRemoveHprof(hprofPath); isDumping = false; &#125; @Override public void onEndFailure(Client client, String s) &#123; isDumping = false; &#125; &#125;; ClientData.setHprofDumpHandler(hprofDumpHandler);&#125; 这里默认选择栈顶进程做dump操作，通过adb shell dumpsys activity top命令获取栈顶TASK的ApplicationId，通过IDevice接口的getClient方法获取Client对象，执行dumpHprof操作 1234567891011121314151617181920212223/** * dump栈顶进程的hprof */public void dumpTopTaskHprof() &#123; if (isDumping) &#123; return; &#125; IDevice iDevice = mDevice.getIDevice(); /** * 这里自动选择手机上栈顶进程做dump操作，获取applicationName */ String topApp = getTopApplication(); Client client = iDevice.getClient(topApp); if (client == null) &#123; throw new RuntimeException(&quot;Can not dump app:&quot; + topApp); &#125; client.dumpHprof(); isDumping = true;&#125; 在IHprofDumpHandler的回调中, 保存hprof文件，做格式转换，分析Bitmap对象的状况。BitmapAnalyzer.java的代码在上文说过。 1234567891011121314151617181920private void conversionAndRemoveHprof(String hprofPath) &#123; String convHprofPath = getConvHprofPath(hprofPath); hprofConv(hprofPath, convHprofPath); removeFile(hprofPath); analyzerBitmap(convHprofPath);&#125;private void hprofConv(String hprofPath, String convHprofPath) &#123; String adbPath = Adb.instance().getAdbPath(); String hprofConvPath = adbPath.replace(&quot;adb&quot;, &quot;hprof-conv&quot;); ShellCommand.exec(hprofConvPath + &quot; &quot; + hprofPath + &quot; &quot; + convHprofPath);&#125;private void analyzerBitmap(String hprofPath) &#123; String[] args = new String[2]; args[0] = hprofPath; args[1] = &quot;bitmap&quot;; BitmapAnalyzer.main(args);&#125; 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"学习总结","slug":"学习总结","permalink":"https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"内存","slug":"内存","permalink":"https://ivonhoe.github.io/tags/%E5%86%85%E5%AD%98/"},{"name":"dump heap","slug":"dump-heap","permalink":"https://ivonhoe.github.io/tags/dump-heap/"}]},{"title":"Android Bitmap的内存大小是如何计算的？","slug":"Bitmap&Memory","date":"2017-03-22T11:35:36.000Z","updated":"2022-03-27T13:58:05.131Z","comments":true,"path":"2017/03/22/Bitmap&Memory/","link":"","permalink":"https://ivonhoe.github.io/2017/03/22/Bitmap&Memory/","excerpt":"一、前言本来只想说下Bitmap和内存的基本关系，但发现如果真的想把这看似简单的事情说清楚，实际上未必那么简单，你不信？不妨先尝试下回答下面几个问题！ 问1：什么是dpi？什么是dp？答：你在侮辱我？我拒绝回答！（：无辜脸 问2：以Nexus6为例，分辨率1440*2560，5.96英寸，ppi是什么？dpi是什么？1dp是多少像素？ 问3：还以Nexus6为例，一张180*180的图片，放置在设置了wrap_content属性的ImageView中，当这张图片，分别放在drawable-nodpi,drawable-mdpi,drawable-hdpi, drawable-xxhdpi,drawable-xxxhdpi这几个资源目录中，在屏幕上分别显示多大(像素)的图片？ 问4：这张图片占用的内存大小分别为多少？ 问5：如果设置ImageView的宽和高为固定的值，如50px，那么上述情况下，加载的Bitmap占用内存大小分别为多大？ 本文主要围绕上述问题，介绍Android图片资源加载的基本机制，图片的内存大小如何计算，以及内存图片分析工具。","text":"一、前言本来只想说下Bitmap和内存的基本关系，但发现如果真的想把这看似简单的事情说清楚，实际上未必那么简单，你不信？不妨先尝试下回答下面几个问题！ 问1：什么是dpi？什么是dp？答：你在侮辱我？我拒绝回答！（：无辜脸 问2：以Nexus6为例，分辨率1440*2560，5.96英寸，ppi是什么？dpi是什么？1dp是多少像素？ 问3：还以Nexus6为例，一张180*180的图片，放置在设置了wrap_content属性的ImageView中，当这张图片，分别放在drawable-nodpi,drawable-mdpi,drawable-hdpi, drawable-xxhdpi,drawable-xxxhdpi这几个资源目录中，在屏幕上分别显示多大(像素)的图片？ 问4：这张图片占用的内存大小分别为多少？ 问5：如果设置ImageView的宽和高为固定的值，如50px，那么上述情况下，加载的Bitmap占用内存大小分别为多大？ 本文主要围绕上述问题，介绍Android图片资源加载的基本机制，图片的内存大小如何计算，以及内存图片分析工具。 二、基础概念 px：像素(pixel)，指的是屏幕上的物理点，最小的独立显示单位 ppi：每英寸像素点(Pixels Per Inch)，之前我自己的理解就是使用勾股定理，通过屏幕长宽计算出对角线的长度，再除以屏幕对角线英寸值。 dpi：每英寸点(Dots Per Inch)，和ppi有什么区别？ dp：像素无关点(Density-Independent pixel)，这个Android定义的虚拟值，和px关系式是px = dp * (dpi / 160)，为啥？ ppi ppi指的是水平方向或者竖直方向上每英寸的像素值，先说为啥很多对ppi的理解都有问题。很多文章利用勾股定理计算手机屏幕对角线像素个数！！但是手机屏幕的像素分布是点阵分布，点阵的对角线像素点不是用勾股定理算出来的，而是等于它的行数或者列数，为啥用对角线计算？因为一般手机的尺寸说的就是对角线英寸值，而不知道长宽的英寸值。这里有个公式推导：设 X&#x2F;x &#x3D; Y&#x2F;y &#x3D; ppi，这里X为水平像素值，x为水平英寸值，Y为竖直像素值，y为竖直英寸值。则(X²+Y²）&#x2F;（x²+y²）&#x3D;（X&#x2F;x）²&#x3D;（Y&#x2F;y）²，这个公式可通过勾股定理和相似三角形原理证明。ppi的计算只是形式和勾股定理一样但并不是勾股定理的意思，分子也不是对角线的像素数！！ppi的计算公式可表示为：√(X²+Y²）&#x2F;对角线英寸。但不意味着ppi是使用勾股定理计算对角线像素值获得的~~ DPI、PPI、DP、PX 的详细计算方法及算法来源是什么？fsk的回答 dpi dpi是由ppi确定的，还是以Nexue6为例，通过ppi的计算公式，可以计算出Nexues6的ppi为492,参照下表，应该在xxxhdpi的范围内，但它的dpi并不是492。实际上dpi只有120(low)、160(medium)、240(high)、260、280、300、320(xhigh)、340、360、400、420、480（xxhpdi）、560、640（xxxhpi）这几种，可以参照android.util.DisplayMetrics的源码。通过getResources().getDisplayMetrics().densityDpi可以获取手机实际的dpi。 DisplayMetrics.java源码链接 dp 1dp在Nexues6上是多少像素？1dp * (560/160) = 3.5px 如何更改手机的dpi 需要root的手机 更改&#x2F;system&#x2F;build.prop中的ro.sf.lcd_density属性，这个值越小，屏幕密度越高 adb reboot 重启手机 如何快速查看手机屏幕信息 adb shell dumpsys display | findstr DisplayDeviceInfo 三、回到问题以Nexus6为例，一张180*180的图片，放在设置了wrap_content属性的ImageView中，当这张图片，分别放置在drawable-nodpi,drawable-mdpi,drawable-hdpi, drawable-xxhdpi,drawable-xxxhdpi这几个资源目录中，在屏幕上分别显示多大(像素)的图片？ 答：根据上面的分析，可以看到nexus6，是属于xxxhpi的屏幕，获取到dpi为560。如果把180大小的图片只放在xxxhdpi目录中，是不是屏幕就会显示180px的大小？其实并不是，dpi&#x3D;640的才是真正的xxxhdpi(这里需要看DisplayMetrics的源码)，当Android系统加载图片时，会针对当前系统的dpi和图片目录的source dpi比较做相应比例的缩放，如果一张图片放在drawable-xxxhdpi目录，这是告诉系统，针对dpi为640的手机屏幕上，这张图片是刚刚好的，它的scale为1.0，同理，drawable-xxhpi对应480dpi，drawable-xhdpi对应的是320dpi。如果希望180*180在nexues6的屏幕上按照原有尺寸显示，只有将其放在drawable-nodpi或者drawable-560dpi目录中才可以。 回到问题，如果将180*180放入hdpi目录中，那实际显示的图片大小应该为：int (180 * (560 / 240) +0.5f ) = 420px，实际图片的大小应该为420px！同理:放入xhdpi目录中，实际大小应该为int (180 * (560 / 320) +0.5f ) = 315px放入xxhdpi目录中，实际大小应该为int (180 * (560 / 480) +0.5f ) = 210px BitmapFactory.cpp源码链接 如果用小的Bitmap容器，放置较大的Bitmap，那这个Bitmap的尺寸大小是按照容器的大小计算？还是按照dpi缩放的规则计算？ 四、一张图片占多大内存现在我们已经知道了一张图片放置在不同的资源目录中，系统decode的bitmap的尺寸大小是如何计算的了。一张图片大概占用多少内存，其实只用看一个像素占用多少内存就可以喽？我们都知道屏幕上的颜色是有R，G，B加透明度表示的，Android官方支持的RGB格式，主要是ALPHA_8，RGB_565 ，ARGB_4444，ARGB_8888 这几种。 以ARGB_8888为例，表示一个像素点，使用8位表示透明度，8位表示Red，8位表示Green，8位表示Blue。加起来，一个像素就需要4byte，同理，RGB_565一个像素需要2byte。 1234567891011public enum Config &#123; ALPHA_8 (1), RGB_565 (3), @Deprecated ARGB_4444 (4), ARGB_8888 (5); final int nativeInt; Config(int ni) &#123; this.nativeInt = ni; &#125;&#125; Android decode资源图片时默认会选择ARGB_8888，如果将180*180放入hdpi目录中，那实际大小应该为int (180 * (560 / 240) +0.5f ) = 420px，像素内存大小为 420 * 420 * 4 = 705600byte = 689kb。同理:放入xhdpi目录中，实际大小应该为int (180 * (560 / 320) +0.5f ) = 315px，像素内存大小为315 * 315 * 4 = 396900byte = 387.6kb放入xxhdpi目录中，实际大小应该为int (180 * (560 / 480) +0.5f ) = 210px，像素内存大小为210 * 210 * 4 = 176400byte = 172.2kb 五、如何分析内存中的图片问题？说了这么多，终于到了我原本想说的。Android的内存优化需要重点关注的几个方面，Bitmap的加载，Activity的泄露，webview内存等。图片的内存问题，是很多Android应用，特别是电商APP需要首要关注的问题。那如何简单的分析出内存中Bitmap的情况，这里提供一个工具。借助leakcanary的思路，通过分析内存堆dump文件中android.graphics.Bitmap对象的情况，将内存中Bitmap对象批量保存到图片文件中，这样就可以直观的看到内存中加载的Bitmap个数、内容和大小，进而分析可能的内存问题。 示例 以分析蘑菇街APP内存中bitmap为例: 先使用Android monitor dump hprof hprof-conv做格式转换 java -jar ./bitmap-analyzer-0.0.1-SNAPSHOT.jar /Users/Ivonhoe/hprof/com.mogujie-conv.hprof 蘑菇街 参数说明： 参数1：需要处理hprof文件的绝对路径 参数2：图片输出的文件夹名称，在hprof文件目录中创建该文件夹,缺省时直接会在hprof文件目录输出文件 输出说明 大小排序.txt 按照图片像素尺寸，从大到小排序 个数排序.txt 按照相同尺寸图片个数，从大到小排序 文件名 width*height_index.png Jar包地址 https://raw.githubusercontent.com/Ivonhoe/mvn-repo/master/ivonhoe/java/heapanalyzer/bitmap-analyzer/0.0.1-SNAPSHOT/bitmap-analyzer-0.0.1-20170327.112600-1.jar 六、参考文档Android drawable微技巧，你所不知道的drawable的那些细节 关于Android适配，看完这篇文章就够了 批量导出dump文件中的Bitmap Android 开发绕不过的坑：你的 Bitmap 究竟占多大内存？ 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Bitmap","slug":"Bitmap","permalink":"https://ivonhoe.github.io/tags/Bitmap/"},{"name":"Drawable","slug":"Drawable","permalink":"https://ivonhoe.github.io/tags/Drawable/"},{"name":"内存","slug":"内存","permalink":"https://ivonhoe.github.io/tags/%E5%86%85%E5%AD%98/"}]},{"title":"Android安全之应用防dex2jar原理及实现","slug":"美团如何防dex2jar","date":"2017-02-09T13:55:01.000Z","updated":"2022-05-25T17:03:42.892Z","comments":true,"path":"2017/02/09/美团如何防dex2jar/","link":"","permalink":"https://ivonhoe.github.io/2017/02/09/%E7%BE%8E%E5%9B%A2%E5%A6%82%E4%BD%95%E9%98%B2dex2jar/","excerpt":"最近在看某外卖平台的代码，发现某外卖平台最新版本版本无法正常的通过dex2jar工具将dex转换出Java源代码，在转换过程中会提示出错，如图：","text":"最近在看某外卖平台的代码，发现某外卖平台最新版本版本无法正常的通过dex2jar工具将dex转换出Java源代码，在转换过程中会提示出错，如图： 一、反编译某平台代码 查看转换出的Java源代码，会发现很多类方法提示下图所示异常，很多方法中都会抛出RuntimeException：can not merge I and Z: 12345678910public class AsyncTaskService extends IntentService &#123; protected void onHandleIntent(Intent paramIntent)&#123; throw new RuntimeException(&quot;d2j fail translate: java.lang.RuntimeException: can not merge I and Z\\n\\tat...); &#125; public int onStartCommand(Intent paramIntent, int paramInt1, int paramInt2)&#123; throw new RuntimeException(&quot;d2j fail translate: java.lang.RuntimeException: can not merge I and Z\\n\\tat...&quot;); &#125;&#125; 查看日志文件会发现很多类似的错误信息，可以看到方法内RuntimeException栈信息和反编译的错误信息是相同的，都提示can not merge I and Z 。 二、为什么？本来以为这是dex2jar工具低版本的一个bug，但更新了dex2jar以后，依然还是会出现上述错误。java.lang.RuntimeException: can not merge I and Z这个异常，在sourceforge上解释的比较清楚，其实是一个dex2jar工具检查出的一个参数异常”，The problem is caused by strict type calculation, because in java syntaxt, a boolean can not assign to an inteager. so dex2jar forbid merge type Z and I. 你用布尔类型入参调用一个参数为整型的函数，当然会检查出错，为啥这么说，我使用apktool工具，看了一下apk的smali代码。发现报错的函数的最前面都含有一段奇怪smali的代码： 12345invoke-static &#123;&#125;, Lpnf/this/object/does/not/Exist;-&gt;a()Zmove-result v0invoke-static &#123;v0&#125;, Lpnf/this/object/does/not/Exist;-&gt;b(I)V 看上面的代码，pnf.this.object.does.not.Exist.a()方法返回一个boolean类型数据，放入v0寄存器，作为pnf.this.object.does.not.Exist.b(int)函数的入参。正常情况下这样的语法错误在java代码编译时就不会通过的。看到这里你会不会想，如果我不想别人直接看到我的Java代码，是不是可以通过在核心函数中插入上面这段有语法错误的代码，以达到dex2jar工具检查出错的目的呢？从而将代码被阅读的门槛从java提高到smali。 三、手动代码注入为了验证上面的猜想，这里我通过反编译一个apk，手动插入有语法错误的smali代码，以验证防dex2jar的思路，具体步骤如下： 1.反编译一个apk。 2.修改smali代码，插入上面这三句有语法错误的代码。 3.重打包，使用dex2jar工具转换新包的dex，看是否能正常转换出Java源代码。并检查运行时是否出错。 我这里用一个Hello World应用来测试，使用apktool反编译出smali代码，并在Application的onCreate方法中插入这段有语法错误的代码。 123456789101112131415161718# virtual methods.method public onCreate()V .locals 3 invoke-super &#123;p0&#125;, Lcn/trinea/android/lib/h/c;-&gt;onCreate()V invoke-virtual &#123;p0&#125;, Lcn/trinea/android/developertools/MyApplication;-&gt;getApplicationContext()Landroid/content/Context; move-result-object v0 invoke-static &#123;&#125;, Lpnf/object/does/not/Exist;-&gt;a()Z move-result v3 invoke-static &#123;v3&#125;, Lpnf/object/does/not/Exist;-&gt;b(I)V return-void.end method 这里不要忘了，你可能需要另外编译出Exist.smali这个文件，不然运行时一定会爆出ClassNotFound异常。将下面的Exist.java编译出Exist.smali放入相应的包路径，重打包就可以了。Java代码如下： 123456789public class Exist &#123; public static boolean a() &#123; return false; &#125; public static void b(int test) &#123; &#125;&#125; 最后，验证下果然重新打包后的apk，确实不能正常转换出Java源代码，这里就不贴图了，因为转换出错日志是一样的。并且运行时也不会出错。接下来会写一个Gradle编译插件，针对特定的函数，插入代码，防止dex2jar工具查看Java源代码。 四、实现思路Android客户端在防止其Java代码被dex2jar转换时其实就是借助dex2jar的语法检查机制，将有语法错误的字节码插入到想要保护的Java函数中里面，以达到dex2jar转换出错的目的。接下来我就大致记录下如何开发Gradle编译插件，在编译过程中实现上述防护思路，先看下Android APK打包流程： Android APK打包流程如上图所示，Java代码先通过Java Compiler生成.class文件，再通过dx工具生成dex文件，最后使用apkbuilder工具完成代码与资源文件的打包，并使用jarsigner签名，最后可能还有使用zipalign对签名后的apk做对齐处理。 如果需要完成对特定函数的代码注入，可以在Java代码编译生成class文件后，在dex文件生成前，针对class字节码进行操作，以本例为例需要动态生成Exsit类文件的字节码。 123456789// 动态生成Exist.classpublic class Exist &#123; public static boolean a() &#123; return false; &#125; public static void b(int test) &#123; &#125;&#125; 将下列Java代码转换成字节码插入需要保护的函数中。 12// 插入到特定的Java函数内Exist.b(Exist.a()); 并将修改后的.class文件放入dex打包目录中，完成dex打包，具体流程如下图所示： Gradle提供了叫Transform的API，允许三方插件在class文件转换为dex文件前操作编译好的class文件，这个API的目标就是简化class文件的自定义的操作而不用对Task进行处理，并且可以更加灵活地进行操作。详细的可以参考区长的博客。 五、使用ASM操作Java字节码ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。这里推荐一个IDEA插件:ASM ByteCode Outline。可以查看.class文件的字节码，并可以生成成ASM框架代码。安装ASM Bytecode Outline插件后，可以在Intellij IDEA-&gt;Code-&gt;Show Bytecode Outline查看类文件对应个字节码和ASM框架代码，利用ASM框架代码就可以生成相应的.class文件了。 生成Exist字节码的具体实现，生成Exist.java的构造函数： 1234567891011121314151617181920212223ClassWriter cw = new ClassWriter(0);FieldVisitor fv;MethodVisitor mv;AnnotationVisitor av0;cw.visit(51, ACC_PUBLIC + ACC_SUPER, &quot;ivonhoe/dexguard/java/Exist&quot;, null, &quot;java/lang/Object&quot;, null);cw.visitSource(&quot;Exist.java&quot;, null);mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);mv.visitCode();Label l0 = new Label();mv.visitLabel(l0);mv.visitLineNumber(7, l0);mv.visitVarInsn(ALOAD, 0);mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);mv.visitInsn(RETURN);Label l1 = new Label();mv.visitLabel(l1);mv.visitLocalVariable(&quot;this&quot;, &quot;Livonhoe/dexguard/java/Exist;&quot;, null, l0, l1, 0);mv.visitMaxs(1, 1);mv.visitEnd(); 声明一个函数名为a，返回值为boolean类型的无参函数： 123456789mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &quot;a&quot;, &quot;()Z&quot;, null, null);mv.visitCode();l0 = new Label();mv.visitLabel(l0);mv.visitLineNumber(10, l0);mv.visitInsn(ICONST_0);mv.visitInsn(IRETURN);mv.visitMaxs(1, 0);mv.visitEnd(); 声明一个函数名为b，参数为int型，返回类型为void的函数 1234567891011MV = CW.VISITmETHOD(acc_public + acc_static, &quot;b&quot;, &quot;(i)v&quot;, NULL, NULL);MV.VISITcODE();L0 = NEW lABEL();MV.VISITlABEL(L0);MV.VISITlINEnUMBER(14, L0);MV.VISITiNSN(return);L1 = NEW lABEL();MV.VISITlABEL(L1);MV.VISITlOCALvARIABLE(&quot;TEST&quot;, &quot;i&quot;, NULL, L0, L1, 0);MV.VISITmAXS(0, 1);MV.VISITeND(); 在指定函数内，插入Exist.b(Exist.a());对应的字节码的具体实现，绕过Java编译器的语法检查： 123456789101112131415161718192021222324252627282930313233343536373839static class InjectClassVisitor extends ClassVisitor &#123; private String methodName; InjectClassVisitor(int i, ClassVisitor classVisitor, String method) &#123; super(i, classVisitor) this.methodName = method; &#125; @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123; MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions); mv = new MethodVisitor(Opcodes.ASM4, mv) &#123; @Override void visitCode() &#123; // 在方法体开始调用时 if (name.equals(methodName)) &#123; mv.visitMethodInsn(INVOKESTATIC, &quot;ivonhoe/dexguard/java/Exist&quot;, &quot;a&quot;, &quot;()Z&quot;, false); mv.visitMethodInsn(INVOKESTATIC, &quot;ivonhoe/dexguard/java/Exist&quot;, &quot;b&quot;, &quot;(I)V&quot;, false); &#125; super.visitCode() &#125; @Override public void visitMaxs(int maxStack, int maxLocal) &#123; if (name.equals(methodName)) &#123; super.visitMaxs(maxStack + 1, maxLocal); &#125; else &#123; super.visitMaxs(maxStack, maxLocal); &#125; &#125; &#125; return mv; &#125; &#125; 六、总结看到这里可能你会有一个疑惑，为什么有语法错误的代码，在运行时不会出错，个人理解不单单是因为bool类型在内存中是以0或1表示，也因为int和bool在Android虚拟机中都存储在32位寄存器中，如果使用int和long类型的参数互换，在dx阶段的编译就会报错。下面是插件源码，有兴趣的同学可以尝试一下~ 插件源码详细的Gradle源码和实例可参考https://github.com/Ivonhoe/dexguard 使用方法 在root project的build.gradle中添加依赖classpath &#39;ivonhoe.gradle.dexguard:dexguard-gradle:0.0.2-SNAPSHOT&#39; 12345678910buildscript &#123; repositories &#123; maven &#123; url &#x27;https://raw.githubusercontent.com/Ivonhoe/mvn-repo/master/&#x27; &#125; mavenCentral() &#125; dependencies &#123; classpath &#x27;com.android.tools.build:gradle:2.3.0&#x27; classpath &#x27;ivonhoe.gradle.dexguard:dexguard-gradle:0.0.2-SNAPSHOT&#x27; &#125;&#125; 在app项目的build.gradle中添加插件，map.txt中配置需要保护的方法名 1234apply plugin: &#x27;ivonhoe.dexguard&#x27;dexguard &#123; guardConfig = &quot;$&#123;rootDir&#125;/map.txt&quot;&#125; 七、参考文档 #238 java.lang.RuntimeException: can not merge I and Z Smali语法 Android 热修复使用Gradle Plugin1.5改造Nuwa插件 ASM-操作字节码初探 手摸手增加字节码往方法体内插代码 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"Android安全","slug":"Android安全","permalink":"https://ivonhoe.github.io/categories/Android%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"移动安全","slug":"移动安全","permalink":"https://ivonhoe.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"},{"name":"dex2jar","slug":"dex2jar","permalink":"https://ivonhoe.github.io/tags/dex2jar/"},{"name":"Gradle","slug":"Gradle","permalink":"https://ivonhoe.github.io/tags/Gradle/"}]},{"title":"Android安全之APP去广告","slug":"android-security-how-to-remove-ads-from-app","date":"2017-02-04T05:27:20.000Z","updated":"2022-05-25T17:01:59.052Z","comments":true,"path":"2017/02/04/android-security-how-to-remove-ads-from-app/","link":"","permalink":"https://ivonhoe.github.io/2017/02/04/android-security-how-to-remove-ads-from-app/","excerpt":"","text":"一、工具介绍 apktool：google提供Android apk编译与反编译工具，https://ibotpeaches.github.io/Apktool/ dex2jar：dex文件转jar文件工具，https://github.com/pxb1988/dex2jar jd-gui：查看jar文件，http://jd.benow.ca/ keytool：制作和管理数字证书 jarsigner：使用数字证书对jar和apk进行签名 Android killer：Window系统中，上述工具的集成工具 更多反编译工具可查看：Uncle Chen—Android反编译技术总结 二、去除应用开发助手的广告CodeKK公众号在17年初推出了一个应用开发助手。V1.0版本是有广告版本的，下面以这个版本为例，简单看下去广告过程。它的后续的V1.1.0和V1.2.0已经去除了广告功能。 2.1、反编译1apktool.sh d -f ./dev-tools.apk 2.2、注释广告代码这里可以先用dex2jar转jar后查看下源码，会发现使用的是Google AdMob作为广告平台，简单看下代码可以发现在主页面activty_main.xml中包含广告视图的布局文件。所以只需要找到ad_layout.xml将其 android:visibility=&quot;gone&quot;属性设置成gone就可以了。 2.3、重打包这里重打包的过程可能会遇到一些错误，不过认真查看日志并结合Google都是可以找到解决方案的，这里暂且不表。使用apktool b命令，生成的apk默认路径为/dist路径下 1apktool.sh b ./dev-tools 2.4、制作一个名为hackapk.keystore的证书,并重新签名应用12345制作证书：keytool -genkey -keystore hackapk.keystore -keyalg RSA -validity 10000 -alias hackapk签名：jarsigner -verbose -keystore hackapk.keystore -signedjar dev-tools-no-ads.apk ./dev-tools/dist/dev-tools.apk hackapk 详细的参数可以参考：APK签名之keytool生成keystore和jarsigner签名apk 2.5、安装1adb install -r dev-tools-no-ads.apk 2.6、下载去广告版本的应用开发助手 三、反编译脚本12345678910111213141516171819202122232425#!/bin/shworkDir=./if [ &quot;$2&quot; ]then mkdir $2 workDir=./$2/fiecho $workDirname=`basename $1 .apk`zipPath=$workDir$name.zip##apkTool反编译smaliDir=$workDir$name@smaliapktool.sh d -f $1 -o $smaliDir## 解压缩，使用dex2jar处理unzipDir=$workDir$name@unzipcp $1 $zipPathunzip $zipPath -d $unzipDird2j-dex2jar.sh -f $unzipDir/classes.dex -o $&#123;workDir&#125;dex2jar.jard2j-dex2jar.sh -f $unzipDir/classes2.dex -o $&#123;workDir&#125;dex2jar2.jard2j-dex2jar.sh -f $unzipDir/classes3.dex -o $&#123;workDir&#125;dex2jar3.jaropen $workDir 将上述内容保存到本地hack.sh文件中，使用下面的命令就会把apktool和dex2jar的结果输出到meipu这个目录中，这样就不需要每次收到敲命令喽，只要知道需要反编译的apk和输出的文件夹名称就可以~ ./hack.sh ./美铺_1487845975713.apk meipu 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"Android安全","slug":"Android安全","permalink":"https://ivonhoe.github.io/categories/Android%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ivonhoe.github.io/tags/Android/"},{"name":"移动安全","slug":"移动安全","permalink":"https://ivonhoe.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"},{"name":"去广告","slug":"去广告","permalink":"https://ivonhoe.github.io/tags/%E5%8E%BB%E5%B9%BF%E5%91%8A/"}]},{"title":"Mac OS上编译Android源码","slug":"build-aosp-with-macos","date":"2017-01-20T14:16:46.000Z","updated":"2018-09-11T13:29:14.000Z","comments":true,"path":"2017/01/20/build-aosp-with-macos/","link":"","permalink":"https://ivonhoe.github.io/2017/01/20/build-aosp-with-macos/","excerpt":"一、制作一个大小写敏感的磁盘分区1.1.Mac OS磁盘工具这里我使用一块移动硬盘，将移动硬盘的一个分区使用Mac OS的硬盘工具，抹掉数据，选择MacOS扩展(区分大小写，日志式)，创建成大小写敏感的分区。 这里会遇到一个问题，抹掉分区数据的时候，会报错：“Mac OSX 抹盘发生错误:Mediakit 报告设备上空间不足以执行此操作”，这里的原因是磁盘没有大于200M的UEFI分区。","text":"一、制作一个大小写敏感的磁盘分区1.1.Mac OS磁盘工具这里我使用一块移动硬盘，将移动硬盘的一个分区使用Mac OS的硬盘工具，抹掉数据，选择MacOS扩展(区分大小写，日志式)，创建成大小写敏感的分区。 这里会遇到一个问题，抹掉分区数据的时候，会报错：“Mac OSX 抹盘发生错误:Mediakit 报告设备上空间不足以执行此操作”，这里的原因是磁盘没有大于200M的UEFI分区。 1.2.制作UEFI分区 我是在windows上操作的，使用DiskGenius工具，在移动硬盘的第一分区前部，划分出200MB的空间。在cmd命令行下运行下列命令,记得分步执行啊，小心出错，数据无价。 12345diskpartlist diskselect disk 1 ###这里选中要分区的磁盘，因为我是移动硬盘，index是1，这里应该会看到选择光标不要选错了create partition efi size=200 详细的图文请参考: Mac OSX 抹盘发生错误:Mediakit 报告设备上空间不足以执行此操作的解决办法 二、下载Android源码2.1.repo sync 出错1234error: RPC failed; result=56, HTTP code = 200&lt;br&gt;fatal: The remote end hung up unexpectedly&lt;br&gt;fatal: early EOF&lt;br&gt;fatal: index-pack failed repo sync时会出现如上错误，安装gnutls和wget后,并参考stackoverflow解决。 2.2.如何选择驱动Source Code Tags and Builds Android原生设备驱动 详细的图文请参考: Android源码的下载、编译与导入到Android Studio Mac OS X下编译Android M源码 三、编译一定要下载并安装驱动，下载nexus5 6.0.1_r17版本为例，需要下载执行下图三个sh 1234$chmod a+x ./*****.sh$./*****.sh输入I ACCEPT完成安装 12345$source build/envsetup.sh$lunch$make -j16 四、如何将编译好的Android img刷入模拟器需要设置ANDROID_PRODUCT_OUT变量到~/.bash_profile文件中 1234#Android 源码编译目录export PATH=$PATH:/Volumes/AOSP/android-6.0.1_r17-x86_64/out/host/darwin-x86/binexport ANDROID_PRODUCT_OUT=/Volumes/AOSP/android-6.0.1_r17-x86_64/out/target/product/generic_x86_64export PATH=$PATH:$ANDROID_PRODUCT_OUT 使用命令启动emulator，加载指定的kernel内核和img 123kans-MacBook-Pro:android-6.0.1_r17-x86_64 Ivonhoe$emulator -kernel /Volumes/AOSP/android-6.0.1_r17-x86_64/prebuilts/qemu-kernel/x86_64/kernel-qemu -sysdir ./out/target/product/generic_x86_64/ -system /Volumes/AOSP/android-6.0.1_r17-x86_64/out/target/product/generic_x86_64/system.img -data /Volumes/AOSP/android-6.0.1_r17-x86_64/out/target/product/generic_x86_64/userdata.img -ramdisk /Volumes/AOSP/android-6.0.1_r17-x86_64/out/target/product/generic_x86_64/ramdisk.img 参考老罗的博客在Ubuntu上下载、编译和安装Android最新源代码 五、刷入Nexus6真机Nexus6关机状态下,长按音量下+电源,进入recovery模式 然后在源码根目录下(Android根目录下)执行下面命令: 1fastboot -w flashall 使用mmm framework/base单独编译framework代码 adb push可能会提示 Read-only file system failed to copy &#39;out/target/product/shamu/system/framework/framework.jar&#39; to &#39;/system/framework/framework.jar&#39;: Read-only file system 通过下列命令解决： 123456adb rootadb remountadb disable-verityadb rebootadb rootadb remount 六、参考文档Android系统源码下载与编译、刷机–Nexus6实测 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"学习总结","slug":"学习总结","permalink":"https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"源码编译","slug":"源码编译","permalink":"https://ivonhoe.github.io/tags/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"}]},{"title":"Mac/Linux下gcc编译动态链接库[.so文件]","slug":"Mac-Linux下gcc编译动态链接库-so文件","date":"2016-12-16T05:47:55.000Z","updated":"2022-03-27T13:59:01.788Z","comments":true,"path":"2016/12/16/Mac-Linux下gcc编译动态链接库-so文件/","link":"","permalink":"https://ivonhoe.github.io/2016/12/16/Mac-Linux%E4%B8%8Bgcc%E7%BC%96%E8%AF%91%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93-so%E6%96%87%E4%BB%B6/","excerpt":"一、以bsdiff.c和bspatch.c为例编译bsdiff.sobsdiff.c和bspatch.c分别依赖bzip2 项目结构步骤 使用BsDiff.java生成BsDiff.class文件 javac ivonhoe&#x2F;spring&#x2F;wrcenter&#x2F;jni&#x2F;BsDiff.java 生成BsDiff.h文件 javah ivonhoe.spring.wrcenter.jni.BsDiff 生成bspatch.o","text":"一、以bsdiff.c和bspatch.c为例编译bsdiff.sobsdiff.c和bspatch.c分别依赖bzip2 项目结构步骤 使用BsDiff.java生成BsDiff.class文件 javac ivonhoe&#x2F;spring&#x2F;wrcenter&#x2F;jni&#x2F;BsDiff.java 生成BsDiff.h文件 javah ivonhoe.spring.wrcenter.jni.BsDiff 生成bspatch.o gcc -fPIC -D_REENTRANT -IJAVA_INCLUDE1 -I&#x2F;JAVA_INCLUDE2&#x2F; -I&#x2F;Users&#x2F;Ivonhoe&#x2F;Downloads&#x2F;VelocityDemo&#x2F;src&#x2F;main&#x2F;java&#x2F;jni&#x2F;bzip2 -I&#x2F;Users&#x2F;Ivonhoe&#x2F;Downloads&#x2F;VelocityDemo&#x2F;src&#x2F;main&#x2F;java&#x2F;jni -c .&#x2F;jni&#x2F;bspatch.c 生成bsdiff.o gcc -fPIC -D_REENTRANT -I&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_60.jdk&#x2F;Contents&#x2F;Home&#x2F;include -I&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_60.jdk&#x2F;Contents&#x2F;Home&#x2F;include&#x2F;darwin -I&#x2F;Users&#x2F;Ivonhoe&#x2F;Downloads&#x2F;VelocityDemo&#x2F;src&#x2F;main&#x2F;java&#x2F;jni&#x2F;bzip2 -I&#x2F;Users&#x2F;Ivonhoe&#x2F;Downloads&#x2F;VelocityDemo&#x2F;src&#x2F;main&#x2F;java&#x2F;jni -c .&#x2F;jni&#x2F;bsdiff.c 将bzip2下的c文件生成相应的.o文件 gcc -fPIC -D_REENTRANT -I&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_60.jdk&#x2F;Contents&#x2F;Home&#x2F;include -I&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_60.jdk&#x2F;Contents&#x2F;Home&#x2F;include&#x2F;darwin -I&#x2F;Users&#x2F;Ivonhoe&#x2F;Downloads&#x2F;VelocityDemo&#x2F;src&#x2F;main&#x2F;java&#x2F;jni&#x2F;bzip2 -c .&#x2F;jni&#x2F;bzip2&#x2F;*.c 生成so文件 *gcc .o -o bsdiff.so -shared -v 注: JAVA_INCLUDE1:&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.7.0_40&#x2F;includeJAVA_INCLUDE2:&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.7.0_40&#x2F;include&#x2F;linux是 jdk 中的 jni.h 文件的所在目录，这两个目录需要大家替换为自己的对应路径 BZIP2_INCLUDE: 参考文档：http://www.cppblog.com/deane/articles/165216.htmlhttp://blog.csdn.net/hongquan1991/article/details/12426615http://codepub.cn/2015/05/19/How-to-load-dll-file-in-Java-Web-Project/ 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"学习总结","slug":"学习总结","permalink":"https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"ndk","slug":"ndk","permalink":"https://ivonhoe.github.io/tags/ndk/"}]},{"title":"有赞、邮箱大师进度动画实现原理","slug":"android-fancy-drawable","date":"2015-09-01T15:17:29.000Z","updated":"2022-05-25T17:04:34.028Z","comments":true,"path":"2015/09/01/android-fancy-drawable/","link":"","permalink":"https://ivonhoe.github.io/2015/09/01/android-fancy-drawable/","excerpt":"","text":"有赞加载进度条四个正方形的运动可以分解成两个分运动，一个是平移运动，一个是自身的旋转运动。在实现这个动画上有两个思路： 一个是通过Android提供的Animation或者Animator操作视图，让一个正方形的视图在translate动画的同时进行rotate动画，只需要设置rotate动画的pivot坐标为视图的中心点就可以了。 另一个是直接在canvas上绘制正方形，通过canvas的坐标变换实现动画。 下面主要说第二种方式的原理： 平移：平移canvas，在平行与手机屏幕的平面坐标系中，水平向右方向为X轴，竖直向下方向为Y轴，把原点平移到视图的中心点，只需要在水平和竖直的正方向平移就可以了。 1canvas.translate(mBounds.width() / 2, mBounds.height() / 2); 旋转：想要完成一个矩形围绕其中心点顺时针旋转一个角度，首先要意识到旋转的过程中，只改变了坐标系的方向并没有改变坐标系的原点位置。换句话说，如果你需要围绕坐标系原点做旋转，那么你只需要旋转操作，如果你需要围绕除了原点以外的另外一个点（比如当前现在正方形的中心点），那么你需要先做平移操作，先把坐标系平移到一个正确的点在做旋转操作。如图所示： 123canvas.translate((float) (x + (1 - 1.414f * Math.sin((45 - degree) / 180f * Math.PI)) * halfLength),(float) (y - (1.414f * Math.cos((45 - degree) / 180f * Math.PI) - 1) * halfLength));canvas.rotate(degree);drawable.draw(canvas); 动画插值：可以看到，每个正方形的平移运动周期是从起始点回到起始点，在时间的中点上达到平移的最大值。反应在平面坐标中的情况就是，一条通过(0, 0), (0.5, 1),(1, 0)三点，在(0.5, 1)达到最大值的一元二次方程。可以间接得到这个插值器是： 1234567// 过（0,0），（0.5,1），（1,0）的一元二次方程Interpolator mInterpolator = new Interpolator() &#123; @Override public float getInterpolation(float input) &#123; return -4 * input * input + 4 * input; &#125;&#125;; 网易邮箱大师加载进度条圆弧的动画需要分解成四个分动画： 画笔宽度变化：绘制圆弧的画笔宽度在动画 圆弧长度变化：绘制圆弧的长度在动画 旋转变化：绘制每段圆弧的起点在动画 圆弧半径变化：绘制圆弧的半径在动画 123456789101112131415161718192021222324public ObjectAnimator[] getAtomAnimator(Atom atom, Rect bound) &#123; ObjectAnimator[] result = new ObjectAnimator[4]; result[0] = ObjectAnimator.ofFloat(atom, &quot;delta&quot;, 4f, 9f); result[0].setInterpolator(mPaintInterpolator); switch (atom.getId()) &#123; case 0: result[1] = ObjectAnimator.ofInt(atom, &quot;rotate&quot;, 0, 360); break; case 1: result[1] = ObjectAnimator.ofInt(atom, &quot;rotate&quot;, 120, 480); break; case 2: result[1] = ObjectAnimator.ofInt(atom, &quot;rotate&quot;, 240, 600); break; default: throw new RuntimeException(); &#125; result[1].setInterpolator(mRotateInterpolator); result[2] = ObjectAnimator.ofFloat(atom, &quot;length&quot;, 80f, 59f); result[2].setInterpolator(mPaintInterpolator); result[3] = ObjectAnimator.ofFloat(atom, &quot;r&quot;, 0, mScaleFactor * getIntrinsicWidth()); result[3].setInterpolator(mPaintInterpolator); return result;&#125; Canvas图形变换原理2.1、平移设图形上点P(x, y)，在x轴和y轴方向分别移动Tx和Ty，结果生成新的点P’(x’, y’)，则: 用矩阵形式可表示为:平移变换矩阵为： 2.2、缩放设图形上的点P(x, y)在x轴和y轴方向分别作Sx倍和Sy倍的缩放，结果生成新的点坐标P’(x’, y’)，则:用矩阵表示为：比例变换矩阵为：![ ](&#x2F;res&#x2F;android_animation2&#x2F;suofang 3.png) 2.3、旋转设点P(x, y)绕原点旋转变换θ角度(假设按逆时针旋转为正角)，生成的新的点坐标P’(x’, y’)，则：用矩阵表示为：旋转变换矩阵为： 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/categories/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/tags/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"}]},{"title":"数据解析工具","slug":"crawler-data-parser","date":"2015-08-19T13:49:49.000Z","updated":"2018-09-11T13:25:51.000Z","comments":true,"path":"2015/08/19/crawler-data-parser/","link":"","permalink":"https://ivonhoe.github.io/2015/08/19/crawler-data-parser/","excerpt":"一、设计目标 设计一个相对通用的数据解析工具，高效解析通过抓包工具抓取的网络数据内容 只需要添加少量代码，实现不同数据格式的解析，并支持不同文件格式保存 二、实施步骤总的来说，就是使用MonkeyRunner自动测试脚本对手机进行某一些具体的操作时，通过Fiddler工具截取手机App的Http通讯数据，通过对这些数据进行解析从而达到获取应用数据的过程。 2.1、编写MonkeyRunner自动脚本 环境和工具：Python，Android SDK开发环境， Android手机一台（debug选项连接PC） 脚本目标：循环对手机屏幕进行上划操作 代码：","text":"一、设计目标 设计一个相对通用的数据解析工具，高效解析通过抓包工具抓取的网络数据内容 只需要添加少量代码，实现不同数据格式的解析，并支持不同文件格式保存 二、实施步骤总的来说，就是使用MonkeyRunner自动测试脚本对手机进行某一些具体的操作时，通过Fiddler工具截取手机App的Http通讯数据，通过对这些数据进行解析从而达到获取应用数据的过程。 2.1、编写MonkeyRunner自动脚本 环境和工具：Python，Android SDK开发环境， Android手机一台（debug选项连接PC） 脚本目标：循环对手机屏幕进行上划操作 代码： 1234567#coding=utf-8from com.android.monkeyrunner import MonkeyRunner,MonkeyDevice,MonkeyImagedevice = MonkeyRunner.waitForConnection(5,&#x27;351BBJHUHDPU&#x27;)sleepTime = 0.2for x in xrange(1,10000): MonkeyRunner.sleep(sleepTime) device.drag((436,1234),(378,346),1,10) 注：MonkeyRunner.waitForConnection方法参数为adb devices 下的手机设备名 2.2、抓取应用流量信息 下载并安装需要抓取数据的Android应用 Google搜索获得Android手机设置代理上网方法，并成功设置手机通过PC代理上网功能 安装Fiddler，通过设置Fiddler host过滤可以获取固定host的HTTP Request和Response 使用MonkeyRunner测试脚本，循环触发手机上划操作，自动浏览手机应用商店的应用分类界面，通过Fiddler抓取手机的HTTP请求和响应消息内容，并导出 2.3、数据解析实现2.3.1、数据处理流程 2.3.2、使用生产者消费者模式处理数据生产者线程读取源数据文件，生产出待解析的字符串数据放入数据池中。 123456789101112131415161718192021222324252627282930/** * 生产者的生产容器 */private LinkedList&lt;Object&gt; mProductPool = new LinkedList&lt;Object&gt;();private void addProduct(List&lt;Object&gt; data) &#123; while (!data.isEmpty()) &#123; synchronized (mProductPool) &#123; while (mProductPool.size() &gt;= MAX_SIZE) &#123; try &#123; mProductPool.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; getDataProducer().startProduce(); for (int i = 0; i &lt; Math.min(MAX_SIZE, data.size()) &amp;&amp; mProductPool.size() &lt; MAX_SIZE; i++) &#123; if (!data.isEmpty()) &#123; mProductPool.add(data.get(0)); data.remove(0); &#125; &#125; mProductPool.notifyAll(); &#125; &#125;&#125; 多个消费者线程每次从数据池中获取一定数量的数据内容用来解析，并把解析结果放入最终的处理结果池中。这里并没有使用二级的消费者去做数据保存操作，因为可能需要把所有数据解析完成后做统一的分类、统计、筛选操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 消费者处理数据后的容器 */private List&lt;Unit&gt; mConsumedPool = new ArrayList&lt;Unit&gt;()；public class Consumer implements Runnable &#123; @Override public void run() &#123; while (true) &#123; List&lt;Object&gt; queue = mEngine.getProductPool(); if (queue == null) &#123; return; &#125; List&lt;Object&gt; temp = new ArrayList&lt;Object&gt;(); synchronized (queue) &#123; while (queue.size() == 0 &amp;&amp; !mEngine.isProduceComplete()) &#123; try &#123; queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); queue.notify(); &#125; &#125; int size = queue.size(); int k = Math.max(0, size - NUM_PER_CONSUME); for (int i = size - 1; i &gt;= k; i--) &#123; temp.add(queue.get(i)); queue.remove(i); &#125; queue.notifyAll(); &#125; for (Object str : temp) &#123; ArrayList&lt;Unit&gt; result = onParse((String) str); if (result != null) &#123; mEngine.addParsedUnit(result); &#125; &#125; if (mEngine.isProduceComplete() &amp;&amp; queue.isEmpty()) &#123; complete(this); Thread t = Thread.currentThread(); t.interrupt(); return; &#125; &#125; &#125;&#125; Engine.java作为整个解析过程的引擎，不同的数据需要不同的解析实现和保存格式实现,使用Reader读取数据的数据，将读取的数据填充到数据池中，当池满时，Reader线程阻塞当池空时，解析线程阻塞。在数据全部读取并解析完成之后，通过IWriter将结果保存到文件 1234567891011121314public class Engine implements IParser.ParseListener &#123; // 指定解析的数据路径 public void setSourcePath(String path) &#123;&#125; // 设置Reader public void setReader(IReader reader) &#123;&#125; // 设置解析器 public void setParser(IParser parser) &#123;&#125; // 设置Writer public void setWriter(IWriter writer) &#123;&#125; // 解析器解析完成的回调 public void onParseComplete() &#123;&#125; // 启动，开始处理数据 public void start()&#125; 三、针对第三方应用商店分类数据的解析2.1、定义不同类型的解析器在分析第三方商店数据的过程中发现，每个应用市场都会选择性的屏蔽竞品信息的行为，例如除非通过搜索功能，你很难在360应用商店看到直接百度的应用。淘宝应用商店的屏蔽行为相对较少，但是会刻意提高一些推广应用的下载排名。很难在应用商店中抓取完全的应用信息，可能需要解析一些自己手动收集的应用分类信息。 12345678910111213141516171819//做具体针对淘宝数据的JSON字符串进行数据解析public class TBParser extends IParser &#123; @Override public ArrayList&lt;Unit&gt; onParse(String source) &#123; &#125;&#125;//做具体针对360的JSON字符串进行数据解析public class QHParser extends IParser &#123; @Override public ArrayList&lt;Unit&gt; onParse(String source) &#123; &#125;&#125;// 针对自己定义的数据进行解析public class CustomParser extends IParser &#123; @Override public ArrayList&lt;Unit&gt; onParse(String source) &#123; &#125;&#125; 2.2、Zip压缩和Huffman编码数据压缩的比较针对ZIP压缩，java提供了标准的接口针对Huffman编码压缩文本的原理，可以参照这里,具体实现在工程代码在：com.ivonhoe.parser.huffman.HuffmanCode.java的实现比较发现针对字符的压缩，直接ZIP压缩比先Huffman压缩后ZIP压缩的压缩比率高。 2.3、保存文本格式保存的数据文件包含两个部分 第一部分表示各种分类数据的条目数量{健康运动:81}{通讯社交:326}{生活休闲:485}…… 第二部分表示所有的包名，按照文件开始部分的分类顺序和条目数依次保存com.hk515.patientcom.guokr.zhixingcom.yidian.health…… 如上所示，健康运动应用数量81个，分别是第二部分的181条目，通讯社交应用有326个，分别是第二部分的82408条目，依次类推。 四、针对京东商品评论数据的解析针对京东的评论数据信息，通过继承IParser的接口实现具体针对京东数据的解析方式。针对解析数据的保存，通过继承IWriter的保存接口，实现针对Excel文件格式的保存 1234567891011121314151617181920212223** * 针对JD的评论数据解析 * * @author ivonhoe */public class JDWebParser extends IParser &#123; @Override public ArrayList&lt;Unit&gt; onParse(String source) &#123; &#125;&#125;** * 通过接口保存到Excel表格中 * * @author ivonhoe */public class JDCommentWriter extends ExlWriter &#123; @Override public void onWrite(List&lt;Unit&gt; list) &#123; // TODO Auto-generated method stub exportToSheet(&quot;comments&quot;, TITLE_STRINGS, list); &#125;&#125; 五、总结 在python部分，在实现上只需要通过简单的循环让手机屏幕不停的滑动就可以了。针对移动端数据传输的特点，绝大多数的客户端应用和服务器数据传输的格式都是通过JSON或者XML。你不再需要想办法在爬取网站页面的基础上进行数据收集，不再需要考虑如何从繁杂的网页上筛选你想要的正文。通过抓包分析的方式，这就像一个漏斗，你不需要再去筛选数据。你拿到的都是格式化的数据了。 如果能够集合一些更智能的自动化测试工具如百度的MTC测试工具，录制一些特殊的操作脚本，那应该可以做更多的事情。 如果针对复杂的业务需求，可以增加二级的消费者针对数据进行进一步的处理。 针对应用分类数据的筛选，因为不同数据源的信息（如下载量）也并不是完全可信的。还需要做进一步的筛选。目前的做法是根据不同数据源进行加权平均取排名的方式（测试效果并不好），或者根据数据源的并集和应用下载量的排名综合筛选，应该可以有更好的方式。 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"学习总结","slug":"学习总结","permalink":"https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"生产者消费者模式","slug":"生产者消费者模式","permalink":"https://ivonhoe.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"数据解析","slug":"数据解析","permalink":"https://ivonhoe.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"}]},{"title":"Drawable,从简化布局谈起","slug":"android-performance-drawable","date":"2015-04-28T15:31:29.000Z","updated":"2022-05-25T16:53:47.006Z","comments":true,"path":"2015/04/28/android-performance-drawable/","link":"","permalink":"https://ivonhoe.github.io/2015/04/28/android-performance-drawable/","excerpt":"说到Drawable肯定会第一时间想到图片资源，可能有人会认为Drawable就是图片。Drawble从字面上说就是“可绘制的”，google文档的描述:“A Drawable is a general abstraction for “something that can be drawn.””，Drawable其实就是为那些”可以被绘制的’’提供的抽象类。 哪些东西是”can be drawn”？ 绘制在哪里的？","text":"说到Drawable肯定会第一时间想到图片资源，可能有人会认为Drawable就是图片。Drawble从字面上说就是“可绘制的”，google文档的描述:“A Drawable is a general abstraction for “something that can be drawn.””，Drawable其实就是为那些”可以被绘制的’’提供的抽象类。 哪些东西是”can be drawn”？ 绘制在哪里的？ 一、Drawble是干嘛的？看下android原生的Drawable和Canvas提供了的绘图的接口：android.graphics.drawableandroid.graphics.Canvas。Canvas提供了一系列的接口去实现绘制想要的图形、图片、颜色或者其他something，Drawable就是为了这些”something”提供的。 二、如何自定义Drawable？如何简化布局？ 相信一定见过类似这样的布局，在Android系统中如何把想要的图形绘制处理，一般有两种方式： 把你想要的视图简单的定义到布局文件中，系统读取布局文件绘制视图 把想要的图形通过canvas的绘图接口直接进行绘制在第二种方式中，你需要通过比如Drawable，比如自定义的View的onDraw()方法，或者调用Canvas的draw…()方法，而View的方式实际上也是Canvas绘制的方式，View也可以看做是对Canvas绘图接口的包装。而直接绘制到Canvas上的方式也单单是这些，在主线程上你可以通过调用View的invalidate()方法触发绘制，在onDraw()方法处理绘图的回调。另一种非主线程绘制的方式就是SurfaceView了。 通过Drawable绘制想要的图形是个不错的选择，Drawable是一个抽象类，draw()方法提供了绘制的Canvas，invalidateSelf()方法提供了重绘的可能。Drawable的抽象方法分别是： **draw(Canvas canvas)**将想要的东西绘制到这个canvas对象上 setAlpha(int alpha) 为drawable指定一个alpha值，0代表全透明，255代表全不透明。 setColorFilter(ColorFilter cf) 为drawable指定一个颜色过滤器 getOpacity() 获取透明度 实现自定义的Drawable只需要继承Drawable.java，并且在draw方法里通过canvas绘制需要的图形就可以了，听起来很简单。无论是一组图片、一条曲线还是一个色块，所有你想要的图形都可通过canvas参数绘制上去。举个例子，如何使用Drawable简化上图所示的网格布局？假设你需要在网格布局里显示不同的图片，就可以把场景微信朋友群组的图标。当然你可以使用view布局来做，当然也可以使用canvas方式。根据Drawable添加的顺序依次确定每个图片的坐标位置，在draw()方法里根据每个图片的坐标位置和图片显示位置绘制到canvas上。 123456789101112@Overridepublic void draw(Canvas canvas) &#123; final int N = Math.min(mChildDrawable.size(), mRowCount * mColumnCount); for (int i = 0; i &lt; N; i++) &#123; ChildDrawable itemToDraw = mChildDrawable.get(i); Drawable drawable = itemToDraw.mDrawable; if (drawable != null) &#123; itemToDraw.mDrawable.setBounds(itemToDraw.mInsetL, itemToDraw.mInsetT, itemToDraw.mInsetR, itemToDraw.mInsetB); drawable.draw(canvas); &#125; &#125;&#125; 三、让Drawable动起来怎么样？ 首先看下Drawable的Canvas从哪里来 一般使用ImageView显示drawable，看下ImageView的onDraw(Canvas canvas)，可以看到Drawable在ImageView里的绘制发生在View的onDraw回调里，根据scaleType和padding确定绘制的方式和位置。 123456789101112protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); .... // mDrawMatrix根据ImageView的ScaleType来确定的 if (mDrawMatrix == null &amp;&amp; mPaddingTop == 0 &amp;&amp; mPaddingLeft == 0) &#123; mDrawable.draw(canvas); &#125; else &#123; ...... mDrawable.draw(canvas); &#125;&#125; View绘制Background Drawable在draw(Canvas canvas)方法，并在setBackgroundDrawable时会执行background.setCallback(this)操作。 1234567891011// Step 1, draw the background, if neededif (background != null) &#123; ...... if ((scrollX | scrollY) == 0) &#123; background.draw(canvas); &#125; else &#123; ...... background.draw(canvas); ...... &#125; &#125; 再看Drawable如何重绘，Drawable是依赖Canvas绘制的，查看Drawable源码发现调用invalidateSelf()方法需要获取Callback，在Callback是空的情况下无法重绘Drawable。那么在View里如何实现Drawable的重绘，显然需要先设置Drawable的重绘回调，View.java实现了Drawable.Callback接口，在View里调用setImageDrawable()方法里会首先设置当前View为Drawable的回调。123456789101112public void invalidateSelf() &#123; final Callback callback = getCallback(); if (callback != null) &#123; callback.invalidateDrawable(this); &#125;&#125;public static interface Callback &#123; public void invalidateDrawable(Drawable who); public void scheduleDrawable(Drawable who, Runnable what, long when); public void unscheduleDrawable(Drawable who, Runnable what);&#125; ImageView调用invalidate触发重绘，回调ImageView的onDraw()方法，完成Drawable的重绘。123456789101112131415@Overridepublic void invalidateDrawable(Drawable dr) &#123; if (dr == mDrawable) &#123; /* we invalidate the whole view in this case because it&#x27;s very * hard to know where the drawable actually is. This is made * complicated because of the offsets and transformations that * can be applied. In theory we could get the drawable&#x27;s bounds * and run them through the transformation and offsets, but this * is probably not worth the effort. */ invalidate(); &#125; else &#123; super.invalidateDrawable(dr); &#125;&#125; 了解了Drawable绘制的画布和重绘的方法，如何实现动画的Drawable只需要按时重绘Drawable就可以了，用动画控制重绘效果。具体实现可以看https://github.com/Ivonhoe/FancyDrawable，现在看如何实现我在贝赛尔插值器里说过的BallsLine进度条效果，只需要在每次重绘的回调里动态的控制每个小球点的位置就可以了，需要的动画插值器参数可以参考Web代码。 protected static final long FRAME_DURATION = 1000 / 60; protected Runnable mUpdater = new Runnable() &#123; @Override public void run() &#123; onFrame(); scheduleSelf(mUpdater, SystemClock.uptimeMillis() + FRAME_DURATION); invalidateSelf(); &#125; &#125;; @Override public void start() &#123; if (!isRunning()) &#123; mIsRunning = true; // start onStart(); scheduleSelf(mUpdater, SystemClock.uptimeMillis() + FRAME_DURATION); invalidateSelf(); &#125; &#125; @Override public void stop() &#123; if (isRunning()) &#123; mIsRunning = false; unscheduleSelf(mUpdater); //stop onStop(); &#125; &#125; 五、参考文档http://developer.android.com/reference/android/graphics/drawable/Drawable.html http://developer.android.com/guide/topics/graphics/2d-graphics.html http://wiresareobsolete.com/2012/12/textdrawable-draw-some-text/ http://cyrilmottier.com/2012/11/27/actionbar-on-the-move/ http://antoine-merle.com/blog/2013/11/12/make-your-progressbar-more-smooth/ 六、Githubhttps://github.com/Ivonhoe/FancyDrawable 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/categories/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/tags/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"}]},{"title":"ColorOS和APEX桌面产品分析","slug":"ColorOS和APEX桌面产品分析","date":"2015-04-23T13:30:35.000Z","updated":"2018-09-11T13:27:47.000Z","comments":true,"path":"2015/04/23/ColorOS和APEX桌面产品分析/","link":"","permalink":"https://ivonhoe.github.io/2015/04/23/ColorOS%E5%92%8CAPEX%E6%A1%8C%E9%9D%A2%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/","excerpt":"一、桌面基本操作1.1 安装初体验 安装包大小ColorOS桌面含有两个安装包，OppoLauncher.apk(2.8M)和OppoLauncherSystem.apk(8.5KB)APEX桌面安装包大小4.36M，并且进行了代码混淆 默认桌面ColorOS桌面，前两个屏幕是系统应用，包含一个小工具的文件夹，其他所有应用平铺桌面，用户自己安装的应用从第三屏开始平铺。APEX桌面，默认的应用排列就很随意，在不同的手机上的表现有差别，应该是不同手机的系统应用的包名不同，造成APEX的预制桌面并不是顺序紧密在桌面显示应用图标。","text":"一、桌面基本操作1.1 安装初体验 安装包大小ColorOS桌面含有两个安装包，OppoLauncher.apk(2.8M)和OppoLauncherSystem.apk(8.5KB)APEX桌面安装包大小4.36M，并且进行了代码混淆 默认桌面ColorOS桌面，前两个屏幕是系统应用，包含一个小工具的文件夹，其他所有应用平铺桌面，用户自己安装的应用从第三屏开始平铺。APEX桌面，默认的应用排列就很随意，在不同的手机上的表现有差别，应该是不同手机的系统应用的包名不同，造成APEX的预制桌面并不是顺序紧密在桌面显示应用图标。 1.2 打开应用 桌面的本分无非就是帮助用户打开其他应用了，体验ColorOS和APEX的打开应用操作过程没有差别，首先是用户找到相应的应用，通过单击图标打开应用。APEX基于Android原生桌面，保留了抽屉功能，所以针对还没有添加到桌面的图标还需要先进入抽屉界面。ColorOS的另一个细节是新安装的应用图标在图标上会有类似IOS的提示，提醒用户这是一个新安装的应用，打开新安装应用后提示就消失。 1.3 移动图标和归纳文件夹 长按和拖动几乎所有的桌面产品移动图标的操作都是长按图标拖拽即可移动，ColorOS在长按时所有图标会进入抖动的模式，这点又和IOS的表现一直，同时可卸载的应用左上角会出现可删除的提示。在抖动模式下可直接卸载应用。相比APEX在长按桌面图标后会出现一个弹出的视图，上面可以进行删除、编辑图标名称、增加手势等操作。在拖动过程中，ColorOS的图标会根据拖动反响有倾斜的效果。 归纳应用到文件夹ColorOS、APEX的桌面图标合并都是基于原生Launcher的，没有本质的差别，都不支持同时合并两个文件夹。但像比较之下，ColorOS在拖动图标更换位置上支持跨屏查找位置，即当从Dock位置拖向一个排满图标的屏幕时，图标会自动向后一个屏幕寻找位置。相比其他桌面产品很少有关注这个细节的。同时ColorOS的文件夹中提供了一个“+”操作，可以批量选择桌面上的图标加入当前文件夹中，针对用户归纳应用行为避免了反复拖动和选择的操作，但是“+”操作只能针对桌面图标，已经放入其他文件夹的图标不在被选列表中，同时“+”支持把当前文件夹中的图标移出文件夹的操作，移出的图标自动放到桌面最后的位置。 1.4 卸载应用ColorOS在长按图标进入跳动模式后，可卸载图标左上角都会出现删除提示，又是IOS的痕迹。APEX卸载操作相对原生Launcher同样没有差别。好懒啊！在桌面上的图标只提供删除接口，从抽屉中长按的图标才可以删除。删除应用同样会弹出框确认。 二、用户感知2.1 图标风格和桌面主题范围 图标风格ColorOS的默认图标并没有定义应用图标的形状也没有加圆角，但是尽量保证了图标大小的统一，同时默认系统图标加了阴影，在色彩上系统默认图标以绿色和白色色调居多，因为并没有给所有的图标加背板，所以整体的感觉是辨识度很好，尽量保持了应用图标的本色。但是统一度不够，不过因为有换主题功能这点也并没有什么不好，不喜欢默认图标？间接的把用户赶向了主题商店。相比APEX的图标风格，还是一个字，“懒惰”。和原生Launcher几乎没有区别，导致三方应用的显示效果很差。 桌面主题范围ColorOS的主题范围 图标，包含背板、圆角、大小、图标内容l 壁纸，包括动态壁纸(ColorOS的一大特色)、静态壁纸l 文件夹图标背景l 页面指示指示样式 APEX:需要到google play下载 2.2 动画和声效ColorOS桌面的动画只要集中在编辑模式中，长按图标的跳动模式和下侧编辑框空间的进场动画。最有亮点的动画天气效果和其他的动态壁纸，比如默认的蒲公英会随着滑动方向飘动。在音效方面，ColorOS在用户的操作反馈上也很有特点，甚至在天气动画和音效的接合上，下雨的声音，闪电的效果，做的都很到位。更可贵的是，针对雾霾天气的显示并不是灰蒙蒙的一片并不会给人太多很压抑或者消极的暗示。 APEX的动画和声效还是用一个字形容。 2.3 用户编辑和设置针对用户编辑和设置在上面也已经提到，包括图标和文件夹的交互。还有新建屏幕方面，ColorOS依然是在编辑模式自动向后新加一个屏幕，对于APEX我表示设置项太多我还没找到。ColorOS针对用户的设置，不管是换壁纸换主题还是添加小部件，桌面都会马上程序出用户设置后的效果，并不是通过菜单项的选择或者其他设置页面的跳转来完成，所有的设置都在桌面上完成，并且几乎文字的描述，因为不需要。而相比较APEX，几乎所有的设置都是通过菜单的选择来设置完成的，因为需要同时针对桌面和应用抽屉两个界面，APEX桌面的设置范围和功能不能说不强大。几乎针对桌面所有能想到的设置项它都覆盖到了。甚至很多功能，通过名字也无法理解到底是有什么作用，只要试试才会知道，而设置的过程可能需要2~3个界面的跳转才能设置成功，预览设置效果还需要返回桌面才能看到，在体验上确实太多繁琐。所有针对这么多设置项，一个备份和恢复设置项显得有多么重要，APEX做到了。但是不得不承认，APEX桌面的设置真的是应有尽有，每一块视图区域都对应一系列的设置项，包括主屏幕设置、抽屉设置(这里还包括抽屉应有的分组分类功能)、托盘区域的设置、文件夹样式的设置、通知设置等。竟然还意犹未尽加上了所谓高级设置。我想收回上面对APEX的评价。APEX桌面真是太勤奋了…简单看下高级设置，就包括图标尺寸设置、图标文字大小设置、图标字体设置、语言设置。甚至还有主屏幕和抽屉页面的滚动速度设置。想象力不可谓不丰富。(这里我就不列举了，详细了解请下载体验。) 三、用户体验3.1 特色和附加功能说到特色，如果针对没有接触过IOS的普通低端用户，照搬IOS的模式是一个很讨巧的方式，在图标的编辑等很多方面ColorOS都有着IOS的烙印。这样也没有错，优秀的事物都是相似的。当然ColorOS称得上特色的不仅仅是这些，天气壁纸和动态壁纸结合图标的效果不可谓不惊艳。在下雨的时候图标上都有雨珠的效果，不单单是产品设置的想象力，在程序设计上也是很有难度的。结合主题的换肤功能，虽然没有太多的亮点，功能上也是中规中矩，但是在素材和资源的质量上也不错，单独就拿图标来说，免费的主题给人的感觉也不是水友随便弄弄的感觉。同时在主题功能上实现了多运营管道的接入，为更多更优质的资源提供了可能。 相对APEX桌面，最大的特色应该就是，“你看到的东西几乎都能改变”，上面已经简单列举过了。抛开用户的操作体验不说，单在程序设计的角度上说，如何组织如此多的设置功能，光是想想都有点头皮发麻，而相对与APEX桌面的流畅和稳定性，它的软件架构一定有很多能够学习的地方。可惜代码被混淆了。 3.2 流程度和内存 流畅度ColorOS在桌面滑动特效上，开始滑动的几帧可能会有掉帧的现象，而且就蒲公英动态壁纸，在滑动桌面是蒲公英的飞动效果也稍有掉帧的感觉，可能是刷新频率的问题。APEX桌面的流畅性上也是表现不错，APEX在原生桌面的交互基础上进行的开发，交互并不复杂，视图的层次和复杂度也并不复杂。 内存ColorOS桌面在一般情况内存在100M以上，增加多个专属空间空间可能会达到150M。正常情况下会在150M以下。APEX桌面启动之后的内存占有在40M左右，正常使用情况下在60M左右。相比较一个hello world都可能分配10M的内存，这样的内存占用率已经很不错了。不过毕竟APEX桌面的动画和视图并不算复杂，这样的占有率也在情理之中。 四、反编译分析分析结果暂无。 五、我的看法ColorOS桌面和APEX桌面在产品思路上是完全不同的方向。一个在尽力讨好用户，尽力把特效和交互做炫，它尽力告诉用户什么样是比较好的，针对国内市场确实算很有特色也很有卖点。而对比其他优秀桌面产品在很多交互上也难免有很多相似之处，当然这并不可怕，可怕的是别人有的我也有，别人有的我没有。还好ColorOS迈过了这道坎，动态壁纸的效果也证明了ColorOS桌面足够优秀。那这么好的效果为什么没有引起别人跟风？（事实上也不是没有，TCL就跟过）。代码都没有加混淆，搞过来应该不难。但是伴随着酷炫的视觉效果背后，躲不开的就是内存和功耗问题，这个可想而知，在体验OPPO手机的过程中，最大的感受就是充电太慢了，电池太不够用。面对开放市场的桌面功耗和内存是必不可少的考核条件。（此处省略一万字）。在另一方面，APEX桌面，尽量做的讨巧，本身原生Launcher的交互和稳定性并不差。国内桌面产品之所以拼的你死我活，无法就是避免同质化。避免和别人一样，保持自己的特点成了很大的一个因素。而APEX也同样懂得这个道理，但是它的方式不太一样，它在避免和别人相同的道路上把更多的选择权交给了用户，给用户提供了各式的设置接口，并且提供了设置备份的功能。也是用心良苦，但是在组织如此多设置接口的方式上也是让人很痛的，太累，我太懒，来不及去探索属于自己更多的可能。 六、对于桌面产品的启发 做好第一感觉第一感觉，安装包的大小，默认桌面图标的设置。能否真正适配不同厂商手机，就拿Phone这个应用来说，不同厂商的包名可能千差万别，能否有合适的方法，让它在每一台手机上都放在正确的位置。从用户已有的桌面中获取用户已有的桌面配置是不是更好？如何做到？在用户第一次使用的时候是否应该给类似分类和相关冷启动的向导，这样会不会更好？还有很多未知！！ 流畅和性能永远是重点,轻 我们的亮点在哪？我们的痛点在哪？我们产品的设计原则是什么？ 如果我们想要做一个优秀的产品，那请先说服自己，先让自己人都喜欢上我们的产品 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"学习总结","slug":"学习总结","permalink":"https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"产品分析","slug":"产品分析","permalink":"https://ivonhoe.github.io/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"}]},{"title":"基于贝塞尔曲线的Android动画差值器","slug":"android-bezier-interpolator","date":"2015-04-17T02:35:05.000Z","updated":"2022-05-25T16:52:07.003Z","comments":true,"path":"2015/04/17/android-bezier-interpolator/","link":"","permalink":"https://ivonhoe.github.io/2015/04/17/android-bezier-interpolator/","excerpt":"贝塞尔曲线于1962，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau算法开发，以稳定数值的方法求出贝兹曲线。贝塞尔曲线不仅仅可以应用到工业设计中，在计算机动画开发中同样占有一席之地，通过构造贝塞尔曲线模拟物体运动的轨迹、速度甚至加速度，来达到想要的动画效果。在CSS开发中使用‘cubic-bezier’方法，传递三次贝赛尔曲线的两个控制点P1和P2来生成一条平滑的曲线。甚至也有很多javaScript动画库使用贝赛尔曲线来实现完美的动画效果。","text":"贝塞尔曲线于1962，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau算法开发，以稳定数值的方法求出贝兹曲线。贝塞尔曲线不仅仅可以应用到工业设计中，在计算机动画开发中同样占有一席之地，通过构造贝塞尔曲线模拟物体运动的轨迹、速度甚至加速度，来达到想要的动画效果。在CSS开发中使用‘cubic-bezier’方法，传递三次贝赛尔曲线的两个控制点P1和P2来生成一条平滑的曲线。甚至也有很多javaScript动画库使用贝赛尔曲线来实现完美的动画效果。 一、简介 而我要做的通过贝塞尔曲线的原理生成Android动画插值器，在Android平台上实现基于贝赛尔曲线的动画效果。想要了解Android动画原理请先阅读这篇文章。了解贝塞尔曲线绘制过程可以先阅读贝塞尔曲线扫盲，写的很好。 二、De Casteljau算法 贝塞尔曲线常见的算法是可以通过多项式、De Casteljau算法和递归算法来进行计算。针对De算法，设P0,P1,P2确定了一条二次贝塞尔曲线q，引入参数t，令即有： 当t从0变到1，第一、二式是两条一次Bezier曲线。将一、二式代入第三式得到： 当t从0变到1时，它表示了由P0、P1、P2三个控制点形成一条二次Bezier曲线。并且这个二次Bezier曲线可以分别由前两个顶点(P0,P1)和后两个顶点(P1,P2)决定的一次Bezier曲线的线性组合。以此类推，由四个控制点定义的三次Bezier曲线可被定义为分别由(P0,P1,P2)和(P1,P2,P3)确定的两条二次Bezier曲线的线性组合，由(n+1)个控制点定义的n次Bezier曲线可被定义为分别由前后n个控制点定义的两条(n-1)次Bezier曲线的线性组合： 由此得到Bezier曲线的递推计算公式: 这就是De Casteljau算法。使用这个递推公式，在给定参数下，求Bezier曲线上一点P(t)非常有效。 三、Bezier动画插值器实现基于De Casteljau算法的递推公式求曲线上点的坐标： public static Point deCasteljau(Point[] points, float t) &#123; final int n = points.length; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt; n - i; j++) &#123; points[j].x = (1 - t) * points[j].x + t * points[j + 1].x; points[j].y = (1 - t) * points[j].y + t * points[j + 1].y; &#125; return points[0]; &#125; De Casteljau算法目的是求得曲线上的每一个点，如何用这些采样点描述一条曲线插值器还需要进一步的处理。主要就是处理精度的问题，用距离很近的两个点连线的线段近似描述曲线，理论上采样点越密集描述的越准确，但是很明显在实际项目中不能选择太多的采样点，因为要考虑内存和效率的问题。所以用尽可能少的点尽可能精细的用直线段描述一条曲线，一个不错的做法就是在采样点的在横坐标方向上不要等距分布，而是在曲线变化较快的地方（即斜率较大）采样点尽可能的密集，而在曲线变化平缓的地方采样点选择稀疏。所以需要在通过De Casteljau算法获取初步的采样点后，再进一步获取非均匀分布的采样点，更加处理后的采样点再进行计算。 考虑到针对不同动画的编辑，可能不仅仅是动画进度的插值，还需要动画速度的插值和动画变化率的插值，针对不同曲线类型的变化，通过下面的方式进行扩展。详细代码可以查看这里 四、使用范例通过控制点构造贝塞尔曲线插值器，例如，可以通过构造一个特殊的插值器，控制drawable的重绘和每个小球的动画并重绘drawable就可以实现类似window phone上经典的Balls Line进度条效果，详细实现可以参考这里。 通过两个控制点构造三次贝赛尔插值器(默认会增加(0,0)和(1,1)作为控制点)。 if (mBezierInterpolator == null) &#123; // 贝塞尔插值器 mBezierInterpolator = new BezierInterpolator(0.03f, 0.615f, 0.995f, 0.415f); &#125; if (mLinearInterpolator == null)&#123; // 普通线性插值器 mLinearInterpolator = new LinearInterpolator(); &#125; 同样可以传递包含所有控制点的List构造插值器。 mBezierInterpolator = new BezierInterpolator(new ArrayList&lt;Point&gt;()); 针对BezierInterpolator的构造会有一定的耗时，所以并不建议在需要用到的时候才去构造，也不建议频繁的构造相同的插值器实例。 五、参考文档3D计算机图形学 Samuel R.BussBezier曲线的算法描述及其程序实现在线贝塞尔曲线编辑器window phone loading animation 六、Githubhttps://github.com/Ivonhoe/BezierInterpolator 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/categories/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/tags/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"}]},{"title":"[译]Context?什么是Context？","slug":"what-is-context","date":"2015-04-08T03:06:31.000Z","updated":"2018-09-11T13:24:36.000Z","comments":true,"path":"2015/04/08/what-is-context/","link":"","permalink":"https://ivonhoe.github.io/2015/04/08/what-is-context/","excerpt":"原文地址：http://possiblemobile.com/2013/06/context/ Context可能是Android应用中最常用的元素也是最容易误用的元素Context是经常被传递的对象，它可以很容易的构造一个你意想不到的情景，如加载资源，启动一个新的Activity，得到一个系统服务，得到内部文件路径和创建视图都需要一个Context去完成这个工作，我接下来为你在Context到底是如何工作的和为你能在你的应用中更好的运用Context提供建议。","text":"原文地址：http://possiblemobile.com/2013/06/context/ Context可能是Android应用中最常用的元素也是最容易误用的元素Context是经常被传递的对象，它可以很容易的构造一个你意想不到的情景，如加载资源，启动一个新的Activity，得到一个系统服务，得到内部文件路径和创建视图都需要一个Context去完成这个工作，我接下来为你在Context到底是如何工作的和为你能在你的应用中更好的运用Context提供建议。 Context类型并不是所有的Context实例都是相同的，对于不同的Android应用组件，Context会有一些差别。 ApplicationApplication 是应用进程中的一个单例，它可以通过Activity或者Service的getApplication()方法或者从Context派生出的其他对象调用getApplicationContext()方法得到，在同一个进程里任意时刻你得到的都是相同的Application实例。 Activity和ServiceActivity和Sevice继承ContextWrapper，而ContxtWrapper同样实现了Context的接口，但是ContextWrapper的所有的方法都是通过包装一个内部context对象实现的，也就是它的base context（注：看ContextWrapper源码，ContextWrapper顾名思义就是Context的包装，ContextWrapper的实际功能都是成员变量mBase完成的，ContextThemeWrapper集成ContextWrapper，增加了Theme和Configuration作为成员变量，Activity继承ContextThemeWrapper，所以说Activity才是唯一包含主题信息的context。详细见下文）。当framework创建一个新的Activity或者Service的实例时，也会创造一个新的ContextImpl实例去真正完成context的实际功能，每一个Activity或者服务，和他们相应的base context，都是不同的context实例。 BroadcastReceiverBroadcastReceiver本身并不是Context，但是当广播事件传递的时候，framework都会在onReceive()方法中传递一个Context。这个Context是一个ReceiverRestrictedContext实例（注：看ContextImpl的getReceiverRestrictedContext()方法），它的registerReceiver()和bindService()方法是失效的，这两个功能是不允许通过onReceive()方法传递的Context调用的，（每次receiver处理一个广播，都会创建一个新的context实例。) ContentProviderContentProvider同样也不是Context，但是已被创建就可以活取getContext方法，如果ContentProvider和调用者在同一个进程，那会返回相同的Application实例，如果在两个单独的进程里，getContext()会返回一个新创建的Context，代表这个provider进程的Context。（注：可以阅读ActivityThread.java中的installProvider()和ContentProvider的attachInfo()方法，installProvider方法会根据provider的包名和当前进程名进行比较，如果是同一个进程那就使用当前的application context，如果在不同的进程中，就会调用createPackageContext创建一个provider相关的Context，并通过attachInfo绑定provider）。 保存引用我们首先关注的问题是，当我们在一个对象或者类里面保存一个context的引用，但是这个对象或者类的生命周期超过了你保存的context实例的生命周期。例如，创建需要一个Context对象去加载资源或者去调用CotentProvider，保存当前Activity或者Service的引用在这个单例中。 失败的单例： public class CustomManager &#123; private static CustomManager sInstance; public static CustomManager getInstance(Context context) &#123; if (sInstance == null) &#123; sInstance = new CustomManager(context); &#125; return sInstance; &#125; private Context mContext; private CustomManager(Context context) &#123; mContext = context; &#125; &#125; 这里的问题是我们并不知道这个Context从哪里来，当持有一个结束的Activity或者Service是不安全的，这是因为在这个类里的单例是一个静态引用。这意味着我们引用的对象包括所有被这个对象引用的对象都不会被垃圾回收。如果这个Context是一个Activity，那么就会造成这个Activity引用的所有视图和其他可能跟它关联的对象持续占有内存，造成内存泄露。 为了防止这种情况，我们把这个单例修改成引用appliction context。 修改后的单例： public class CustomManager &#123; private static CustomManager sInstance; public static CustomManager getInstance(Context context) &#123; if (sInstance == null) &#123; //Always pass in the Application Context sInstance = new CustomManager(context.getApplicationContext()); &#125; return sInstance; &#125; private Context mContext; private CustomManager(Context context) &#123; mContext = context; &#125; &#125; 现在不用关心这个Context是什么，因为现在持有的引用是安全的。Application context本身就是一个单例，我们只是创建另一个静态引用并不会造成内存泄露。另一个类似例子就是在一个后台的线程或者等待的Handler里持有一个Context引用。既然这样那我们为什么总是引用一个application context呢？我们就永远不用担心内存泄露的问题。答案当然是不可以，就想我在前面提到的那样，每种类型的Context类型都不相同。 Context的功能我们安全的调用Context的方法取决于这个Context是如何创建的，下面的表是Context功能的使用情况： Application Activity Service ContentProvider BroadcastReceiver Show a Dialog NO YES NO NO NO Start an Activity NO1 YES NO1 NO1 NO1 Layout Inflation NO2 YES NO2 NO2 NO2 Start a Service YES YES YES YES YES Bind to a Service YES YES YES YES NO Send a Broadcast YES YES YES YES YES Register BroadcastReceiver YES YES YES YES NO3 Load Resource Values YES YES YES YES YES 注：1.一个application可以启动一个Activity，但是需要创建一个新的任务。这样做可能满足一些特定的需求，但是在应用中创建一个非标准的回退栈并不是一种经过深思熟虑的推荐做法。2.这样是合法的，但是这样是加载出来的系统默认的主题布局，而并不是你在应用里定义的主题样式。3.在receiver是null的情况下是允许的（注：看ContextImpl的内部类ReceiverRestrictedContext，ReceiverRestrictedContext进程ContentWrapper但是重写了注册广播和绑定服务的方法，会在这两个方法里抛出异常。为什么要这么做？），在4.2以上版本用来获取粘性广播。 用户接口从上个表格你可以看出，有很多和UI处理相关的Context的功能并不适合用application context去处理。事实上，实现了所有和所有UI相关的操作接口的是Activity，而其他的类别的功能都几乎相同。幸运的是这三个操作（注：指Application context不具备的三个Context功能）是application在Activity范围之外根本不需要去做的，这好像就是framework故意设计如此，如果你尝试通过一个application context去创建一个对话框或者启动一个Activity会抛出异常并造成应用程序终止，会有明显的指示告诉你这样出错了。另一个值得注意的问题是加载布局，如果你阅读过我的文章layout inflation,你会觉得这个过程会是稍微难理解的过程，使用正确的context就算一个。当你使用通过application context构造的LayoutInflater去加载视图，当然framework同样会返回一个正确的视图树，但是你在应用中设置的主题和样式是被忽略的，这是因为Activity才是真正关联你在manifest中设置的主题的Context。其他类型的Context实例会使用系统默认的主题样式去构建视图。所以这样构建出的视图可能并不是像你预期的那样。 交集一定会有人得到这样的冲突的结论，在应用设计中会有一种情况，可能必须长期持有一个Activity Context引用，因为我想完成的任务包含UI的操作。如果是这样的话，那我只能强烈建议你重新考虑你的设计，因为那样的设计将是和Android应用架构背道而驰的过程。 总结在大多数情况下，使用你当前封闭的组件中直接使用Context就是可以了，只有你持有引用不超过这个组件的生命周期就不会有问题，只要你需要保存一个Context的引用超出Activity或者Service的生命周期，哪怕是暂时的引用，那就请转换成保存application context的引用。 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"翻译","slug":"翻译","permalink":"https://ivonhoe.github.io/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://ivonhoe.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Android","slug":"Android","permalink":"https://ivonhoe.github.io/tags/Android/"},{"name":"Context","slug":"Context","permalink":"https://ivonhoe.github.io/tags/Context/"}]},{"title":"动画源码分析（基于Android 5.0）","slug":"android-animation-source","date":"2015-03-03T14:48:07.000Z","updated":"2022-05-25T16:50:53.689Z","comments":true,"path":"2015/03/03/android-animation-source/","link":"","permalink":"https://ivonhoe.github.io/2015/03/03/android-animation-source/","excerpt":"想要实现动画无非想做一件事情，就是把动画的对象在合适的时间画出合适的状态，如何控制时间？就是通过补间动画或者属性动画设置动画的时长、起始时间、起始延迟这些属性来控制动画的时间。如何控制动画状态？就可以通过动画插值，插值方法getInterpolation(input),input就是当前动画运行时间的百分比，而函数返回值就是当前动画的进度百分比，通过动画进度和动画的起始状态和结束状态来控制动画对象的当前状态。无论是补间动画或者属性动画都是定义动画状态的起始状态、终止状态、动画多久、如何动画。","text":"想要实现动画无非想做一件事情，就是把动画的对象在合适的时间画出合适的状态，如何控制时间？就是通过补间动画或者属性动画设置动画的时长、起始时间、起始延迟这些属性来控制动画的时间。如何控制动画状态？就可以通过动画插值，插值方法getInterpolation(input),input就是当前动画运行时间的百分比，而函数返回值就是当前动画的进度百分比，通过动画进度和动画的起始状态和结束状态来控制动画对象的当前状态。无论是补间动画或者属性动画都是定义动画状态的起始状态、终止状态、动画多久、如何动画。 0x01 补间动画源码先找到动画执行的入口View.startAnimation(animation)，startAnimation执行了invalidate，触发了重绘刷新视图界面。 123456public void startAnimation(Animation animation) &#123; animation.setStartTime(Animation.START_ON_FIRST_FRAME); setAnimation(animation); invalidateParentCaches(); invalidate(true);&#125; invalidate()触发执行View.draw(Canvas canvas, ViewGroup parent, long drawingTime)函数 调用动画的 getTransformation 方法，得到当前时间点的矩阵 将该矩阵设置成 Canvas 的当前矩阵 调用 canvas 的 drawBitmap 方法，绘制屏幕 判断 getTransformation 的返回值，若为真，调用 invalidate 方法，刷新屏幕进入下一桢；若为假，说明动画完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; ...... // 如果有需要执行的动画 final Animation a = getAnimation(); if (a != null) &#123; // 根据动画和当前时间计算Transformation，并返回是否需要再继续做动画 more = drawAnimation(parent, drawingTime, a, scalingRequired); concatMatrix = a.willChangeTransformationMatrix(); if (concatMatrix) &#123; mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM; &#125; // 得到动画的变换结果 transformToApply = parent.mChildTransformation; &#125; else &#123; ...... &#125; ...... float alpha = useDisplayListProperties ? 1 : getAlpha(); if (transformToApply != null || alpha &lt; 1 || !hasIdentityMatrix() || (mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) &#123; ...... // 根据Transformation值变换canvs if (transformToApply != null) &#123; if (concatMatrix) &#123; if (useDisplayListProperties) &#123; displayList.setAnimationMatrix(transformToApply.getMatrix()); &#125; else &#123; // Undo the scroll translation, apply the transformation matrix, // then redo the scroll translate to get the correct result. canvas.translate(-transX, -transY); canvas.concat(transformToApply.getMatrix()); canvas.translate(transX, transY); &#125; parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION; &#125; float transformAlpha = transformToApply.getAlpha(); if (transformAlpha &lt; 1) &#123; alpha *= transformAlpha; parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION; &#125; if (!childHasIdentityMatrix &amp;&amp; !useDisplayListProperties) &#123; canvas.translate(-transX, -transY); canvas.concat(getMatrix()); canvas.translate(transX, transY); &#125; &#125; ...... &#125; if (a != null &amp;&amp; !more) &#123; if (!hardwareAccelerated &amp;&amp; !a.getFillAfter()) &#123; onSetAlpha(255); &#125; parent.finishAnimatingView(this, a); &#125; // 根据动画进度判断是否需要继续重绘 if (more &amp;&amp; hardwareAccelerated) &#123; // invalidation is the trigger to recreate display lists, so if we&#x27;re using // display lists to render, force an invalidate to allow the animation to // continue drawing another frame parent.invalidate(true); if (a.hasAlpha() &amp;&amp; (mPrivateFlags &amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) &#123; // alpha animations should cause the child to recreate its display list invalidate(true); &#125; &#125; mRecreateDisplayList = false; return more;&#125; 0x02 属性动画源码onsync时序图： 从ObjectAnimator的start()方法开始,跳转到父类ValueAnimator的start()方法，为了减少篇幅，这里的代码就不贴出来了，详细的代码可以查看从ObjectAnimator.java。 12345678@Overridepublic void start() &#123; // See if any of the current active/pending animators need to be canceled // 这里先判断当前的动画、等待的动画和延迟执行的动画和this去比较，如果动画的目标对象相同并且属性相同就取消相同的动画。 ...... super.start();&#125; ValueAnimator的start(boolean)方法只是做了两件事：1.把当前的animator加入等待队列中，2.启动animationHandler。AnimationHandler并不是一个Handler，而是Runnable。 123456789101112131415161718 private void start(boolean playBackwards) &#123; if (Looper.myLooper() == null) &#123; throw new AndroidRuntimeException(&quot;Animators may only be run on Looper threads&quot;); &#125; ...... AnimationHandler animationHandler = getOrCreateAnimationHandler(); animationHandler.mPendingAnimations.add(this); if (mStartDelay == 0) &#123; // This sets the initial value of the animation, prior to actually starting it running setCurrentPlayTime(0); mPlayingState = STOPPED; mRunning = true; notifyStartListeners(); &#125; animationHandler.start();&#125; 将AnimationHandler对象传递给Choreographer(编舞者)，Choreographer是和线程绑定的单例。告诉编舞者，我是一个CALLBACK_ANIMATION(动画类型)，你自己看着办吧。 123456private void scheduleAnimation() &#123; if (!mAnimationScheduled) &#123; mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, this, null); mAnimationScheduled = true; &#125; &#125; 编舞者根据callbackType(就是上面的CALLBACK_ANIMATION类型)，把当前的action(就是animationHandler)加入相应类型的Callback队列等待被执行。并且安排下一帧的时间。 12345678910111213141516171819private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; // 加入相应类型的Callback队列等待被执行 mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125; &#125; 如果使用Vsync，通过FrameDisplayEventReceiver的scheduleVsync方法，申请一次VSYNC中断，这样就可以在中断处理的onVsync函数去进行绘制。如果不需要直接发送MSG_DO_FRAME消息。 12345678910111213141516171819202122232425private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123; // If running on the Looper thread, then schedule the vsync immediately, // otherwise post a message to schedule the vsync from the UI thread // as soon as possible. // 如果使用VSYNC就申请一次中断请求 if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); // 如果不是要VSYNC，就直接触发MSG_DO_FRAME Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125; 上面注册一个了reciver，在VSYNC发生的时候接受到消息，就会触发onVsync方法,执行当前的FrameDisplayEventReceiver Runnable。 123456789101112public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; ...... Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);&#125;@Overridepublic void run() &#123; mHavePendingVsync = false; doFrame(mTimestampNanos, mFrame);&#125; 我们看doFrame方法做了什么？调用doCallbacks方法，获取当前类型的等待序列中在当前时间的callback，得到action并执行run方法，在这里callback的action就是AnimationHandler。 1234567891011121314151617181920212223242526272829303132 void doFrame(long frameTimeNanos, int frame) &#123; ...... // 优先级最高，和输入事件处理有关 doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); // 优先级其次，和Animation的处理有关 doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); // 优先级最低，和UI等控件绘制有关 doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);&#125;void doCallbacks(int callbackType, long frameTimeNanos) &#123; CallbackRecord callbacks; synchronized (mLock) &#123; // We use &quot;now&quot; to determine when callbacks become due because it&#x27;s possible // for earlier processing phases in a frame to post callbacks that should run // in a following phase, such as an input event that causes an animation to start. final long now = SystemClock.uptimeMillis(); callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now); if (callbacks == null) &#123; return; &#125; mCallbacksRunning = true; &#125; try &#123; for (CallbackRecord c = callbacks; c != null; c = c.next) &#123; // 在这里回调callback的action c.run(frameTimeNanos); &#125; &#125; ......&#125; 终于回调了AnimationHandler的run方法，代码很多，起始无非就是让应该启动的animation启动起来，该延迟的放在延迟队列，正在做动画的调用doAnimationFrame方法，动画播放结束的就结束动画。当然如果还需要继续动画那就继续调用scheduleAnimation方法，告诉编舞者，还有呢，继续在下个帧时间执行我。当然所有时间控制是根据VSYNC回调上来的时间和每个动画的时间信息共同控制的。 123456789101112131415 private void doAnimationFrame(long frameTime) &#123; ...... for (int i = 0; i &lt; numAnims; ++i) &#123; ValueAnimator anim = mTmpAnimations.get(i); if (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime)) &#123; mEndingAnims.add(anim); &#125; &#125; ...... // If there are still active or delayed animations, schedule a future call to // onAnimate to process the next frame of the animations. if (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) &#123; scheduleAnimation(); &#125;&#125; 0x03 动画源码总结1.针对视图来说，Animation和Scroller相似，都是如何控制视图的重绘，它们都指示定义了在某一个特定时刻我应该画成什么样子。2.Choreographer实际上是视图所有重绘进度的实际控制者，因为它在控制着时间节奏，告诉应用们什么时间可以画，视图不需要自己控制刷新时间。3.回头看Animation的源码分析，视图的重绘最终是触发ViewRootImpl的invalidate函数，该函数将最终调用ViewRootImpl的scheduleTraversals。同样是通过mChoreographer只是类型变成了CALLBACK_TRAVERSAL，代码如下所示： 123456789101112void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); &#125;&#125; 4.Asynchronous Message和Synchronization Barrier我还没有理解，当你觉得自己明白了的时候，其实你还有很多不知道，当你觉得你不明白的时候，那是你真的不知道。不知道还是不知道！！ 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/categories/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/tags/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"}]},{"title":"Android launcher文件夹动效总结","slug":"android-animation","date":"2015-02-09T11:40:53.000Z","updated":"2022-05-25T17:05:19.750Z","comments":true,"path":"2015/02/09/android-animation/","link":"","permalink":"https://ivonhoe.github.io/2015/02/09/android-animation/","excerpt":"这篇文档记录了一下自己在实际工作中实现的一些Android动画效果时的开发思路，总结了我自己如何看待Android动画问题，希望能给大家的动画开发提供一些思路和帮助。","text":"这篇文档记录了一下自己在实际工作中实现的一些Android动画效果时的开发思路，总结了我自己如何看待Android动画问题，希望能给大家的动画开发提供一些思路和帮助。 一、Android动画基础1.1 动画类型 Frame Animation：帧动画，顺序播放事先做好的图像，是一种画面转换动画 Tween Animation:补间动画（或者叫渐变动画），通过对场景里的对象不断做图像变换(平移、缩放、旋转)产生动画效果 Property Animation:属性动画，通过动态地改变对象的属性从而达到动画效果，属性动画为API 11新特性 1.2 帧动画：是指顺序执行预先设置好的一组图片，类似电影胶片的形式，设置每一帧drawable，在java代码中加载资源生成一个AnimationDrawable对象。例如：在xml中配置spin_animation.xml在文件夹res&#x2F;drawable&#x2F;中： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot; &gt; &lt;item android:drawable=&quot;@drawable/p1&quot; android:duration=&quot;1000&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/p2&quot; android:duration=&quot;1000&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/p3&quot; android:duration=&quot;1000&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/p4&quot; android:duration=&quot;1000&quot;&gt;&lt;/item&gt; &lt;/animation-list&gt; 加载资源并应用： // Load the ImageView that will host the animation and // set its background to our AnimationDrawable XML resource. ImageView img = (ImageView)findViewById(R.id.spinning_wheel_image); img.setBackgroundResource(R.drawable.spin_animation); // Get the background, which has been compiled to an AnimationDrawable object. AnimationDrawable frameAnimation = (AnimationDrawable) img.getBackground(); // Start the animation (looped playback by default). frameAnimation.start(); 1.3 补间动画：补间动画有四种动画形式，分别是: alpha 渐变透明度动画效果 scale 渐变尺寸伸缩动画效果 translate 画面位置移动动画效果 rotate 画面旋转动画效果 可以和帧动画一样在xml中配置动画，例如旋转动画rotate.xml，设置起始和终止的角度，动画中心的相对位置，动画时长等。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fillAfter = &quot;false&quot; android:zAdjustment=&quot;bottom&quot; &gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:toDegrees=&quot;360&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:duration=&quot;4000&quot; /&gt; &lt;/set&gt; 使用AnimationUtils加载动画的xml文件生成Animation的实例，也可以在JAVA代码中构造补间动画 // 加载xml构造Animation Animation anim = AnimationUtils.loadAnimation(mContext, R.anim.rotate); // 不通过xml构造 Animation rotate = new RotateAnimation(0.0f, +360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); 1.4 属性动画：补间动画只能应用于视图(View)对象，动画的方式也仅限于上面所说的四种方式，而属性动画可以应用于所有的Object对象，它通过改变对象的属性值完成动画效果，当然前提是需要有该属性的get和set方法，通过在动画的过程中调用get和set方法改变对象的属性值来完成动画效果。例如通过ObjectAnimator指定要改变的对象和属性名称： ObjectAnimator animator = ObjectAnimator.ofInt(testObject, &quot;data&quot;, 0, 10); animator.start(); private class TestObject &#123; private int data; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; &#125; 当然也通过ValueAnimator，不需要指定属性名更灵活，设置AnimatorUpdateListener，在动画更新的回调中完成想要的动作，例如，在从0到10的变化过程中，去更新视图的位置？或者其他想要的任何可能操作。 ValueAnimator animator = ValueAnimator.ofInt(0, 10); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int factor = (Integer) animation.getAnimatedValue(); &#125; &#125;); 1.5 动画插值：插值器的作用是根据时间运行的百分比来计算出当前属性改变的百分比，反映的是时间和动画进度（或属性变化）的关系，通过动画当前运行的时间，计算出当前动画的变化量。例如系统预制的线性插值器（LinearInterpolator），时间和动画进度的函数关系是y &#x3D; x的直线方程，就表示当前动画是均速变化的。而当时间和动画进度的函数关系式表达为y&#x3D;x^2的时候，那表示动画的变化率随着时间的增加而增加的，在视觉上就表现为加速动画。在理论上就可以通过动画插值器实现不同快慢效果的动画。 在系统预制的插值器有：AccelerateInterpolator（加速插值器），AccelerateDecelerateInterpolator（加速减速插值器）， LinearInterpolator（线性插值器），BounceInterpolator（弹跳插值器），AnticipateInterpolator（回荡秋千插值器），AnticipateOvershootInterpolator， CycleInterpolator（正弦周期变化插值器），OvershootInterpolator ，我们也可以通过实现TimeTimeInterpolator或者Interpolatorr接口实现自定义的插值器。 1.6 动画估值器估值器的作用是，根据插值器结果（当前属性变化的百分比）计算出当前属性的值，系统预置的有IntEvaluator（针对整型属性）、FloatEvaluator（针对浮点型属性）和ArgbEvaluator（针对Color属性）。满足的关系是： 二、桌面文件夹伸缩动画2.1 IOS文件夹动画原理类似IOS的文件夹视图展开动画，简单说就是针对文件夹视图的一个伸缩动画，而视觉效果上的动画目标就是如何让文件夹的桌面图标和文件夹打开后的视图看起来是一个进行放大缩小的整体，处理伸缩动画的关键：1.伸缩的前后比例（多少）2.伸缩视图的中心坐标（相对于哪一点做伸缩）针对伸缩的比例，应该是文件夹展开前后文件夹内应用图标大小确定的。针对如何确定伸缩视图的中心坐标，就需要首先确定坐标系，就是中心点是相对哪个坐标系确定的！伸缩动画坐标系的的原点在哪里？ 伸缩动画的坐标系是由当前缩放视图确定的，当前视图的左上角为坐标系的原点，即（0，0）点。 原点的水平向右方向为横坐标的正方向，平行手机屏幕垂直向下方向未纵坐标的正方向。 确定了伸缩的坐标系，现在的问题就是如何确定伸缩中心点的坐标，在我们学习数学的过程中，老师教我们如何把实际问题抽象成数学问题，就像小学时经典的船在顺流和逆流中航形的问题一样。面对视图的缩放，我们能够想到的应该就是多边形的相似问题，看待现在的文件夹视图，可以抽象成一个矩形，在以矩形的左上角确定的坐标系里，从一个Size放大（或缩小）到另一个Size，在矩形长和宽变化比例相同的情况下，变化前后的矩形就是两个相似矩形，这样就可以很容易的画出下图. 针对相似多边形对应点连线或者反向延长线相交于一点的原理，我们很容易得出下面的关系，即伸缩前后大小、伸缩比例和伸缩点坐标的关系式： h2 = offset / (1-scale) 通过上面的公式，就很容易计算出文件夹视图伸缩动画的pivotX和pivotY的值计算代码： // set scale pivotX and pivotY int leftOffset = folderIconRect.left - folderViewLeft; int topOffset = folderIconRect.top - folderViewTop; float height = folderHeight * mFolderScale; float delta = ((float) folderHeight) / (folderHeight - height); float folderPivotX = leftOffset * delta; float folderPivotY = topOffset * delta; 但是这对展开动画仅仅解决缩放动画的问题还原因不够，因为缩放动画只是针对文件夹的视图，而针对文件夹内每个应用图标视图也应该有相应的动画，为什么？因为按照文件夹的位置进行的缩放动画，无法保证文件夹内的应用图标和文件夹图标上应用的缩略图完全重合。联想到学习过的中学物理知识，这个场景就好像你一定能够想到了分运动和合运动，火车在轨道上行驶，人在火车内行走，问人相对与地面的运动是什么样子的？整体文件夹的视图相对于它的伸缩中心点进行伸缩，文件夹视图内的应用图标相对于文件夹视图进行位移，效果又会是什么样子的？想明白这个，相信你一定能感受到选择一个正确的坐标系是多么重要。 抽象出了运动的理论，那计算的思路就是计算出每个应用缩略图标相对于文件夹图标的位置，计算出文件夹展开后每个应用图标相对于文件夹视图的相对位置，接合每个应用图标的伸缩比例，就能得到每个应用图标在文件夹视图的缩放过程中需要完成的位移，简单来说就是Folder的视图在缩放，Folder里的App图标在Folder视图上做相应的位移，结果你会发现是这样： 处理完文件夹视图的问题，相信这个问题已经解决大半了，剩下的就是桌面上其他图标的移动，简单来说还是缩放动画，只需要让每个图标的缩放点和Folder视图的缩放点相对于屏幕坐标系重合就可以了。 2.2 总结1.处理动画问题首先确定动画起始和终止的状态，根据状态确定动画类型。2.确定动画坐标系。动画坐标系如何确定取决与动画改变的属性，对于缩放动画，缩放改变是视图本身，那缩放动画的坐标系一定是相对于视图自己建立的，左上角是原点。而对于位移动画，改变translationX和X的值都能实现位置上的改变，但是他们表示的含义不一样，translationX是相对于视图本身而言的，X是相对于父布局而言的，那他们建立的坐标系肯定也不一样。3.根据建立坐标系完成动画，把复杂的合运动分解成在不同坐标系上的分运动简单求解。 三、参考文档Android 属性动画（Property Animation） 完全解析 （上）Android 属性动画（Property Animation） 完全解析 （下）Android Project Butter分析http://developer.android.com/reference/android/view/Choreographer.htmlhttp://developer.android.com/reference/android/view/Choreographer.FrameCallback.htmlhttps://github.com/samchen2009/android_uml 转载请标明出处病已blog https://ivonhoe.github.io/","categories":[{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/categories/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/tags/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"}]}],"categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"方案与设计","slug":"方案与设计","permalink":"https://ivonhoe.github.io/categories/%E6%96%B9%E6%A1%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"学习总结","slug":"学习总结","permalink":"https://ivonhoe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"Flutter","slug":"Flutter","permalink":"https://ivonhoe.github.io/categories/Flutter/"},{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/categories/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"name":"Android插件化","slug":"Android插件化","permalink":"https://ivonhoe.github.io/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96/"},{"name":"Android安全","slug":"Android安全","permalink":"https://ivonhoe.github.io/categories/Android%E5%AE%89%E5%85%A8/"},{"name":"翻译","slug":"翻译","permalink":"https://ivonhoe.github.io/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://ivonhoe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"flutter","slug":"flutter","permalink":"https://ivonhoe.github.io/tags/flutter/"},{"name":"ASM","slug":"ASM","permalink":"https://ivonhoe.github.io/tags/ASM/"},{"name":"SPI","slug":"SPI","permalink":"https://ivonhoe.github.io/tags/SPI/"},{"name":"设计模式","slug":"设计模式","permalink":"https://ivonhoe.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JVM","slug":"JVM","permalink":"https://ivonhoe.github.io/tags/JVM/"},{"name":"Bitmap","slug":"Bitmap","permalink":"https://ivonhoe.github.io/tags/Bitmap/"},{"name":"BitmapFactory","slug":"BitmapFactory","permalink":"https://ivonhoe.github.io/tags/BitmapFactory/"},{"name":"绘制与动画","slug":"绘制与动画","permalink":"https://ivonhoe.github.io/tags/%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"name":"anr","slug":"anr","permalink":"https://ivonhoe.github.io/tags/anr/"},{"name":"无痕埋点","slug":"无痕埋点","permalink":"https://ivonhoe.github.io/tags/%E6%97%A0%E7%97%95%E5%9F%8B%E7%82%B9/"},{"name":"插件化","slug":"插件化","permalink":"https://ivonhoe.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"},{"name":"网络","slug":"网络","permalink":"https://ivonhoe.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"ndk","slug":"ndk","permalink":"https://ivonhoe.github.io/tags/ndk/"},{"name":"对称加密","slug":"对称加密","permalink":"https://ivonhoe.github.io/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"},{"name":"非对称加密","slug":"非对称加密","permalink":"https://ivonhoe.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"},{"name":"数字签名，数字证书","slug":"数字签名，数字证书","permalink":"https://ivonhoe.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%EF%BC%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"},{"name":"Android","slug":"Android","permalink":"https://ivonhoe.github.io/tags/Android/"},{"name":"Android源码","slug":"Android源码","permalink":"https://ivonhoe.github.io/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"移动安全","slug":"移动安全","permalink":"https://ivonhoe.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"},{"name":"多线程","slug":"多线程","permalink":"https://ivonhoe.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"死锁","slug":"死锁","permalink":"https://ivonhoe.github.io/tags/%E6%AD%BB%E9%94%81/"},{"name":"Zygote","slug":"Zygote","permalink":"https://ivonhoe.github.io/tags/Zygote/"},{"name":"Copy-on-write","slug":"Copy-on-write","permalink":"https://ivonhoe.github.io/tags/Copy-on-write/"},{"name":"Delvik","slug":"Delvik","permalink":"https://ivonhoe.github.io/tags/Delvik/"},{"name":"GC","slug":"GC","permalink":"https://ivonhoe.github.io/tags/GC/"},{"name":"转载","slug":"转载","permalink":"https://ivonhoe.github.io/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"翻译","slug":"翻译","permalink":"https://ivonhoe.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"内存","slug":"内存","permalink":"https://ivonhoe.github.io/tags/%E5%86%85%E5%AD%98/"},{"name":"dump heap","slug":"dump-heap","permalink":"https://ivonhoe.github.io/tags/dump-heap/"},{"name":"Drawable","slug":"Drawable","permalink":"https://ivonhoe.github.io/tags/Drawable/"},{"name":"dex2jar","slug":"dex2jar","permalink":"https://ivonhoe.github.io/tags/dex2jar/"},{"name":"Gradle","slug":"Gradle","permalink":"https://ivonhoe.github.io/tags/Gradle/"},{"name":"去广告","slug":"去广告","permalink":"https://ivonhoe.github.io/tags/%E5%8E%BB%E5%B9%BF%E5%91%8A/"},{"name":"源码编译","slug":"源码编译","permalink":"https://ivonhoe.github.io/tags/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"name":"生产者消费者模式","slug":"生产者消费者模式","permalink":"https://ivonhoe.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"数据解析","slug":"数据解析","permalink":"https://ivonhoe.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"},{"name":"产品分析","slug":"产品分析","permalink":"https://ivonhoe.github.io/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"},{"name":"Context","slug":"Context","permalink":"https://ivonhoe.github.io/tags/Context/"}]}